# diff -Naurw src.org/AboutFrame.java src/AboutFrame.java...
--- src.org/AboutFrame.java	2015-12-08 19:44:00.000000000 +0100
+++ src/AboutFrame.java	2016-03-16 12:18:19.264880402 +0100
@@ -1,5 +1,6 @@
+
 /*
- * Code by Federico García García.
+ * Code by Federico GarcÃ­a GarcÃ­a.
  * 08/11/2015.
  * 
  * Frame that shows the About info.
@@ -27,6 +28,7 @@
 import javax.swing.JPanel;
 
 public class AboutFrame extends JDialog implements WindowListener {
+	private static final long serialVersionUID = 1L;
 	private final String TITLE = "About CircuitMod";
 	private final String NAMES_TITLE = "Brought to you by:";
 	private final String [] NAMES  = {"federoggio", "munukuntla4313", "fgg192"};
@@ -35,15 +37,9 @@
 	
 	private final String LICENSE_TITLE   = "GNU GENERAL PUBLIC LICENSE";
 	private final String LICENSE_VERSION = "Version 3, 29 June 2007";
-	private final String LICENSE         =
-											"<HTML>"
-											+"Copyright (C) 2007 Free Software Foundation, Inc. "
-											+"&lt;http://fsf.org/&gt;"
-											+"<br>"
-											+"Everyone is permitted to copy and distribute verbatim copies"
-											+"<br>"
-											+"of this license document, but changing it is not allowed."
-											+"</HTML>";
+	private final String LICENSE = "<HTML>" + "Copyright (C) 2007 Free Software Foundation, Inc. "
+			+ "&lt;http://fsf.org/&gt;" + "<br>" + "Everyone is permitted to copy and distribute verbatim copies"
+			+ "<br>" + "of this license document, but changing it is not allowed." + "</HTML>";
 	
 	private final String WEBSITE_TITLE = "Website";
 	private final String WEBSITE = "http://circuitmod.sourceforge.net/";
@@ -77,7 +73,11 @@
 		panelTitle.add(labelImage);
 		
 		JLabel labelProgramName = new JLabel(cirSim.PROGRAM_NAME+"         ");
-		labelProgramName.setFont(new Font("Serif", Font.BOLD, font.getSize()*2)); // Set big bold serif font
+		labelProgramName.setFont(new Font("Serif", Font.BOLD, font.getSize() * 2)); // Set
+																					// big
+																					// bold
+																					// serif
+																					// font
 		panelTitle.add(labelProgramName);
 		
 		panelMain.add(panelTitle);
@@ -91,18 +91,8 @@
 		}
 		
 		// We use HTML for new lines.
-		JLabel labelNamesTitle = new JLabel(
-				"<html>"
-				+ "<center>"
-				+ "<b>"+NAMES_TITLE+"</b>"
-				+ "<br>"
-				+ names
-				+ "<br>"
-				+ "<b>"+NAME_ORIGINAL_TITLE+"</b>"
-				+ "<br>"
-				+ NAME_ORIGINAL
-				+ "</center>"
-				+ "</html>");
+		JLabel labelNamesTitle = new JLabel("<html>" + "<center>" + "<b>" + NAMES_TITLE + "</b>" + "<br>" + names
+				+ "<br>" + "<b>" + NAME_ORIGINAL_TITLE + "</b>" + "<br>" + NAME_ORIGINAL + "</center>" + "</html>");
 		panelNames.add(labelNamesTitle);
 		
 		panelMain.add(panelNames);
@@ -110,16 +100,8 @@
 		// Create panel with license.
 		JPanel panelLicense = new JPanel();
 		
-		JLabel labelLicense = new JLabel(
-				"<html>"
-				+ "<center>"
-				+ "<b>"+LICENSE_TITLE+"</b>"
-				+ "<br>"
-				+ LICENSE_VERSION
-				+ "</center>"
-				+"<br>"
-				+ LICENSE
-				+ "</html>");
+		JLabel labelLicense = new JLabel("<html>" + "<center>" + "<b>" + LICENSE_TITLE + "</b>" + "<br>"
+				+ LICENSE_VERSION + "</center>" + "<br>" + LICENSE + "</html>");
 		
 		panelLicense.add(labelLicense);
 		
@@ -178,7 +160,6 @@
         });
     }
 	
-	
 	@Override
 	public void windowActivated(WindowEvent arg0) {
 		// TODO Auto-generated method stub
# diff -Naurw src.org/ACRailElm.java src/ACRailElm.java...
--- src.org/ACRailElm.java	2015-12-05 20:46:40.000000000 +0100
+++ src/ACRailElm.java	2016-03-16 13:04:11.971298534 +0100
@@ -1,7 +1,10 @@
-
-
     class ACRailElm extends RailElm {
-	public ACRailElm(int xx, int yy) { super(xx, yy, WF_AC); }
+	public ACRailElm(int xx, int yy) {
+		super(xx, yy, WF_AC);
+	}
+
 	@Override
-	Class getDumpClass() { return RailElm.class; }
+	Class<RailElm> getDumpClass() {
+		return RailElm.class;
+	}
     }
# diff -Naurw src.org/ACVoltageElm.java src/ACVoltageElm.java...
--- src.org/ACVoltageElm.java	2015-12-05 20:47:00.000000000 +0100
+++ src/ACVoltageElm.java	2016-03-16 13:04:19.835156579 +0100
@@ -1,6 +1,10 @@
-
     class ACVoltageElm extends VoltageElm {
-	public ACVoltageElm(int xx, int yy) { super(xx, yy, WF_AC); }
+	public ACVoltageElm(int xx, int yy) {
+		super(xx, yy, WF_AC);
+	}
+
 	@Override
-	Class getDumpClass() { return VoltageElm.class; }
+	Class<VoltageElm> getDumpClass() {
+		return VoltageElm.class;
+	}
     }
# diff -Naurw src.org/ADCElm.java src/ADCElm.java...
--- src.org/ADCElm.java	2015-12-05 20:46:58.000000000 +0100
+++ src/ADCElm.java	2016-03-16 13:04:28.259004515 +0100
@@ -1,16 +1,24 @@
-
 import java.util.StringTokenizer;
 
 class ADCElm extends ChipElm {
-    public ADCElm(int xx, int yy) { super(xx, yy); }
-    public ADCElm(int xa, int ya, int xb, int yb, int f,
-		  StringTokenizer st) {
+	public ADCElm(int xx, int yy) {
+		super(xx, yy);
+	}
+
+	public ADCElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	super(xa, ya, xb, yb, f, st);
     }
+
     @Override
-	String getChipName() { return "ADC"; }
+	String getChipName() {
+		return "ADC";
+	}
+
     @Override
-	boolean needsBits() { return true; }
+	boolean needsBits() {
+		return true;
+	}
+
     @Override
 	void setupPins() {
 	sizeX = 2;
@@ -25,6 +33,7 @@
 	pins[bits+1] = new Pin(sizeY-1, SIDE_W, "V+");
 	allocNodes();
     }
+
     @Override
 	void execute() {
 	int imax = (1<<bits)-1;
@@ -36,11 +45,19 @@
 	for (i = 0; i != bits; i++)
 	    pins[i].value = ((ival & (1<<i)) != 0);
     }
+
     @Override
-	int getVoltageSourceCount() { return bits; }
-    @Override
-	int getPostCount() { return bits+2; }
+	int getVoltageSourceCount() {
+		return bits;
+	}
+
     @Override
-	int getDumpType() { return 167; }
+	int getPostCount() {
+		return bits + 2;
 }
     
+	@Override
+	int getDumpType() {
+		return 167;
+	}
+}
# diff -Naurw src.org/AnalogSwitch2Elm.java src/AnalogSwitch2Elm.java...
--- src.org/AnalogSwitch2Elm.java	2015-12-05 20:47:00.000000000 +0100
+++ src/AnalogSwitch2Elm.java	2016-03-16 13:04:40.950775410 +0100
@@ -1,4 +1,3 @@
-
 import java.awt.Graphics;
 import java.awt.Point;
 import java.util.StringTokenizer;
@@ -7,13 +6,14 @@
     public AnalogSwitch2Elm(int xx, int yy) {
 	super(xx, yy);
     }
-    public AnalogSwitch2Elm(int xa, int ya, int xb, int yb, int f,
-			    StringTokenizer st) {
+
+	public AnalogSwitch2Elm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	super(xa, ya, xb, yb, f, st);
     }
 
     final int openhs = 16;
     Point swposts[], swpoles[], ctlPoint;
+
     @Override
 	void setPoints() {
 	super.setPoints();
@@ -24,8 +24,11 @@
 	interpPoint2(point1, point2, swposts[0], swposts[1], 1, openhs);
 	ctlPoint = interpPoint(point1, point2, .5, openhs);
     }
+
     @Override
-	int getPostCount() { return 4; }
+	int getPostCount() {
+		return 4;
+	}
 
     @Override
 	void draw(Graphics g) {
@@ -58,8 +61,11 @@
 	Point getPost(int n) {
 	return (n == 0) ? point1 : (n == 3) ? ctlPoint : swposts[n-1];
     }
+
     @Override
-	int getDumpType() { return 160; }
+	int getDumpType() {
+		return 160;
+	}
 
     @Override
 	void calculateCurrent() {
@@ -75,6 +81,7 @@
 	sim.stampNonLinear(nodes[1]);
 	sim.stampNonLinear(nodes[2]);
     }
+
     @Override
 	void doStep() {
 	open = (volts[3] < 2.5);
@@ -95,10 +102,10 @@
 	    return false;
 	return true;
     }
+
     @Override
 	void getInfo(String arr[]) {
 	arr[0] = "analog switch (SPDT)";
 	arr[1] = "I = " + getCurrentDText(getCurrent());
     }
 }
-
# diff -Naurw src.org/AnalogSwitchElm.java src/AnalogSwitchElm.java...
--- src.org/AnalogSwitchElm.java	2015-12-05 20:47:00.000000000 +0100
+++ src/AnalogSwitchElm.java	2016-03-16 13:04:47.422658583 +0100
@@ -1,4 +1,3 @@
-
 import java.awt.Checkbox;
 import java.awt.Graphics;
 import java.awt.Point;
@@ -7,32 +6,39 @@
 class AnalogSwitchElm extends CircuitElm {
     final int FLAG_INVERT = 1;
     double resistance, r_on, r_off;
+
     public AnalogSwitchElm(int xx, int yy) {
 	super(xx, yy);
 	r_on = 20;
 	r_off = 1e10;
     }
-    public AnalogSwitchElm(int xa, int ya, int xb, int yb, int f,
-			   StringTokenizer st) {
+
+	public AnalogSwitchElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	super(xa, ya, xb, yb, f);
 	r_on = 20;
 	r_off = 1e10;
 	try {
 	    r_on = new Double(st.nextToken()).doubleValue();
 	    r_off = new Double(st.nextToken()).doubleValue();
-	} catch (Exception e) { }
+		} catch (Exception e) {
+		}
 	
     }
+
     @Override
 	String dump() {
 	return super.dump() + " " + r_on + " " + r_off;
     }
     
     @Override
-	int getDumpType() { return 159; }
+	int getDumpType() {
+		return 159;
+	}
+
     boolean open;
 	
     Point ps, point3, lead3;
+
     @Override
 	void setPoints() {
 	super.setPoints();
@@ -62,6 +68,7 @@
 	    doDots(g);
 	drawPosts(g);
     }
+
     @Override
 	void calculateCurrent() {
 	current = (volts[0]-volts[1])/resistance;
@@ -69,13 +76,16 @@
 	
     // we need this to be able to change the matrix for each step
     @Override
-	boolean nonLinear() { return true; }
+	boolean nonLinear() {
+		return true;
+	}
 
     @Override
 	void stamp() {
 	sim.stampNonLinear(nodes[0]);
 	sim.stampNonLinear(nodes[1]);
     }
+
     @Override
 	void doStep() {
 	open = (volts[2] < 2.5);
@@ -84,6 +94,7 @@
 	resistance = (open) ? r_off : r_on;
 	sim.stampResistor(nodes[0], nodes[1], resistance);
     }
+
     @Override
 	void drag(int xx, int yy) {
 	xx = sim.snapGrid(xx);
@@ -96,15 +107,21 @@
 	int q2 = (q1/2) % sim.gridSize;
 	if (q2 != 0)
 	    return;
-	x2 = xx; y2 = yy;
+		x2 = xx;
+		y2 = yy;
 	setPoints();
     }
+
     @Override
-	int getPostCount() { return 3; }
+	int getPostCount() {
+		return 3;
+	}
+
     @Override
 	Point getPost(int n) {
 	return (n == 0) ? point1 : (n == 1) ? point2 : point3;
     }
+
     @Override
 	void getInfo(String arr[]) {
 	arr[0] = "analog switch";
@@ -113,6 +130,7 @@
 	arr[3] = "I = " + getCurrentDText(getCurrent());
 	arr[4] = "Vc = " + getVoltageText(volts[2]);
     }
+
     // we have to just assume current will flow either way, even though that
     // might cause singular matrix errors
     @Override
@@ -121,12 +139,12 @@
 	    return false;
 	return true;
     }
+
     @Override
 	public EditInfo getEditInfo(int n) {
 	if (n == 0) {
 	    EditInfo ei = new EditInfo("", 0, -1, -1);
-	    ei.checkbox = new Checkbox("Normally closed",
-				       (flags & FLAG_INVERT) != 0);
+			ei.checkbox = new Checkbox("Normally closed", (flags & FLAG_INVERT) != 0);
 	    return ei;
 	}
 	if (n == 1)
@@ -135,16 +153,14 @@
 	    return new EditInfo("Off Resistance (ohms)", r_off, 0, 0);
 	return null;
     }
+
     @Override
 	public void setEditValue(int n, EditInfo ei) {
 	if (n == 0)
-	    flags = (ei.checkbox.getState()) ?
-		(flags | FLAG_INVERT) :
-		(flags & ~FLAG_INVERT);
+			flags = (ei.checkbox.getState()) ? (flags | FLAG_INVERT) : (flags & ~FLAG_INVERT);
 	if (n == 1 && ei.value > 0)
 	    r_on = ei.value;
 	if (n == 2 && ei.value > 0)
 	    r_off = ei.value;
     }
 }
-
# diff -Naurw src.org/AndGateElm.java src/AndGateElm.java...
--- src.org/AndGateElm.java	2015-12-05 20:47:00.000000000 +0100
+++ src/AndGateElm.java	2016-03-16 13:04:54.006539736 +0100
@@ -1,13 +1,15 @@
-
 import java.awt.Point;
 import java.util.StringTokenizer;
 
     class AndGateElm extends GateElm {
-	public AndGateElm(int xx, int yy) { super(xx, yy); }
-	public AndGateElm(int xa, int ya, int xb, int yb, int f,
-			  StringTokenizer st) {
+	public AndGateElm(int xx, int yy) {
+		super(xx, yy);
+	}
+
+	public AndGateElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	    super(xa, ya, xb, yb, f, st);
 	}
+
 	@Override
 	void setPoints() {
 	    super.setPoints();
@@ -20,9 +22,7 @@
 	    for (i = 0; i != 10; i++) {
 		double a = i*.1;
 		double b = Math.sqrt(1-a*a);
-		interpPoint2(lead1, lead2,
-			     triPoints[i+1], triPoints[21-i],
-			     .5+a/2, b*hs2);
+			interpPoint2(lead1, lead2, triPoints[i + 1], triPoints[21 - i], .5 + a / 2, b * hs2);
 	    }
 	    triPoints[11] = new Point(lead2);
 	    if (isInverting()) {
@@ -31,8 +31,12 @@
 	    }
 	    gatePoly = createPolygon(triPoints);
 	}
+
 	@Override
-	String getGateName() { return "AND gate"; }
+	String getGateName() {
+		return "AND gate";
+	}
+
 	@Override
 	boolean calcFunction() {
 	    int i;
@@ -41,6 +45,9 @@
 		f &= getInput(i);
 	    return f;
 	}
+
 	@Override
-	int getDumpType() { return 150; }
+	int getDumpType() {
+		return 150;
+	}
     }
# diff -Naurw src.org/AntennaElm.java src/AntennaElm.java...
--- src.org/AntennaElm.java	2015-12-05 20:47:02.000000000 +0100
+++ src/AntennaElm.java	2016-03-16 13:05:09.514259803 +0100
@@ -1,31 +1,38 @@
-
-
 import java.util.StringTokenizer;
 
     class AntennaElm extends RailElm {
-	public AntennaElm(int xx, int yy) { super(xx, yy, WF_DC); }
-	public AntennaElm(int xa, int ya, int xb, int yb, int f,
-		       StringTokenizer st) {
+	public AntennaElm(int xx, int yy) {
+		super(xx, yy, WF_DC);
+	}
+
+	public AntennaElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	    super(xa, ya, xb, yb, f, st);
 	    waveform = WF_DC;
 	}
+
 	double fmphase;
+
 	@Override
 	void stamp() {
 	    sim.stampVoltageSource(0, nodes[0], voltSource);
 	}
+
 	@Override
 	void doStep() {
 	    sim.updateVoltageSource(0, nodes[0], voltSource, getVoltage());
 	}
+
 	@Override
 	double getVoltage() {
 	    fmphase += 2*pi*(2200+Math.sin(2*pi*sim.t*13)*100)*sim.timeStep;
 	    double fm = 3*Math.sin(fmphase);
-	    return Math.sin(2*pi*sim.t*3000)*(1.3+Math.sin(2*pi*sim.t*12))*3 +
-	           Math.sin(2*pi*sim.t*2710)*(1.3+Math.sin(2*pi*sim.t*13))*3 +
-		   Math.sin(2*pi*sim.t*2433)*(1.3+Math.sin(2*pi*sim.t*14))*3 + fm;
+		return Math.sin(2 * pi * sim.t * 3000) * (1.3 + Math.sin(2 * pi * sim.t * 12)) * 3
+				+ Math.sin(2 * pi * sim.t * 2710) * (1.3 + Math.sin(2 * pi * sim.t * 13)) * 3
+				+ Math.sin(2 * pi * sim.t * 2433) * (1.3 + Math.sin(2 * pi * sim.t * 14)) * 3 + fm;
 	}
+
 	@Override
-	int getDumpType() { return 'A'; }
+	int getDumpType() {
+		return 'A';
+	}
     }
# diff -Naurw src.org/CapacitorElm.java src/CapacitorElm.java...
--- src.org/CapacitorElm.java	2015-12-05 20:47:00.000000000 +0100
+++ src/CapacitorElm.java	2016-03-16 13:05:16.522133303 +0100
@@ -1,4 +1,3 @@
-
 import java.awt.Checkbox;
 import java.awt.Color;
 import java.awt.Graphics;
@@ -10,34 +9,45 @@
 	double compResistance, voltdiff;
 	Point plate1[], plate2[];
 	public static final int FLAG_BACK_EULER = 2;
+
 	public CapacitorElm(int xx, int yy) {
 	    super(xx, yy);
 	    capacitance = 1e-5;
 	}
-	public CapacitorElm(int xa, int ya, int xb, int yb, int f,
-			    StringTokenizer st) {
+
+	public CapacitorElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	    super(xa, ya, xb, yb, f);
 	    capacitance = new Double(st.nextToken()).doubleValue();
 	    voltdiff = new Double(st.nextToken()).doubleValue();
 	}
-	boolean isTrapezoidal() { return (flags & FLAG_BACK_EULER) == 0; }
+
+	boolean isTrapezoidal() {
+		return (flags & FLAG_BACK_EULER) == 0;
+	}
+
 	@Override
 	void setNodeVoltage(int n, double c) {
 	    super.setNodeVoltage(n, c);
 	    voltdiff = volts[0]-volts[1];
 	}
+
 	@Override
 	void reset() {
 	    current = curcount = 0;
 	    // put small charge on caps when reset to start oscillators
 	    voltdiff = 1e-3;
 	}
+
 	@Override
-	int getDumpType() { return 'c'; }
+	int getDumpType() {
+		return 'c';
+	}
+
 	@Override
 	String dump() {
 	    return super.dump() + " " + capacitance + " " + voltdiff;
 	}
+
 	@Override
 	void setPoints() {
 	    super.setPoints();
@@ -82,6 +92,7 @@
 		drawValues(g, s, hs);
 	    }
 	}
+
 	@Override
 	void stamp() {
 	    // capacitor companion model using trapezoidal approximation
@@ -97,14 +108,17 @@
 	    sim.stampRightSide(nodes[0]);
 	    sim.stampRightSide(nodes[1]);
 	}
+
 	@Override
 	void startIteration() {
 	    if (isTrapezoidal())
 		curSourceValue = -voltdiff/compResistance-current;
 	    else
 		curSourceValue = -voltdiff/compResistance;
-	    //System.out.println("cap " + compResistance + " " + curSourceValue + " " + current + " " + voltdiff);
+		// System.out.println("cap " + compResistance + " " + curSourceValue + "
+		// " + current + " " + voltdiff);
 	}
+
 	@Override
 	void calculateCurrent() {
 	    double voltdiff = volts[0] - volts[1];
@@ -114,11 +128,14 @@
 	    if (compResistance > 0)
 		current = voltdiff/compResistance + curSourceValue;
 	}
+
 	double curSourceValue;
+
 	@Override
 	void doStep() {
 	    sim.stampCurrentSource(nodes[0], nodes[1], curSourceValue);
  	}
+
 	@Override
 	void getInfo(String arr[]) {
 	    arr[0] = "capacitor";
@@ -128,6 +145,7 @@
 	    //double v = getVoltageDiff();
 	    //arr[4] = "U = " + getUnitText(.5*capacitance*v*v, "J");
 	}
+
 	@Override
 	public EditInfo getEditInfo(int n) {
 	    if (n == 0)
@@ -139,6 +157,7 @@
 	    }
 	    return null;
 	}
+
 	@Override
 	public void setEditValue(int n, EditInfo ei) {
 	    if (n == 0 && ei.value > 0)
@@ -150,6 +169,9 @@
 		    flags |= FLAG_BACK_EULER;
 	    }
 	}
+
 	@Override
-	boolean needsShortcut() { return true; }
+	boolean needsShortcut() {
+		return true;
+	}
     }
# diff -Naurw src.org/CC2Elm.java src/CC2Elm.java...
--- src.org/CC2Elm.java	2015-12-05 20:47:02.000000000 +0100
+++ src/CC2Elm.java	2016-03-16 13:05:25.653968464 +0100
@@ -1,22 +1,34 @@
-
 import java.awt.Graphics;
 import java.util.StringTokenizer;
 
     class CC2Elm extends ChipElm {
 	double gain;
-	public CC2Elm(int xx, int yy) { super(xx, yy); gain = 1; }
-	public CC2Elm(int xx, int yy, int g) { super(xx, yy); gain = g; }
-	public CC2Elm(int xa, int ya, int xb, int yb, int f,
-		      StringTokenizer st) {
+
+	public CC2Elm(int xx, int yy) {
+		super(xx, yy);
+		gain = 1;
+	}
+
+	public CC2Elm(int xx, int yy, int g) {
+		super(xx, yy);
+		gain = g;
+	}
+
+	public CC2Elm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	    super(xa, ya, xb, yb, f, st);
 	    gain = new Double(st.nextToken()).doubleValue();
 	}
+
 	@Override
 	String dump() {
 	    return super.dump() + " " + gain;
 	}
+
 	@Override
-	String getChipName() { return "CC2"; }
+	String getChipName() {
+		return "CC2";
+	}
+
 	@Override
 	void setupPins() {
 	    sizeX = 2;
@@ -27,6 +39,7 @@
 	    pins[1] = new Pin(2, SIDE_W, "Y");
 	    pins[2] = new Pin(1, SIDE_E, "Z");
 	}
+
 	@Override
 	void getInfo(String arr[]) {
 	    arr[0] = (gain == 1) ? "CCII+" : "CCII-";
@@ -34,6 +47,7 @@
 	    arr[2] = "Z = " + getVoltageText(volts[2]);
 	    arr[3] = "I = " + getCurrentText(pins[0].current);
 	}
+
 	//boolean nonLinear() { return true; }
 	@Override
 	void stamp() {
@@ -43,21 +57,36 @@
 	    // Z current = gain * X current
 	    sim.stampCCCS(0, nodes[2], pins[0].voltSource, gain);
 	}
+
 	@Override
 	void draw(Graphics g) {
 	    pins[2].current = pins[0].current * gain;
 	    drawChip(g);
 	}
+
 	@Override
-	int getPostCount() { return 3; }
+	int getPostCount() {
+		return 3;
+	}
+
 	@Override
-	int getVoltageSourceCount() { return 1; }
+	int getVoltageSourceCount() {
+		return 1;
+	}
+
 	@Override
-	int getDumpType() { return 179; }
+	int getDumpType() {
+		return 179;
+	}
     }
 
 class CC2NegElm extends CC2Elm {
-    public CC2NegElm(int xx, int yy) { super(xx, yy, -1); }
+	public CC2NegElm(int xx, int yy) {
+		super(xx, yy, -1);
+	}
+
     @Override
-	Class getDumpClass() { return CC2Elm.class; }
+	Class<CC2Elm> getDumpClass() {
+		return CC2Elm.class;
+	}
 }
# diff -Naurw src.org/CD4017.java src/CD4017.java...
--- src.org/CD4017.java	2015-04-21 12:23:29.000000000 +0200
+++ src/CD4017.java	2016-03-16 13:05:34.353811423 +0100
@@ -1,19 +1,24 @@
-
 import java.util.StringTokenizer;
 
 class CD4017 extends ChipCDElm {
 	
-    public CD4017(int xx, int yy) { super(xx, yy); }
+	public CD4017(int xx, int yy) {
+		super(xx, yy);
+	}
     
     public CD4017(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
     	super(xa, ya, xb, yb, f, st);
     }
     
     @Override
-	boolean needsBits() { return true; }
+	boolean needsBits() {
+		return true;
+	}
     
     @Override
-	String getChipName() { return "Decade Counter (4017)"; }
+	String getChipName() {
+		return "Decade Counter (4017)";
+	}
     
     int loadPin;
     int Q;
@@ -84,16 +89,16 @@
 	    }
 	    
 	    // Clock Inhibit / Clock Enable
-	    if(pins[1].value) return;
+		if (pins[1].value)
+			return;
 	    
 	    // Clock Counter
 	    if (pins[0].value && !lastClock) {
-	    	System.out.println(pins[0].value + " X " + lastClock + "-");
+			// System.out.println(pins[0].value + " X " + lastClock + "-");
 	    	
 	    	Q += 1;
-	    	if(Q>9) Q=0;
-	    	
-
+			if (Q > 9)
+				Q = 0;
 	    	
 	    }
 
@@ -101,10 +106,17 @@
     }
     
     @Override
-	int getVoltageSourceCount() { return 11; }	// Outputs
+	int getVoltageSourceCount() {
+		return 11;
+	} // Outputs
+
     @Override
-	int getPostCount() { return 3+11; }			// Total Pins
+	int getPostCount() {
+		return 3 + 11;
+	} // Total Pins
+
     @Override
-	int getDumpType() { return 189; }
+	int getDumpType() {
+		return 189;
+	}
 }
-    
\ No newline at end of file
# diff -Naurw src.org/CD4024.java src/CD4024.java...
--- src.org/CD4024.java	2015-04-06 03:51:34.000000000 +0200
+++ src/CD4024.java	2016-03-16 13:05:43.773641387 +0100
@@ -1,18 +1,20 @@
-
 import java.util.StringTokenizer;
 
 class CD4024 extends ChipCDElm {
 	final int FLAG_ENABLE = 2;
 	final int bits = 7;
 
-	public CD4024(int xx, int yy) { super(xx, yy); }
+	public CD4024(int xx, int yy) {
+		super(xx, yy);
+	}
 
-	public CD4024(int xa, int ya, int xb, int yb, int f,
-				StringTokenizer st) {
+	public CD4024(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 		super(xa, ya, xb, yb, f, st);
 	}
 
-	String getChipName() { return "Counter 7-bit (4024)"; }
+	String getChipName() {
+		return "Counter 7-bit (4024)";
+	}
 
 	void setupPins() {
 		sizeX = 2;	//Columns
@@ -35,9 +37,13 @@
 		return bits+2;
 	}
 
-	boolean hasEnable() { return (flags & FLAG_ENABLE) != 0; }
+	boolean hasEnable() {
+		return (flags & FLAG_ENABLE) != 0;
+	}
 
-	int getVoltageSourceCount() { return bits; }
+	int getVoltageSourceCount() {
+		return bits;
+	}
 
 	void execute() {
 		boolean en = true;
@@ -63,5 +69,7 @@
 		lastClock = pins[0].value;
 	}
 
-	int getDumpType() { return 182; }
+	int getDumpType() {
+		return 182;
+	}
 }
# diff -Naurw src.org/CD4028.java src/CD4028.java...
--- src.org/CD4028.java	2013-12-15 05:22:33.000000000 +0100
+++ src/CD4028.java	2016-03-16 13:05:50.477520379 +0100
@@ -1,17 +1,22 @@
-
 import java.util.StringTokenizer;
 
 class CD4028 extends ChipCDElm {
 	
-    public CD4028(int xx, int yy) { super(xx, yy); }
+	public CD4028(int xx, int yy) {
+		super(xx, yy);
+	}
     
     public CD4028(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
     	super(xa, ya, xb, yb, f, st);
     }
     
-    boolean needsBits() { return true; }
+	boolean needsBits() {
+		return true;
+	}
     
-    String getChipName() { return "BCD-to-Decimal Decoder (4028)"; }
+	String getChipName() {
+		return "BCD-to-Decimal Decoder (4028)";
+	}
     
     int loadPin;
     
@@ -38,7 +43,8 @@
     	int[] bit = new int[4];
     	
     	for(int a=0; a<4; a++)
-    		if(pins[a].value == true) bit[a] = 1;
+			if (pins[a].value == true)
+				bit[a] = 1;
     	
     	int decimal;
     	decimal = bit[0]*1 + bit[1]*2 + bit[2]*4 + bit[3]*8;
@@ -55,20 +61,37 @@
     	pins[12].value = false;
     	pins[13].value = false;
     	
-    	if (decimal == 0) pins[4].value = true;
-    	if (decimal == 1) pins[5].value = true;
-    	if (decimal == 2) pins[6].value = true;
-    	if (decimal == 3) pins[7].value = true;
-    	if (decimal == 4) pins[8].value = true;
-    	if (decimal == 5) pins[9].value = true;
-    	if (decimal == 6) pins[10].value = true;
-    	if (decimal == 7) pins[11].value = true;
-    	if (decimal == 8) pins[12].value = true;
-    	if (decimal == 9) pins[13].value = true;
+		if (decimal == 0)
+			pins[4].value = true;
+		if (decimal == 1)
+			pins[5].value = true;
+		if (decimal == 2)
+			pins[6].value = true;
+		if (decimal == 3)
+			pins[7].value = true;
+		if (decimal == 4)
+			pins[8].value = true;
+		if (decimal == 5)
+			pins[9].value = true;
+		if (decimal == 6)
+			pins[10].value = true;
+		if (decimal == 7)
+			pins[11].value = true;
+		if (decimal == 8)
+			pins[12].value = true;
+		if (decimal == 9)
+			pins[13].value = true;
     }
     
-    int getVoltageSourceCount() { return bits+6; }
-    int getPostCount() { return bits*2+6; }
-    int getDumpType() { return 185; }
+	int getVoltageSourceCount() {
+		return bits + 6;
 }
     
\ No newline at end of file
+	int getPostCount() {
+		return bits * 2 + 6;
+	}
+
+	int getDumpType() {
+		return 185;
+	}
+}
# diff -Naurw src.org/CD4040.java src/CD4040.java...
--- src.org/CD4040.java	2015-04-06 06:08:29.000000000 +0200
+++ src/CD4040.java	2016-03-16 13:06:15.333071720 +0100
@@ -1,18 +1,20 @@
-//import java.awt.*;
 import java.util.StringTokenizer;
 
 class CD4040 extends ChipCDElm {
 	final int FLAG_ENABLE = 2;
 	final int bits = 12;
 
-	public CD4040(int xx, int yy) { super(xx, yy); }
+	public CD4040(int xx, int yy) {
+		super(xx, yy);
+	}
 
-	public CD4040(int xa, int ya, int xb, int yb, int f,
-				StringTokenizer st) {
+	public CD4040(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 		super(xa, ya, xb, yb, f, st);
 	}
 
-	String getChipName() { return "Counter 12-bit (4040)"; }
+	String getChipName() {
+		return "Counter 12-bit (4040)";
+	}
 
 	void setupPins() {
 		sizeX = 3;
@@ -40,9 +42,13 @@
 		return bits+2;
 	}
 
-	boolean hasEnable() { return (flags & FLAG_ENABLE) != 0; }
+	boolean hasEnable() {
+		return (flags & FLAG_ENABLE) != 0;
+	}
 
-	int getVoltageSourceCount() { return bits; }
+	int getVoltageSourceCount() {
+		return bits;
+	}
 
 	void execute() {
 		boolean en = true;
@@ -68,5 +74,7 @@
 		lastClock = pins[0].value;
 	}
 
-	int getDumpType() { return 183; }
+	int getDumpType() {
+		return 183;
+	}
 }
# diff -Naurw src.org/CD4511.java src/CD4511.java...
--- src.org/CD4511.java	2013-12-15 08:27:44.000000000 +0100
+++ src/CD4511.java	2016-03-16 13:06:23.856917861 +0100
@@ -1,4 +1,3 @@
-
 import java.util.StringTokenizer;
 
 class CD4511 extends ChipCDElm {
@@ -7,14 +6,18 @@
 	boolean le;
 	int loadPin;
 	
-    public CD4511(int xx, int yy) { super(xx, yy); }
+	public CD4511(int xx, int yy) {
+		super(xx, yy);
+	}
     
     public CD4511(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
     	super(xa, ya, xb, yb, f, st);
     }
     
     @Override
-    String getChipName() { return "BCD to 7-Segm Decoder (4511)"; }
+	String getChipName() {
+		return "BCD to 7-Segm Decoder (4511)";
+	}
     
     void setupPins() {
     	sizeX = 2;
@@ -55,7 +58,6 @@
 	    	return;
     	}
     	
-    	
     	// BI Blanking
     	if(pins[12].value == false) {
     		pins[4].value = false;
@@ -68,12 +70,11 @@
 	    	return;
     	}
     	
-
-    	
     	int[] bit = new int[4];
     	
     	for(a=0; a<4; a++)
-    		if(pins[a].value == true) bit[a] = 1;
+			if (pins[a].value == true)
+				bit[a] = 1;
     	
     	int decimal;
     	decimal = bit[0]*1 + bit[1]*2 + bit[2]*4 + bit[3]*8;
@@ -189,7 +190,6 @@
 	    	pins[10].value = false;
     	}
     	
-    	
     	// LE latch enable
     	if(pins[11].value == false) {
     		le = false;
@@ -210,8 +210,15 @@
     	}
     }
     
-    int getVoltageSourceCount() { return 7; }
-    int getPostCount() { return 7+7; }
-    int getDumpType() { return 184; }
+	int getVoltageSourceCount() {
+		return 7;
+	}
+
+	int getPostCount() {
+		return 7 + 7;
 }
     
\ No newline at end of file
+	int getDumpType() {
+		return 184;
+	}
+}
# diff -Naurw src.org/ChipCDElm.java src/ChipCDElm.java...
--- src.org/ChipCDElm.java	2014-10-07 07:28:16.000000000 +0200
+++ src/ChipCDElm.java	2016-03-16 12:18:19.948868088 +0100
@@ -75,16 +75,14 @@
 			drawDots(g, b, a, p.curcount);
 			
 			if (p.bubble) {
-				g.setColor(sim.printableCheckItem.getState() ? Color.white
-						: Color.black);
+				g.setColor(sim.printableCheckItem.getState() ? Color.white : Color.black);
 				drawThickCircle(g, p.bubbleX, p.bubbleY, 1);
 				g.setColor(lightGrayColor);
 				drawThickCircle(g, p.bubbleX, p.bubbleY, 3);
 			}
 			g.setColor(whiteColor);
 			int sw = fm.stringWidth(p.text);
-			g.drawString(p.text, p.textloc.x - sw / 2,
-					p.textloc.y + fm.getAscent() / 2);
+			g.drawString(p.text, p.textloc.x - sw / 2, p.textloc.y + fm.getAscent() / 2);
 			
 			if (p.lineOver) {
 				int ya = p.textloc.y - fm.getAscent() / 2;
@@ -170,7 +168,7 @@
 				return;
 			}
 		}
-		System.out.println("setVoltageSource failed for " + this);
+		// System.out.println("setVoltageSource failed for " + this);
 	}
 
 	@Override
@@ -198,8 +196,7 @@
 		for (i = 0; i != getPostCount(); i++) {
 			Pin p = pins[i];
 			if (p.output)
-				sim.updateVoltageSource(0, nodes[i], p.voltSource, p.value ? 5
-						: 0);
+				sim.updateVoltageSource(0, nodes[i], p.voltSource, p.value ? 5 : 0);
 		}
 	}
 
@@ -323,8 +320,7 @@
 		boolean lineOver, bubble, clock, output, value, state;
 		double curcount, current;
 
-		void setPoint(int px, int py, int dx, int dy, int dax, int day, int sx,
-				int sy) {
+		void setPoint(int px, int py, int dx, int dy, int dax, int day, int sx, int sy) {
 			if ((flags & FLAG_FLIP_X) != 0) {
 				dx = -dx;
 				dax = -dax;
# diff -Naurw src.org/ChipElm.java src/ChipElm.java...
--- src.org/ChipElm.java	2013-12-15 02:51:16.000000000 +0100
+++ src/ChipElm.java	2016-03-16 12:18:19.316879466 +0100
@@ -79,16 +79,14 @@
 			drawDots(g, b, a, p.curcount);
 			
 			if (p.bubble) {
-				g.setColor(sim.printableCheckItem.getState() ? Color.white
-						: Color.black);
+				g.setColor(sim.printableCheckItem.getState() ? Color.white : Color.black);
 				drawThickCircle(g, p.bubbleX, p.bubbleY, 1);
 				g.setColor(lightGrayColor);
 				drawThickCircle(g, p.bubbleX, p.bubbleY, 3);
 			}
 			g.setColor(whiteColor);
 			int sw = fm.stringWidth(p.text);
-			g.drawString(p.text, p.textloc.x - sw / 2,
-					p.textloc.y + fm.getAscent() / 2);
+			g.drawString(p.text, p.textloc.x - sw / 2, p.textloc.y + fm.getAscent() / 2);
 			
 			if (p.lineOver) {
 				int ya = p.textloc.y - fm.getAscent() / 2;
@@ -174,7 +172,7 @@
 				return;
 			}
 		}
-		System.out.println("setVoltageSource failed for " + this);
+		// System.out.println("setVoltageSource failed for " + this);
 	}
 
 	@Override
@@ -202,8 +200,7 @@
 		for (i = 0; i != getPostCount(); i++) {
 			Pin p = pins[i];
 			if (p.output)
-				sim.updateVoltageSource(0, nodes[i], p.voltSource, p.value ? 5
-						: 0);
+				sim.updateVoltageSource(0, nodes[i], p.voltSource, p.value ? 5 : 0);
 		}
 	}
 
@@ -327,8 +324,7 @@
 		boolean lineOver, bubble, clock, output, value, state;
 		double curcount, current;
 
-		void setPoint(int px, int py, int dx, int dy, int dax, int day, int sx,
-				int sy) {
+		void setPoint(int px, int py, int dx, int dy, int dax, int day, int sx, int sy) {
 			if ((flags & FLAG_FLIP_X) != 0) {
 				dx = -dx;
 				dax = -dax;
# diff -Naurw src.org/CircuitCanvas.java src/CircuitCanvas.java...
--- src.org/CircuitCanvas.java	2015-12-22 08:07:29.000000000 +0100
+++ src/CircuitCanvas.java	2016-03-16 13:06:53.692379324 +0100
@@ -1,4 +1,3 @@
-
 import java.awt.Canvas;
 import java.awt.Dimension;
 import java.awt.Graphics;
# diff -Naurw src.org/CircuitElm.java src/CircuitElm.java...
--- src.org/CircuitElm.java	2015-12-05 20:47:02.000000000 +0100
+++ src/CircuitElm.java	2016-03-16 13:07:00.828250521 +0100
@@ -1,4 +1,3 @@
-
 import java.awt.Color;
 import java.awt.Font;
 import java.awt.FontMetrics;
@@ -6,7 +5,6 @@
 import java.awt.Point;
 import java.awt.Polygon;
 import java.awt.Rectangle;
-import java.text.DecimalFormat;
 import java.text.NumberFormat;
 
 /*
@@ -35,9 +33,18 @@
     Rectangle boundingBox;
     boolean noDiagonal;
     public boolean selected;
-    int getDumpType() { return 0; }
-    Class getDumpClass() { return getClass(); }
-    int getDefaultFlags() { return 0; }
+
+	int getDumpType() {
+		return 0;
+	}
+
+	Class<? extends CircuitElm> getDumpClass() {
+		return getClass();
+	}
+
+	int getDefaultFlags() {
+		return 0;
+	}
 
     static void initClass(CirSim s) {
 		unitsFont = new Font("SansSerif", 0, 10);
@@ -79,15 +86,18 @@
     }
     
     CircuitElm(int xa, int ya, int xb, int yb, int f) {
-		x = xa; y = ya; x2 = xb; y2 = yb; flags = f;
+		x = xa;
+		y = ya;
+		x2 = xb;
+		y2 = yb;
+		flags = f;
 		allocNodes();
 		initBoundingBox();
     }
     
     void initBoundingBox() {
 	boundingBox = new Rectangle();
-	boundingBox.setBounds(min(x, x2), min(y, y2),
-			      abs(x2-x)+1, abs(y2-y)+1);
+		boundingBox.setBounds(min(x, x2), min(y, y2), abs(x2 - x) + 1, abs(y2 - y) + 1);
     }
     
     void allocNodes() {
@@ -97,8 +107,7 @@
     
     String dump() {
     	int t = getDumpType();
-		return (t < 127 ? ((char)t)+" " : t+" ") + x + " " + y + " " +
-		    x2 + " " + y2 + " " + flags;
+		return (t < 127 ? ((char) t) + " " : t + " ") + x + " " + y + " " + x2 + " " + y2 + " " + flags;
     }
     
     void reset() {
@@ -108,22 +117,41 @@
 		curcount = 0;
     }
     
-    void draw(Graphics g) {}   
-    void setCurrent(int x, double c) { current = c; }   
-    double getCurrent() { return current; }
-    void doStep() {}
-    void delete() {}
-    void startIteration() {}
-    double getPostVoltage(int x) { return volts[x]; }
+	void draw(@SuppressWarnings("unused") Graphics g) {
+	}
+
+	void setCurrent(@SuppressWarnings("unused") int x, double c) {
+		current = c;
+	}
+
+	double getCurrent() {
+		return current;
+	}
+
+	void doStep() {
+	}
+
+	void delete() {
+	}
+
+	void startIteration() {
+	}
+
+	double getPostVoltage(int x) {
+		return volts[x];
+	}
     
     void setNodeVoltage(int n, double c) {
 		volts[n] = c;
 		calculateCurrent();
     }
     
-    void calculateCurrent() {}
+	void calculateCurrent() {
+	}
+
     void setPoints() {
-	dx = x2-x; dy = y2-y;
+		dx = x2 - x;
+		dy = y2 - y;
 	dn = Math.sqrt(dx*dx+dy*dy);
 	dpx1 = dy/dn;
 	dpy1 = -dx/dn;
@@ -131,6 +159,7 @@
 	point1 = new Point(x , y );
 	point2 = new Point(x2, y2);
     }
+
     void calcLeads(int len) {
 	if (dn < len || len == 0) {
 	    lead1 = point1;
@@ -140,36 +169,43 @@
 	lead1 = interpPoint(point1, point2, (dn-len)/(2*dn));
 	lead2 = interpPoint(point1, point2, (dn+len)/(2*dn));
     }
+
     Point interpPoint(Point a, Point b, double f) {
 	Point p = new Point();
 	interpPoint(a, b, p, f);
 	return p;
     }
+
     void interpPoint(Point a, Point b, Point c, double f) {
-	int xpd = b.x-a.x;
-	int ypd = b.y-a.y;
-	/*double q = (a.x*(1-f)+b.x*f+.48);
-	  System.out.println(q + " " + (int) q);*/
+		// int xpd = b.x-a.x;
+		// int ypd = b.y-a.y;
+		/*
+		 * double q = (a.x*(1-f)+b.x*f+.48); System.out.println(q + " " + (int)
+		 * q);
+		 */
 	c.x = (int) Math.floor(a.x*(1-f)+b.x*f+.48);
 	c.y = (int) Math.floor(a.y*(1-f)+b.y*f+.48);
     }
+
     void interpPoint(Point a, Point b, Point c, double f, double g) {
-	int xpd = b.x-a.x;
-	int ypd = b.y-a.y;
+		// int xpd = b.x-a.x;
+		// int ypd = b.y-a.y;
 	int gx = b.y-a.y;
 	int gy = a.x-b.x;
 	g /= Math.sqrt(gx*gx+gy*gy);
 	c.x = (int) Math.floor(a.x*(1-f)+b.x*f+g*gx+.48);
 	c.y = (int) Math.floor(a.y*(1-f)+b.y*f+g*gy+.48);
     }
+
     Point interpPoint(Point a, Point b, double f, double g) {
 	Point p = new Point();
 	interpPoint(a, b, p, f, g);
 	return p;
     }
+
     void interpPoint2(Point a, Point b, Point c, Point d, double f, double g) {
-	int xpd = b.x-a.x;
-	int ypd = b.y-a.y;
+		// int xpd = b.x-a.x;
+		// int ypd = b.y-a.y;
 	int gx = b.y-a.y;
 	int gy = a.x-b.x;
 	g /= Math.sqrt(gx*gx+gy*gy);
@@ -178,6 +214,7 @@
 	d.x = (int) Math.floor(a.x*(1-f)+b.x*f-g*gx+.48);
 	d.y = (int) Math.floor(a.y*(1-f)+b.y*f-g*gy+.48);
     }
+
     void draw2Leads(Graphics g) {
 	// draw first lead
 	setVoltageColor(g, volts[0]);
@@ -187,6 +224,7 @@
 	setVoltageColor(g, volts[1]);
 	drawThickLine(g, lead2, point2);
     }
+
     Point [] newPointArray(int n) {
 	Point a[] = new Point[n];
 	while (n > 0)
@@ -226,6 +264,7 @@
 	poly.addPoint(p2.x, p2.y);
 	return poly;
     }
+
     Polygon createPolygon(Point a, Point b, Point c) {
 	Polygon p = new Polygon();
 	p.addPoint(a.x, a.y);
@@ -233,6 +272,7 @@
 	p.addPoint(c.x, c.y);
 	return p;
     }
+
     Polygon createPolygon(Point a, Point b, Point c, Point d) {
 	Polygon p = new Polygon();
 	p.addPoint(a.x, a.y);
@@ -241,6 +281,7 @@
 	p.addPoint(d.x, d.y);
 	return p;
     }
+
     Polygon createPolygon(Point a[]) {
 	Polygon p = new Polygon();
 	int i;
@@ -248,6 +289,7 @@
 	    p.addPoint(a[i].x, a[i].y);
 	return p;
     }
+
     void drag(int xx, int yy) {
 	xx = sim.snapGrid(xx);
 	yy = sim.snapGrid(yy);
@@ -258,16 +300,22 @@
 		yy = y;
 	    }
 	}
-	x2 = xx; y2 = yy;
+		x2 = xx;
+		y2 = yy;
 	setPoints();
     }
+
     void move(int dx, int dy) {
-	x += dx; y += dy; x2 += dx; y2 += dy;
-	boundingBox.move(dx, dy);
+		x += dx;
+		y += dy;
+		x2 += dx;
+		y2 += dy;
+		boundingBox.setLocation(dx, dy);
 	setPoints();
     }
 
-    // determine if moving this element by (dx,dy) will put it on top of another element
+	// determine if moving this element by (dx,dy) will put it on top of another
+	// element
     boolean allowMove(int dx, int dy) {
 	int nx = x+dx;
 	int ny = y+dy;
@@ -286,12 +334,15 @@
     
     void movePoint(int n, int dx, int dy) {
 	if (n == 0) {
-	    x += dx; y += dy;
+			x += dx;
+			y += dy;
 	} else {
-	    x2 += dx; y2 += dy;
+			x2 += dx;
+			y2 += dy;
 	}
 	setPoints();
     }
+
     void drawPosts(Graphics g) {
 	int i;
 	for (i = 0; i != getPostCount(); i++) {
@@ -299,60 +350,111 @@
 	    drawPost(g, p.x, p.y, nodes[i]);
 	}
     }
-    void stamp() {}
-    int getVoltageSourceCount() { return 0; }
-    int getInternalNodeCount() { return 0; }
-    void setNode(int p, int n) { nodes[p] = n; }
-    void setVoltageSource(int n, int v) { voltSource = v; }
-    int getVoltageSource() { return voltSource; }
+
+	void stamp() {
+	}
+
+	int getVoltageSourceCount() {
+		return 0;
+	}
+
+	int getInternalNodeCount() {
+		return 0;
+	}
+
+	void setNode(int p, int n) {
+		nodes[p] = n;
+	}
+
+	void setVoltageSource(@SuppressWarnings("unused") int n, int v) {
+		voltSource = v;
+	}
+
+	int getVoltageSource() {
+		return voltSource;
+	}
+
     double getVoltageDiff() {
 	return volts[0] - volts[1];
     }
-    boolean nonLinear() { return false; }
-    int getPostCount() { return 2; }
-    int getNode(int n) { return nodes[n]; }
+
+	boolean nonLinear() {
+		return false;
+	}
+
+	int getPostCount() {
+		return 2;
+	}
+
+	int getNode(int n) {
+		return nodes[n];
+	}
+
     Point getPost(int n) {
 	return (n == 0) ? point1 : (n == 1) ? point2 : null;
     }
+
     void drawPost(Graphics g, int x0, int y0, int n) {
-	if (sim.dragElm == null && !needsHighlight() &&
-	    sim.getCircuitNode(n).links.size() == 2)
+		if (sim.dragElm == null && !needsHighlight() && sim.getCircuitNode(n).links.size() == 2)
 	    return;
-	if (sim.mouseMode == CirSim.MODE_DRAG_ROW ||
-	    sim.mouseMode == CirSim.MODE_DRAG_COLUMN)
+		if (sim.mouseMode == CirSim.MODE_DRAG_ROW || sim.mouseMode == CirSim.MODE_DRAG_COLUMN)
 	    return;
 	drawPost(g, x0, y0);
     }
+
     void drawPost(Graphics g, int x0, int y0) {
 	g.setColor(whiteColor);
 	g.fillOval(x0-3, y0-3, 7, 7);
     }
+
     void setBbox(int x1, int y1, int x2, int y2) {
-	if (x1 > x2) { int q = x1; x1 = x2; x2 = q; }
-	if (y1 > y2) { int q = y1; y1 = y2; y2 = q; }
+		if (x1 > x2) {
+			int q = x1;
+			x1 = x2;
+			x2 = q;
+		}
+		if (y1 > y2) {
+			int q = y1;
+			y1 = y2;
+			y2 = q;
+		}
 	boundingBox.setBounds(x1, y1, x2-x1+1, y2-y1+1);
     }
+
     void setBbox(Point p1, Point p2, double w) {
 	setBbox(p1.x, p1.y, p2.x, p2.y);
-	int gx = p2.y-p1.y;
-	int gy = p1.x-p2.x;
+		// int gx = p2.y-p1.y;
+		// int gy = p1.x-p2.x;
 	int dpx = (int) (dpx1*w);
 	int dpy = (int) (dpy1*w);
 	adjustBbox(p1.x+dpx, p1.y+dpy, p1.x-dpx, p1.y-dpy);
     }
+
     void adjustBbox(int x1, int y1, int x2, int y2) {
-	if (x1 > x2) { int q = x1; x1 = x2; x2 = q; }
-	if (y1 > y2) { int q = y1; y1 = y2; y2 = q; }
+		if (x1 > x2) {
+			int q = x1;
+			x1 = x2;
+			x2 = q;
+		}
+		if (y1 > y2) {
+			int q = y1;
+			y1 = y2;
+			y2 = q;
+		}
 	x1 = min(boundingBox.x, x1);
 	y1 = min(boundingBox.y, y1);
 	x2 = max(boundingBox.x+boundingBox.width-1,  x2);
 	y2 = max(boundingBox.y+boundingBox.height-1, y2);
 	boundingBox.setBounds(x1, y1, x2-x1, y2-y1);
     }
+
     void adjustBbox(Point p1, Point p2) {
 	adjustBbox(p1.x, p1.y, p2.x, p2.y);
     }
-    boolean isCenteredText() { return false; }
+
+	boolean isCenteredText() {
+		return false;
+	}
 	
     void drawCenteredText(Graphics g, String s, int x, int y, boolean cx) {
 	FontMetrics fm = g.getFontMetrics();
@@ -360,8 +462,7 @@
 	if (cx)
 	    x -= w/2;
 	g.drawString(s, x, y+fm.getAscent()/2);
-	adjustBbox(x, y-fm.getAscent()/2,
-		   x+w, y+fm.getAscent()/2+fm.getDescent());
+		adjustBbox(x, y - fm.getAscent() / 2, x + w, y + fm.getAscent() / 2 + fm.getDescent());
     }
     
     void drawValues(Graphics g, String s, double hs) {
@@ -391,9 +492,9 @@
 	    g.drawString(s, xx, yc+dpy+ya);
 	}
     }
-    void drawCoil(Graphics g, int hs, Point p1, Point p2,
-		  double v1, double v2) {
-	double len = distance(p1, p2);
+
+	void drawCoil(Graphics g, int hs, Point p1, Point p2, double v1, double v2) {
+		// double len = distance(p1, p2);
 	int segments = 30; // 10*(int) (len/10);
 	int i;
 	double segf = 1./segments;
@@ -411,6 +512,7 @@
 	    ps1.setLocation(ps2);
 	}
     }
+
     static void drawThickLine(Graphics g, int x, int y, int x2, int y2) {
 	g.drawLine(x, y, x2, y2);
 	g.drawLine(x+1, y, x2+1, y2);
@@ -452,9 +554,11 @@
     static String getVoltageDText(double v) {
 	return getUnitText(Math.abs(v), "V");
     }
+
     static String getVoltageText(double v) {
 	return getUnitText(v, "V");
     }
+
     static String getUnitText(double v, String u) {
 	double va = Math.abs(v);
 	if (va < 1e-14)
@@ -475,6 +579,7 @@
 	    return showFormat.format(v*1e-6) + " M" + u;
 	return showFormat.format(v*1e-9) + " G" + u;
     }
+
     static String getShortUnitText(double v, String u) {
 	double va = Math.abs(v);
 	if (va < 1e-13)
@@ -495,9 +600,11 @@
 	    return shortFormat.format(v*1e-6) + "M" + u;
 	return shortFormat.format(v*1e-9) + "G" + u;
     }
+
     static String getCurrentText(double i) {
 	return getUnitText(i, "A");
     }
+
     static String getCurrentDText(double i) {
 	return getUnitText(Math.abs(i), "A");
     }
@@ -505,60 +612,72 @@
     void updateDotCount() {
 	curcount = updateDotCount(current, curcount);
     }
+
     double updateDotCount(double cur, double cc) {
 	if (sim.stoppedCheck.getState())
 	    return cc;
 	double cadd = cur*currentMult;
-	/*if (cur != 0 && cadd <= .05 && cadd >= -.05)
-	  cadd = (cadd < 0) ? -.05 : .05;*/
+		/*
+		 * if (cur != 0 && cadd <= .05 && cadd >= -.05) cadd = (cadd < 0) ? -.05
+		 * : .05;
+		 */
 	cadd %= 8;
-	/*if (cadd > 8)
-	  cadd = 8;
-	  if (cadd < -8)
-	  cadd = -8;*/
+		/*
+		 * if (cadd > 8) cadd = 8; if (cadd < -8) cadd = -8;
+		 */
 	return cc + cadd;
     }
+
     void doDots(Graphics g) {
 	updateDotCount();
 	if (sim.dragElm != this)
 	    drawDots(g, point1, point2, curcount);
     }
-    void doAdjust() {}
-    void setupAdjust() {}
-    void getInfo(String arr[]) {
+
+	void doAdjust() {
+	}
+
+	void setupAdjust() {
+	}
+
+	void getInfo(@SuppressWarnings("unused") String arr[]) {
     }
+
     int getBasicInfo(String arr[]) {
 	arr[1] = "I = " + getCurrentDText(getCurrent());
 	arr[2] = "Vd = " + getVoltageDText(getVoltageDiff());
 	return 3;
     }
+
     void setVoltageColor(Graphics g, double volts) {
 	if (needsHighlight()) {
 	    g.setColor(selectColor);
 	    return;
 	}
 	if (!sim.voltsCheckItem.getState()) {
-	    if (!sim.powerCheckItem.getState()) // && !conductanceCheckItem.getState())
+			if (!sim.powerCheckItem.getState()) // &&
+												// !conductanceCheckItem.getState())
 		g.setColor(whiteColor);
 	    return;
 	}
-	int c = (int) ((volts+voltageRange)*(colorScaleCount-1)/
-		       (voltageRange*2));
+		int c = (int) ((volts + voltageRange) * (colorScaleCount - 1) / (voltageRange * 2));
 	if (c < 0)
 	    c = 0;
 	if (c >= colorScaleCount)
 	    c = colorScaleCount-1;
 	g.setColor(colorScale[c]);
     }
-    void setPowerColor(Graphics g, boolean yellow) {
-	/*if (conductanceCheckItem.getState()) {
-	  setConductanceColor(g, current/getVoltageDiff());
-	  return;
-	  }*/
+
+	void setPowerColor(Graphics g, @SuppressWarnings("unused") boolean yellow) {
+		/*
+		 * if (conductanceCheckItem.getState()) { setConductanceColor(g,
+		 * current/getVoltageDiff()); return; }
+		 */
 	if (!sim.powerCheckItem.getState())
 	    return;
 	setPowerColor(g, getPower());
     }
+
     void setPowerColor(Graphics g, double w0) {
 	w0 *= powerMult;
 	//System.out.println(w);
@@ -567,14 +686,15 @@
 	    w = 1;
 	int rg = 128+(int) (w*127);
 	int b  = (int) (128*(1-w));
-	/*if (yellow)
-	  g.setColor(new Color(rg, rg, b));
-	  else */
+		/*
+		 * if (yellow) g.setColor(new Color(rg, rg, b)); else
+		 */
 	if (w0 > 0)
 	    g.setColor(new Color(rg, b, b));
 	else
 	    g.setColor(new Color(b, rg, b));
     }
+
     void setConductanceColor(Graphics g, double w0) {
 	w0 *= powerMult;
 	//System.out.println(w);
@@ -584,39 +704,91 @@
 	int rg = (int) (w*255);
 	g.setColor(new Color(rg, rg, rg));
     }
-    double getPower() { return getVoltageDiff()*current; }
+
+	double getPower() {
+		return getVoltageDiff() * current;
+	}
+
     double getScopeValue(int x) {
 	return (x == 1) ? getPower() : getVoltageDiff();
     }
+
     String getScopeUnits(int x) {
 	return (x == 1) ? "W" : "V";
     }
+
     @Override
-	public EditInfo getEditInfo(int n) { return null; }
+	public EditInfo getEditInfo(int n) {
+		return null;
+	}
+
     @Override
-	public void setEditValue(int n, EditInfo ei) {}
-    boolean getConnection(int n1, int n2) { return true; }
-    boolean hasGroundConnection(int n1) { return false; }
-    boolean isWire() { return false; }
-    boolean canViewInScope() { return getPostCount() <= 2; }
+	public void setEditValue(int n, EditInfo ei) {
+	}
+
+	boolean getConnection(@SuppressWarnings("unused") int n1, @SuppressWarnings("unused") int n2) {
+		return true;
+	}
+
+	boolean hasGroundConnection(@SuppressWarnings("unused") int n1) {
+		return false;
+	}
+
+	boolean isWire() {
+		return false;
+	}
+
+	boolean canViewInScope() {
+		return getPostCount() <= 2;
+	}
+
     boolean comparePair(int x1, int x2, int y1, int y2) {
 	return ((x1 == y1 && x2 == y2) || (x1 == y2 && x2 == y1));
     }
-    boolean needsHighlight() { return sim.mouseElm == this || selected; }
-    boolean isSelected() { return selected; }
-    void setSelected(boolean x) { selected = x; }
+
+	boolean needsHighlight() {
+		return sim.mouseElm == this || selected;
+	}
+
+	boolean isSelected() {
+		return selected;
+	}
+
+	void setSelected(boolean x) {
+		selected = x;
+	}
+
     void selectRect(Rectangle r) {
 	selected = r.intersects(boundingBox);
     }
-    static int abs(int x) { return x < 0 ? -x : x; }
-    static int sign(int x) { return (x < 0) ? -1 : (x == 0) ? 0 : 1; }
-    static int min(int a, int b) { return (a < b) ? a : b; }
-    static int max(int a, int b) { return (a > b) ? a : b; }
+
+	static int abs(int x) {
+		return x < 0 ? -x : x;
+	}
+
+	static int sign(int x) {
+		return (x < 0) ? -1 : (x == 0) ? 0 : 1;
+	}
+
+	static int min(int a, int b) {
+		return (a < b) ? a : b;
+	}
+
+	static int max(int a, int b) {
+		return (a > b) ? a : b;
+	}
+
     static double distance(Point p1, Point p2) {
 	double x = p1.x-p2.x;
 	double y = p1.y-p2.y;
 	return Math.sqrt(x*x+y*y);
     }
-    Rectangle getBoundingBox() { return boundingBox; }
-    boolean needsShortcut() { return false; }
+
+	Rectangle getBoundingBox() {
+		return boundingBox;
+	}
+
+	boolean needsShortcut() {
+		return false;
+	}
 }
# diff -Naurw src.org/CircuitLayout.java src/CircuitLayout.java...
--- src.org/CircuitLayout.java	2015-12-05 20:46:58.000000000 +0100
+++ src/CircuitLayout.java	2016-03-17 09:05:02.675227802 +0100
@@ -1,4 +1,3 @@
-
 import java.awt.Choice;
 import java.awt.Component;
 import java.awt.Container;
@@ -9,27 +8,35 @@
 import java.awt.Scrollbar;
 
 class CircuitLayout implements LayoutManager {
-    public CircuitLayout() {}
+	public CircuitLayout() {
+	}
+
     @Override
-	public void addLayoutComponent(String name, Component c) {}
+	public void addLayoutComponent(String name, Component c) {
+	}
+
     @Override
-	public void removeLayoutComponent(Component c) {}
+	public void removeLayoutComponent(Component c) {
+	}
+
     @Override
 	public Dimension preferredLayoutSize(Container target) {
 	return new Dimension(500, 500);
     }
+
     @Override
 	public Dimension minimumLayoutSize(Container target) {
 	return new Dimension(100,100);
     }
+
     @Override
 	public void layoutContainer(Container target) {
-	Insets insets = target.insets();
-	int targetw = target.size().width - insets.left - insets.right;
+		Insets insets = target.getInsets();
+		int targetw = target.getSize().width - insets.left - insets.right;
 	int cw = targetw* 8/10;
-	int targeth = target.size().height - (insets.top+insets.bottom);
-	target.getComponent(0).move(insets.left, insets.top);
-	target.getComponent(0).resize(cw, targeth);
+		int targeth = target.getSize().height - (insets.top + insets.bottom);
+		target.getComponent(0).setLocation(insets.left, insets.top);
+		target.getComponent(0).setSize(cw, targeth);
 	int barwidth = targetw - cw;
 	cw += insets.left;
 	int i;
@@ -46,8 +53,8 @@
 		    h += d.height/5;
 		    d.width = barwidth;
 		}
-		m.move(cw, h);
-		m.resize(d.width, d.height);
+				m.setLocation(cw, h);
+				m.setSize(d.width, d.height);
 		h += d.height;
 	    }
 	}
# diff -Naurw src.org/CircuitMod.java src/CircuitMod.java...
--- src.org/CircuitMod.java	2015-12-22 08:08:50.000000000 +0100
+++ src/CircuitMod.java	2016-03-16 12:18:19.392878098 +0100
@@ -1,4 +1,3 @@
-
 import java.applet.Applet;
 import java.awt.Graphics;
 import java.awt.event.ComponentEvent;
@@ -6,12 +5,8 @@
 //import java.io.FileNotFoundException;
 //import java.io.PrintWriter;
 
-
 public class CircuitMod extends Applet implements ComponentListener {
 	
-	/**
-	 * 
-	 */
 	private static final long serialVersionUID = 1L;
 	static CirSim ogf;
 	
@@ -50,7 +45,8 @@
 					ogf.init(null);
 				}
 				
-				// When program finishes initializing, dispose logo and show program frame.
+				// When program finishes initializing, dispose logo and show
+				// program frame.
 				// Make it so that the logo is shown at least 1.5 seconds.
 				long timeElapsed = (System.nanoTime()-time)/1000000;
 				
@@ -78,7 +74,9 @@
 		}
 	}
 
-	public void toggleSwitch(int x) { ogf.toggleSwitch(x); }
+	public void toggleSwitch(int x) {
+		ogf.toggleSwitch(x);
+	}
 
 	@Override
 	public void paint(Graphics g) {
@@ -93,11 +91,18 @@
 	}
 
 	@Override
-	public void componentHidden(ComponentEvent e){}
+	public void componentHidden(ComponentEvent e) {
+	}
+
 	@Override
-	public void componentMoved(ComponentEvent e){}
+	public void componentMoved(ComponentEvent e) {
+	}
+
 	@Override
-	public void componentShown(ComponentEvent e) { showFrame(); }
+	public void componentShown(ComponentEvent e) {
+		showFrame();
+	}
+
 	@Override
 	public void componentResized(ComponentEvent e) {
 		if (ogf != null)
@@ -112,4 +117,3 @@
 		repaint();
 	}
 };
-
# diff -Naurw src.org/CircuitNode.java src/CircuitNode.java...
--- src.org/CircuitNode.java	2015-12-05 20:47:02.000000000 +0100
+++ src/CircuitNode.java	2016-03-16 13:07:46.015434900 +0100
@@ -1,9 +1,11 @@
-
 import java.util.Vector;
 
 class CircuitNode {
     int x, y;
-    Vector links;
+	Vector<CircuitNodeLink> links;
     boolean internal;
-    CircuitNode() { links = new Vector(); }
+
+	CircuitNode() {
+		links = new Vector<CircuitNodeLink>();
+	}
 }
# diff -Naurw src.org/CircuitNodeLink.java src/CircuitNodeLink.java...
--- src.org/CircuitNodeLink.java	2015-12-05 20:47:02.000000000 +0100
+++ src/CircuitNodeLink.java	2016-03-16 13:07:55.987254913 +0100
@@ -1,4 +1,3 @@
-
     class CircuitNodeLink {
 	int num;
 	CircuitElm elm;
# diff -Naurw src.org/CirSim.java src/CirSim.java...
--- src.org/CirSim.java	2015-12-22 08:11:07.000000000 +0100
+++ src/CirSim.java	2016-03-17 09:03:20.457064593 +0100
@@ -1,7 +1,3 @@
-
-
-// For information about the theory behind this, see Electronic Circuit & System Simulation Methods by Pillage
-
 import java.awt.Button;
 import java.awt.Checkbox;
 import java.awt.CheckboxMenuItem;
@@ -40,6 +36,7 @@
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FilterInputStream;
+import java.io.UnsupportedEncodingException;
 import java.lang.reflect.Constructor;
 import java.net.URL;
 import java.net.URLDecoder;
@@ -56,13 +53,11 @@
 import javax.swing.UIManager.LookAndFeelInfo;
 import javax.swing.UnsupportedLookAndFeelException;
 
-public class CirSim extends Frame
-implements ComponentListener, ActionListener, AdjustmentListener,
-MouseMotionListener, MouseListener, ItemListener {
+//For information about the theory behind this, see Electronic Circuit & System Simulation Methods by Pillage
+
+public class CirSim extends Frame implements ComponentListener, ActionListener, AdjustmentListener, MouseMotionListener,
+		MouseListener, ItemListener {
 
-	/**
-	 * 
-	 */
 	private static final long serialVersionUID = 1L;
 
 	final String PROGRAM_NAME = "CircuitMod v2.6";
@@ -86,10 +81,11 @@
 
 	static Container main;
 	Label titleLabel;
+	Label modeInfoLabel;
 	Button resetButton;
 	Button dumpMatrixButton;
-	MenuItem newItem, openItem, saveItem, saveAsItem, exportLinkItem, exitItem, undoItem, redoItem,
-	cutItem, copyItem, pasteItem, selectAllItem, optionsItem, aboutItem;
+	MenuItem newItem, openItem, saveItem, saveAsItem, exportLinkItem, exitItem, undoItem, redoItem, cutItem, copyItem,
+			pasteItem, selectAllItem, optionsItem, aboutItem;
 	Menu optionsMenu;
 	Checkbox stoppedCheck;
 	CheckboxMenuItem dotsCheckItem;
@@ -173,8 +169,7 @@
 	CircuitElm plotXElm, plotYElm;
 	int draggingPost;
 	SwitchElm heldSwitchElm;
-	double circuitMatrix[][], circuitRightSide[],
-	origRightSide[], origMatrix[][];
+	double circuitMatrix[][], circuitRightSide[], origRightSide[], origMatrix[][];
 	RowInfo circuitRowInfo[];
 	int circuitPermute[];
 	boolean circuitNonLinear;
@@ -188,8 +183,8 @@
 	static EditDialog editDialog;
 	static ImportDialog impDialog;
 	Class<?> dumpTypes[];
-	static String muString = "u";
-	static String ohmString = "ohm";
+	static String muString = "Î¼";
+	static String ohmString = "Î©";
 	String clipboard;
 	Rectangle circuitArea;
 	int circuitBottom;
@@ -197,9 +192,11 @@
 
 	int getrand(int x) {
 		int q = random.nextInt();
-		if (q < 0) q = -q;
+		if (q < 0)
+			q = -q;
 		return q % x;
 	}
+
 	CircuitCanvas cv;
 	CircuitMod applet;
 
@@ -228,19 +225,20 @@
 		
 		// Set native look and feel
 		try {
-			UIManager.setLookAndFeel(new com.sun.java.swing.plaf.windows.WindowsLookAndFeel());
+			UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
 		} catch (UnsupportedLookAndFeelException e) {
-			// Set Nimbus look and feel as alternative
+			// Set Metal look and feel as alternative
 			try {
 				for (LookAndFeelInfo info : UIManager.getInstalledLookAndFeels()) {
-					if ("Nimbus".equals(info.getName())) {
+					if ("Metal".equals(info.getName())) {
 						UIManager.setLookAndFeel(info.getClassName());
 						break;
 					}
 				}
 			} catch (Exception e2) {
+				e.printStackTrace();
 			}
-
+		} catch (ClassNotFoundException | InstantiationException | IllegalAccessException e) {
 			e.printStackTrace();
 		}
 	}
@@ -270,7 +268,7 @@
 					x = URLDecoder.decode(x, "UTF-8");
 					startCircuitText = x;
 				} catch (Exception e) {
-					System.out.println("can't decode " + x);
+					// System.out.println("can't decode " + x);
 					e.printStackTrace();
 				}
 			}
@@ -291,7 +289,8 @@
 			x = applet.getParameter("conventionalCurrent");
 			if (x != null && x.equalsIgnoreCase("true"))
 				convention = false;
-		} catch (Exception e) { }
+		} catch (Exception e) {
+		}
 
 		boolean euro = (euroResistor != null && euroResistor.equalsIgnoreCase("true"));
 		useFrame = (useFrameStr == null || !useFrameStr.equalsIgnoreCase("false"));
@@ -299,7 +298,6 @@
 			main = this;
 		else
 			main = applet;
-
 		String os = System.getProperty("os.name");
 		isMac = (os.indexOf("Mac ") == 0);
 		ctrlMetaKey = (isMac) ? "\u2318" : "Ctrl";
@@ -447,7 +445,6 @@
 		inputMenu.add(getClassCheckItem("Add Antenna", "AntennaElm"));
 		inputMenu.add(getClassCheckItem("Add Current Source", "CurrentElm"));
 
-
 		Menu activeMenu = new Menu("Active Components");
 		mainMenu.add(activeMenu);
 		activeMenu.add(getClassCheckItem("Add Diode", "DiodeElm"));
@@ -463,12 +460,14 @@
 		activeMenu.add(getClassCheckItem("Add Analog Switch (SPST)", "AnalogSwitchElm"));
 		activeMenu.add(getClassCheckItem("Add Analog Switch (SPDT)", "AnalogSwitch2Elm"));
 		activeMenu.add(getClassCheckItem("Add SCR", "SCRElm")); //177
-		//activeMenu.add(getClassCheckItem("Add Varactor/Varicap", "VaractorElm"));
+		// activeMenu.add(getClassCheckItem("Add Varactor/Varicap",
+		// "VaractorElm"));
 		activeMenu.add(getClassCheckItem("Add Tunnel Diode", "TunnelDiodeElm")); //175
 		activeMenu.add(getClassCheckItem("Add Triode", "TriodeElm")); //173
 		//activeMenu.add(getClassCheckItem("Add Diac", "DiacElm"));
 		//activeMenu.add(getClassCheckItem("Add Triac", "TriacElm"));
-		//activeMenu.add(getClassCheckItem("Add Photoresistor", "PhotoResistorElm")); // Alpha
+		// activeMenu.add(getClassCheckItem("Add Photoresistor",
+		// "PhotoResistorElm")); // Alpha
 		//activeMenu.add(getClassCheckItem("Add Thermistor", "ThermistorElm"));
 		activeMenu.add(getClassCheckItem("Add CCII+", "CC2Elm")); //179
 		activeMenu.add(getClassCheckItem("Add CCII-", "CC2NegElm"));
@@ -483,7 +482,6 @@
 		gateMenu.add(getClassCheckItem("Add XOR Gate", "XorGateElm"));
 		gateMenu.add(getClassCheckItem("Add ST Inverter", "InverterSTElm")); //186
 		
-
 		Menu chipMenu = new Menu("Chips");
 		mainMenu.add(chipMenu);
 		chipMenu.add(getClassCheckItem("Add D Flip-Flop", "DFlipFlopElm"));
@@ -498,7 +496,6 @@
 		chipMenu.add(getClassCheckItem("Add ADC", "ADCElm"));
 		chipMenu.add(getClassCheckItem("Add Latch", "LatchElm")); // 168
 
-
 		Menu displayMenu = new Menu("Display Devices");
 		mainMenu.add(displayMenu);
 		displayMenu.add(getClassCheckItem("Add Text", "TextElm"));
@@ -508,7 +505,6 @@
 		displayMenu.add(getClassCheckItem("Add LED Array", "LEDArrayElm")); //176
 		displayMenu.add(getClassCheckItem("Add Matrix 5x7", "Matrix5x7Elm")); // 180
 
-
 		Menu mychipMenu = new Menu("CD Series");
 		mainMenu.add(mychipMenu);
 		mychipMenu.add(getClassCheckItem("Add Counter 7-bit (4024)", "CD4024")); // 182
@@ -521,17 +517,11 @@
 		Menu otherMenu = new Menu("Other");
 		mainMenu.add(otherMenu);
 		otherMenu.add(getCheckItem("Drag All (Alt-drag)", "DragAll"));
-		otherMenu.add(getCheckItem(
-				isMac ? "Drag Row (Alt-S-drag, S-right)" :
-					"Drag Row (S-right)",
-				"DragRow"));
-		otherMenu.add(getCheckItem(
-				isMac ? "Drag Column (Alt-\u2318-drag, \u2318-right)" :
-					"Drag Column (C-right)",
+		otherMenu.add(getCheckItem(isMac ? "Drag Row (Alt-S-drag, S-right)" : "Drag Row (S-right)", "DragRow"));
+		otherMenu.add(getCheckItem(isMac ? "Drag Column (Alt-\u2318-drag, \u2318-right)" : "Drag Column (C-right)",
 				"DragColumn"));
 		otherMenu.add(getCheckItem("Drag Selected", "DragSelected"));
-		otherMenu.add(getCheckItem("Drag Post (" + ctrlMetaKey + "-drag)",
-				"DragPost"));
+		otherMenu.add(getCheckItem("Drag Post (" + ctrlMetaKey + "-drag)", "DragPost"));
 
 		mainMenu.add(getCheckItem("Select/Drag Selected (space or Shift-drag)", "Select"));
 		main.add(mainMenu);
@@ -552,37 +542,33 @@
 		speedBar.addAdjustmentListener(this);
 
 		main.add(new Label("Current Speed", Label.CENTER));
-		currentBar = new Scrollbar(Scrollbar.HORIZONTAL,
-				50, 1, 1, 100);
+		currentBar = new Scrollbar(Scrollbar.HORIZONTAL, 50, 1, 1, 100);
 		currentBar.addAdjustmentListener(this);
 		main.add(currentBar);
 
 		main.add(powerLabel = new Label("Power Brightness", Label.CENTER));
-		main.add(powerBar = new Scrollbar(Scrollbar.HORIZONTAL,
-				50, 1, 1, 100));
+		main.add(powerBar = new Scrollbar(Scrollbar.HORIZONTAL, 50, 1, 1, 100));
 		powerBar.addAdjustmentListener(this);
 		
-		//powerBar.disable();
-		//powerLabel.disable();
 		powerBar.setEnabled(false);
 		powerLabel.setEnabled(false);
 		
 		//main.add(new Label("CircuitMod"));
 
-		if (useFrame)
-			main.add(new Label(""));
-		Font f = new Font("SansSerif", 0, 10);
-
-		Label l;
-		l = new Label("Current Circuit:");
-		//l.setFont(f);
+		Font f = new Font("SansSerif", Font.BOLD, 12);
 
-		titleLabel = new Label("Label");
+		titleLabel = new Label("Untitled");
 		titleLabel.setFont(f);
 
+		modeInfoLabel = new Label("Select");
+		modeInfoLabel.setFont(f);
+
 		if (useFrame) {
-			main.add(l);
+			main.add(new Label(""));
+			main.add(new Label("Current Circuit"));
 			main.add(titleLabel);
+			main.add(new Label("Current Mode"));
+			main.add(modeInfoLabel);
 		}
 
 		setGrid();
@@ -621,8 +607,7 @@
 			setMenuBar(mb);
 		if(initCircuit != null) {
 			loadStartup(initCircuit);
-		}
-		else if (startCircuitText != null)
+		} else if (startCircuitText != null)
 			readSetup(startCircuitText);
 		else if (stopMessage == null && startCircuit != null)
 			readSetupFile(startCircuit, startLabel);
@@ -637,24 +622,25 @@
 			handleResize();
 			//resize(860, 640);			
 			//Dimension x = getSize();
-			//setLocation((screen.width  - x.width)/2, (screen.height - x.height)/2);
-		 	setBounds(
-		 			(screen.width  - 860)/2, 
-		 			(screen.height - 640)/2, 
-		 			860, 640
-		 	);
+			// move((screen.width - x.width)/2, (screen.height - x.height)/2);
+			// setBounds(
+			// (screen.width - 860)/2,
+			// (screen.height - 640)/2,
+			// 860, 640
+			// );
 			//show();
+			setSize(860, 640);
+			setLocationByPlatform(true);
 		 	setVisible(true);
 
 			// Start maximized
-			setExtendedState( getExtendedState()|MAXIMIZED_BOTH );
+			// setExtendedState( getExtendedState()|MAXIMIZED_BOTH );
 		} else {
 			if (!powerCheckItem.getState()) {
 				main.remove(powerBar);
 				main.remove(powerLabel);
 				main.validate();
 			}
-			//hide();
 			setVisible(false);
 			handleResize();
 			applet.validate();
@@ -728,7 +714,7 @@
 
 	CheckboxMenuItem getClassCheckItem(String s, String t) {
 		try {
-			Class c = Class.forName(t);
+			Class<?> c = Class.forName(t);
 			CircuitElm elm = constructElement(c, 0, 0);
 			register(c, elm);
 			int dt = 0;
@@ -750,18 +736,17 @@
 		return mi;
 	}
 
-	void register(Class c, CircuitElm elm) {
+	void register(Class<?> c, CircuitElm elm) {
 		int t = elm.getDumpType();
 		if (t == 0) {
 			System.out.println("no dump type: " + c);
 			return;
 		}
-		Class<Scope> dclass = elm.getDumpClass();
+		Class<? extends CircuitElm> dclass = elm.getDumpClass();
 		if (dumpTypes[t] == dclass)
 			return;
 		if (dumpTypes[t] != null) {
-			System.out.println("dump type conflict: " + c + " " +
-					dumpTypes[t]);
+			System.out.println("dump type conflict: " + c + " " + dumpTypes[t]);
 			return;
 		}
 		dumpTypes[t] = dclass;
@@ -773,8 +758,9 @@
 			return;
 		dbimage = main.createImage(winSize.width, winSize.height);
 		int h = winSize.height / 5;
-		/*if (h < 128 && winSize.height > 300)
-	  h = 128;*/
+		/*
+		 * if (h < 128 && winSize.height > 300) h = 128;
+		 */
 		circuitArea = new Rectangle(0, 0, winSize.width, winSize.height-h);
 		int i;
 		int minx = 1000, maxx = 0, miny = 1000, maxy = 0;
@@ -817,7 +803,7 @@
 		if (ev.id == Event.WINDOW_DESTROY) {
 			doExit();
 		}
-		return super.handleEvent(ev);
+		return true;
 	}
 
 	@Override
@@ -879,8 +865,10 @@
 					CircuitElm.currentMult = -CircuitElm.currentMult;
 			}
 			if (sysTime-secTime >= 1000) {
-				framerate = frames; steprate = steps;
-				frames = 0; steps = 0;
+				framerate = frames;
+				steprate = steps;
+				frames = 0;
+				steps = 0;
 				secTime = sysTime;
 			}
 			lastTime = sysTime;
@@ -893,12 +881,14 @@
 		for (i = 0; i != elmList.size(); i++) {
 			if (powerCheckItem.getState())
 				g.setColor(Color.gray);
-			/*else if (conductanceCheckItem.getState())
-	      g.setColor(Color.white);*/
+			/*
+			 * else if (conductanceCheckItem.getState())
+			 * g.setColor(Color.white);
+			 */
 			getElm(i).draw(g);
 		}
-		if (tempMouseMode == MODE_DRAG_ROW || tempMouseMode == MODE_DRAG_COLUMN ||
-				tempMouseMode == MODE_DRAG_POST || tempMouseMode == MODE_DRAG_SELECTED)
+		if (tempMouseMode == MODE_DRAG_ROW || tempMouseMode == MODE_DRAG_COLUMN || tempMouseMode == MODE_DRAG_POST
+				|| tempMouseMode == MODE_DRAG_SELECTED)
 			for (i = 0; i != elmList.size(); i++) {
 				CircuitElm ce = getElm(i);
 				ce.drawPost(g, ce.x , ce.y );
@@ -911,10 +901,9 @@
 			CircuitNode cn = getCircuitNode(i);
 			if (!cn.internal && cn.links.size() == 1) {
 				int bb = 0, j;
-				CircuitNodeLink cnl = (CircuitNodeLink) cn.links.elementAt(0);
+				CircuitNodeLink cnl = cn.links.elementAt(0);
 				for (j = 0; j != elmList.size(); j++)
-					if (cnl.elm != getElm(j) &&
-					getElm(j).boundingBox.contains(cn.x, cn.y))
+					if (cnl.elm != getElm(j) && getElm(j).boundingBox.contains(cn.x, cn.y))
 						bb++;
 				if (bb > 0) {
 					g.setColor(Color.red);
@@ -923,12 +912,11 @@
 				}
 			}
 		}
-		/*if (mouseElm != null) {
-	    g.setFont(oldfont);
-	    g.drawString("+", mouseElm.x+10, mouseElm.y);
-	    }*/
-		if (dragElm != null &&
-				(dragElm.x != dragElm.x2 || dragElm.y != dragElm.y2))
+		/*
+		 * if (mouseElm != null) { g.setFont(oldfont); g.drawString("+",
+		 * mouseElm.x+10, mouseElm.y); }
+		 */
+		if (dragElm != null && (dragElm.x != dragElm.x2 || dragElm.y != dragElm.y2))
 			dragElm.draw(g);
 		g.setFont(oldfont);
 		int ct = scopeCount;
@@ -947,13 +935,12 @@
 				if (mousePost == -1)
 					mouseElm.getInfo(info);
 				else
-					info[0] = "V = " +
-							CircuitElm.getUnitText(mouseElm.getPostVoltage(mousePost), "V");
-				/* //shownodes
-		for (i = 0; i != mouseElm.getPostCount(); i++)
-		    info[0] += " " + mouseElm.nodes[i];
-		if (mouseElm.getVoltageSourceCount() > 0)
-		    info[0] += ";" + (mouseElm.getVoltageSource()+nodeList.size());
+					info[0] = "V = " + CircuitElm.getUnitText(mouseElm.getPostVoltage(mousePost), "V");
+				/*
+				 * //shownodes for (i = 0; i != mouseElm.getPostCount(); i++)
+				 * info[0] += " " + mouseElm.nodes[i]; if
+				 * (mouseElm.getVoltageSourceCount() > 0) info[0] += ";" +
+				 * (mouseElm.getVoltageSource()+nodeList.size());
 				 */
 
 			} else {
@@ -979,16 +966,15 @@
 			for (i = 0; info[i] != null; i++)
 				;
 			if (badnodes > 0)
-				info[i++] = badnodes + ((badnodes == 1) ?
-						" bad connection" : " bad connections");
+				info[i++] = badnodes + ((badnodes == 1) ? " bad connection" : " bad connections");
 
-			// find where to show data; below circuit, not too high unless we need it
+			// find where to show data; below circuit, not too high unless we
+			// need it
 			int ybase = winSize.height-15*i-5;
 			ybase = min(ybase, circuitArea.height);
 			ybase = max(ybase, circuitBottom);
 			for (i = 0; info[i] != null; i++)
-				g.drawString(info[i], x,
-						ybase+15*(i+1));
+				g.drawString(info[i], x, ybase + 15 * (i + 1));
 		}
 		if (selectedArea != null) {
 			g.setColor(CircuitElm.selectColor);
@@ -997,16 +983,15 @@
 		mouseElm = realMouseElm;
 		frames++;
 		/*
-	g.setColor(Color.white);
-	g.drawString("Framerate: " + framerate, 10, 10);
-	g.drawString("Steprate: " + steprate,  10, 30);
-	g.drawString("Steprate/iter: " + (steprate/getIterCount()),  10, 50);
-	g.drawString("iterc: " + (getIterCount()),  10, 70);
+		 * g.setColor(Color.white); g.drawString("Framerate: " + framerate, 10,
+		 * 10); g.drawString("Steprate: " + steprate, 10, 30); g.drawString(
+		 * "Steprate/iter: " + (steprate/getIterCount()), 10, 50); g.drawString(
+		 * "iterc: " + (getIterCount()), 10, 70);
 		 */
 
 		realg.drawImage(dbimage, 0, 0, this);
 		if (!stoppedCheck.getState() && circuitMatrix != null) {
-			// Limit to 50 fps (thanks to Jürgen Klötzer for this)
+			// Limit to 50 fps (thanks to JÃ¼rgen KlÃ¶tzer for this)
 			long delay = 1000/50 - (System.currentTimeMillis() - lastFrameTime);
 			//realg.drawString("delay: " + delay,  10, 90);
 			if (delay > 0) {
@@ -1076,8 +1061,7 @@
 				s.speed = speed;
 				s.resetGraph();
 			}
-			Rectangle r = new Rectangle(pos*w, winSize.height-h+colh*row,
-					w-marg, colh);
+			Rectangle r = new Rectangle(pos * w, winSize.height - h + colh * row, w - marg, colh);
 			row++;
 			if (!r.equals(s.rect))
 				s.setRect(r);
@@ -1096,8 +1080,7 @@
 				return null;
 			InductorElm ie = (InductorElm) c1;
 			CapacitorElm ce = (CapacitorElm) c2;
-			return "res.f = " + CircuitElm.getUnitText(1/(2*pi*Math.sqrt(ie.inductance*
-					ce.capacitance)), "Hz");
+			return "res.f = " + CircuitElm.getUnitText(1 / (2 * pi * Math.sqrt(ie.inductance * ce.capacitance)), "Hz");
 		}
 		if (hintType == HINT_RC) {
 			if (!(c1 instanceof ResistorElm))
@@ -1106,8 +1089,7 @@
 				return null;
 			ResistorElm re = (ResistorElm) c1;
 			CapacitorElm ce = (CapacitorElm) c2;
-			return "RC = " + CircuitElm.getUnitText(re.resistance*ce.capacitance,
-					"s");
+			return "RC = " + CircuitElm.getUnitText(re.resistance * ce.capacitance, "s");
 		}
 		if (hintType == HINT_3DB_C) {
 			if (!(c1 instanceof ResistorElm))
@@ -1116,8 +1098,7 @@
 				return null;
 			ResistorElm re = (ResistorElm) c1;
 			CapacitorElm ce = (CapacitorElm) c2;
-			return "f.3db = " +
-			CircuitElm.getUnitText(1/(2*pi*re.resistance*ce.capacitance), "Hz");
+			return "f.3db = " + CircuitElm.getUnitText(1 / (2 * pi * re.resistance * ce.capacitance), "Hz");
 		}
 		if (hintType == HINT_3DB_L) {
 			if (!(c1 instanceof ResistorElm))
@@ -1126,8 +1107,7 @@
 				return null;
 			ResistorElm re = (ResistorElm) c1;
 			InductorElm ie = (InductorElm) c2;
-			return "f.3db = " +
-			CircuitElm.getUnitText(re.resistance/(2*pi*ie.inductance), "Hz");
+			return "f.3db = " + CircuitElm.getUnitText(re.resistance / (2 * pi * ie.inductance), "Hz");
 		}
 		if (hintType == HINT_TWINT) {
 			if (!(c1 instanceof ResistorElm))
@@ -1136,8 +1116,7 @@
 				return null;
 			ResistorElm re = (ResistorElm) c1;
 			CapacitorElm ce = (CapacitorElm) c2;
-			return "fc = " +
-			CircuitElm.getUnitText(1/(2*pi*re.resistance*ce.capacitance), "Hz");
+			return "fc = " + CircuitElm.getUnitText(1 / (2 * pi * re.resistance * ce.capacitance), "Hz");
 		}
 		return null;
 	}
@@ -1345,7 +1324,7 @@
 			// connect unconnected nodes
 			for (i = 0; i != nodeList.size(); i++)
 				if (!closure[i] && !getCircuitNode(i).internal) {
-					System.out.println("node " + i + " unconnected");
+					// System.out.println("node " + i + " unconnected");
 					stampResistor(0, i, 1e8);
 					closure[i] = true;
 					changed = true;
@@ -1358,29 +1337,25 @@
 			CircuitElm ce = getElm(i);
 			// look for inductors with no current path
 			if (ce instanceof InductorElm) {
-				FindPathInfo fpi = new FindPathInfo(FindPathInfo.INDUCT, ce,
-						ce.getNode(1));
-				// first try findPath with maximum depth of 5, to avoid slowdowns
-				if (!fpi.findPath(ce.getNode(0), 5) &&
-						!fpi.findPath(ce.getNode(0))) {
+				FindPathInfo fpi = new FindPathInfo(FindPathInfo.INDUCT, ce, ce.getNode(1));
+				// first try findPath with maximum depth of 5, to avoid
+				// slowdowns
+				if (!fpi.findPath(ce.getNode(0), 5) && !fpi.findPath(ce.getNode(0))) {
 					System.out.println(ce + " no path");
 					ce.reset();
 				}
 			}
 			// look for current sources with no current path
 			if (ce instanceof CurrentElm) {
-				FindPathInfo fpi = new FindPathInfo(FindPathInfo.INDUCT, ce,
-						ce.getNode(1));
+				FindPathInfo fpi = new FindPathInfo(FindPathInfo.INDUCT, ce, ce.getNode(1));
 				if (!fpi.findPath(ce.getNode(0))) {
 					stop("No path for current source!", ce);
 					return;
 				}
 			}
 			// look for voltage source loops
-			if ((ce instanceof VoltageElm && ce.getPostCount() == 2) ||
-					ce instanceof WireElm) {
-				FindPathInfo fpi = new FindPathInfo(FindPathInfo.VOLTAGE, ce,
-						ce.getNode(1));
+			if ((ce instanceof VoltageElm && ce.getPostCount() == 2) || ce instanceof WireElm) {
+				FindPathInfo fpi = new FindPathInfo(FindPathInfo.VOLTAGE, ce, ce.getNode(1));
 				if (fpi.findPath(ce.getNode(0))) {
 					stop("Voltage source/wire loop with no resistance!", ce);
 					return;
@@ -1388,8 +1363,7 @@
 			}
 			// look for shorted caps, or caps w/ voltage but no R
 			if (ce instanceof CapacitorElm) {
-				FindPathInfo fpi = new FindPathInfo(FindPathInfo.SHORT, ce,
-						ce.getNode(1));
+				FindPathInfo fpi = new FindPathInfo(FindPathInfo.SHORT, ce, ce.getNode(1));
 				if (fpi.findPath(ce.getNode(0))) {
 					System.out.println(ce + " shorted");
 					ce.reset();
@@ -1409,8 +1383,10 @@
 			int qm = -1, qp = -1;
 			double qv = 0;
 			RowInfo re = circuitRowInfo[i];
-			/*System.out.println("row " + i + " " + re.lsChanges + " " + re.rsChanges + " " +
-			       re.dropRow);*/
+			/*
+			 * System.out.println("row " + i + " " + re.lsChanges + " " +
+			 * re.rsChanges + " " + re.dropRow);
+			 */
 			if (re.lsChanges || re.dropRow || re.rsChanges)
 				continue;
 			double rsadd = 0;
@@ -1438,15 +1414,11 @@
 				break;
 			}
 			/*
-	    //System.out.println("line " + i + " " + qp + " " + qm + " " + j);
-	    if (qp != -1 && circuitRowInfo[qp].lsChanges) {
-		System.out.println("lschanges");
-		continue;
-	    }
-	    if (qm != -1 && circuitRowInfo[qm].lsChanges) {
-		System.out.println("lschanges");
-		continue;
-		}
+			 * //System.out.println("line " + i + " " + qp + " " + qm + " " +
+			 * j); if (qp != -1 && circuitRowInfo[qp].lsChanges) {
+			 * System.out.println("lschanges"); continue; } if (qm != -1 &&
+			 * circuitRowInfo[qm].lsChanges) { System.out.println("lschanges");
+			 * continue; }
 			 */
 			if (j == matrixSize) {
 				if (qp == -1) {
@@ -1460,8 +1432,10 @@
 					int k;
 					for (k = 0; elt.type == RowInfo.ROW_EQUAL && k < 100; k++) {
 						// follow the chain
-						/*System.out.println("following equal chain from " +
-					   i + " " + qp + " to " + elt.nodeEq);*/
+						/*
+						 * System.out.println("following equal chain from " + i
+						 * + " " + qp + " to " + elt.nodeEq);
+						 */
 						qp = elt.nodeEq;
 						elt = circuitRowInfo[qp];
 					}
@@ -1478,7 +1452,8 @@
 					elt.type = RowInfo.ROW_CONST;
 					elt.value = (circuitRightSide[i]+rsadd)/qv;
 					circuitRowInfo[i].dropRow = true;
-					//System.out.println(qp + " * " + qv + " = const " + elt.value);
+					// System.out.println(qp + " * " + qv + " = const " +
+					// elt.value);
 					i = -1; // start over from scratch
 				} else if (circuitRightSide[i]+rsadd == 0) {
 					// we found a row with only two nonzero entries, and one
@@ -1486,7 +1461,8 @@
 					if (elt.type != RowInfo.ROW_NORMAL) {
 						//System.out.println("swapping");
 						int qq = qm;
-						qm = qp; qp = qq;
+						qm = qp;
+						qp = qq;
 						elt = circuitRowInfo[qp];
 						if (elt.type != RowInfo.ROW_NORMAL) {
 							// we should follow the chain here, but this
@@ -1547,16 +1523,14 @@
 		}
 		//System.out.println("ac8");
 
-		/*System.out.println("matrixSize = " + matrixSize);
-
-	for (j = 0; j != circuitMatrixSize; j++) {
-	    System.out.println(j + ": ");
-	    for (i = 0; i != circuitMatrixSize; i++)
-		System.out.print(circuitMatrix[j][i] + " ");
-	    System.out.print("  " + circuitRightSide[j] + "\n");
-	}
-	System.out.print("\n");*/
-
+		/*
+		 * System.out.println("matrixSize = " + matrixSize);
+		 *
+		 * for (j = 0; j != circuitMatrixSize; j++) { System.out.println(j +
+		 * ": "); for (i = 0; i != circuitMatrixSize; i++)
+		 * System.out.print(circuitMatrix[j][i] + " "); System.out.print("  " +
+		 * circuitRightSide[j] + "\n"); } System.out.print("\n");
+		 */
 
 		// make the new, simplified matrix
 		int newsize = nn;
@@ -1593,13 +1567,12 @@
 		circuitNeedsMap = true;
 
 		/*
-	System.out.println("matrixSize = " + matrixSize + " " + circuitNonLinear);
-	for (j = 0; j != circuitMatrixSize; j++) {
-	    for (i = 0; i != circuitMatrixSize; i++)
-		System.out.print(circuitMatrix[j][i] + " ");
-	    System.out.print("  " + circuitRightSide[j] + "\n");
-	}
-	System.out.print("\n");*/
+		 * System.out.println("matrixSize = " + matrixSize + " " +
+		 * circuitNonLinear); for (j = 0; j != circuitMatrixSize; j++) { for (i
+		 * = 0; i != circuitMatrixSize; i++)
+		 * System.out.print(circuitMatrix[j][i] + " "); System.out.print("  " +
+		 * circuitRightSide[j] + "\n"); } System.out.print("\n");
+		 */
 
 		// if a matrix is linear, we can do the lu_factor here instead of
 		// needing to do it every frame
@@ -1631,13 +1604,18 @@
 		int dest;
 		CircuitElm firstElm;
 		int type;
+
 		FindPathInfo(int t, CircuitElm e, int d) {
 			dest = d;
 			type = t;
 			firstElm = e;
 			used = new boolean[nodeList.size()];
 		}
-		boolean findPath(int n1) { return findPath(n1, -1); }
+
+		boolean findPath(int n1) {
+			return findPath(n1, -1);
+		}
+
 		boolean findPath(int n1, int depth) {
 			if (n1 == dest)
 				return true;
@@ -1664,8 +1642,7 @@
 				if (type == SHORT && !ce.isWire())
 					continue;
 				if (type == CAP_V) {
-					if (!(ce.isWire() || ce instanceof CapacitorElm ||
-							ce instanceof VoltageElm))
+					if (!(ce.isWire() || ce instanceof CapacitorElm || ce instanceof VoltageElm))
 						continue;
 				}
 				if (n1 == 0) {
@@ -1673,8 +1650,7 @@
 					// our path can go through ground
 					int j;
 					for (j = 0; j != ce.getPostCount(); j++)
-						if (ce.hasGroundConnection(j) &&
-								findPath(ce.getNode(j), depth)) {
+						if (ce.hasGroundConnection(j) && findPath(ce.getNode(j), depth)) {
 							used[n1] = false;
 							return true;
 						}
@@ -1696,7 +1672,8 @@
 					double c = ce.getCurrent();
 					if (j == 0)
 						c = -c;
-					//System.out.println("matching " + c + " to " + firstElm.getCurrent());
+					// System.out.println("matching " + c + " to " +
+					// firstElm.getCurrent());
 					//System.out.println(ce + " " + firstElm);
 					if (Math.abs(c-firstElm.getCurrent()) > 1e-10)
 						continue;
@@ -1705,7 +1682,8 @@
 				for (k = 0; k != ce.getPostCount(); k++) {
 					if (j == k)
 						continue;
-					//System.out.println(ce + " " + ce.getNode(j) + "-" + ce.getNode(k));
+					// System.out.println(ce + " " + ce.getNode(j) + "-" +
+					// ce.getNode(k));
 					if (ce.getConnection(j, k) && findPath(ce.getNode(k), depth)) {
 						//System.out.println("got findpath " + n1);
 						used[n1] = false;
@@ -1757,7 +1735,7 @@
 		stampMatrix(n2, vn, -1);
 	}
 
-	void updateVoltageSource(int n1, int n2, int vs, double v) {
+	void updateVoltageSource(@SuppressWarnings("unused") int n1, @SuppressWarnings("unused") int n2, int vs, double v) {
 		int vn = nodeList.size()+vs;
 		stampRightSide(vn, v);
 	}
@@ -1811,7 +1789,8 @@
 				i = circuitRowInfo[i-1].mapRow;
 				RowInfo ri = circuitRowInfo[j-1];
 				if (ri.type == RowInfo.ROW_CONST) {
-					//System.out.println("Stamping constant " + i + " " + j + " " + x);
+					// System.out.println("Stamping constant " + i + " " + j + "
+					// " + x);
 					circuitRightSide[i] -= x*ri.value;
 					return;
 				}
@@ -1860,6 +1839,7 @@
 
 	boolean converged;
 	int subIterations;
+
 	void runCircuit() {
 		if (circuitMatrix == null || elmList.size() == 0) {
 			circuitMatrix = null;
@@ -1920,14 +1900,12 @@
 				if (circuitNonLinear) {
 					if (converged && subiter > 0)
 						break;
-					if (!lu_factor(circuitMatrix, circuitMatrixSize,
-							circuitPermute)) {
+					if (!lu_factor(circuitMatrix, circuitMatrixSize, circuitPermute)) {
 						stop("Singular matrix!", null);
 						return;
 					}
 				}
-				lu_solve(circuitMatrix, circuitMatrixSize, circuitPermute,
-						circuitRightSide);
+				lu_solve(circuitMatrix, circuitMatrixSize, circuitPermute, circuitRightSide);
 
 				for (j = 0; j != circuitMatrixFullSize; j++) {
 					RowInfo ri = circuitRowInfo[j];
@@ -1936,8 +1914,10 @@
 						res = ri.value;
 					else
 						res = circuitRightSide[ri.mapCol];
-					/*System.out.println(j + " " + res + " " +
-		      ri.type + " " + ri.mapCol);*/
+					/*
+					 * System.out.println(j + " " + res + " " + ri.type + " " +
+					 * ri.mapCol);
+					 */
 					if (Double.isNaN(res)) {
 						converged = false;
 						//debugprint = true;
@@ -1946,12 +1926,14 @@
 					if (j < nodeList.size()-1) {
 						CircuitNode cn = getCircuitNode(j+1);
 						for (k = 0; k != cn.links.size(); k++) {
-							CircuitNodeLink cnl = (CircuitNodeLink) cn.links.elementAt(k);
+							CircuitNodeLink cnl = cn.links.elementAt(k);
 							cnl.elm.setNodeVoltage(cnl.num, res);
 						}
+
 					} else {
 						int ji = j-(nodeList.size()-1);
-						//System.out.println("setting vsrc " + ji + " to " + res);
+						// System.out.println("setting vsrc " + ji + " to " +
+						// res);
 						voltageSources[ji].setCurrent(ji, res);
 					}
 				}
@@ -1959,7 +1941,8 @@
 					break;
 			}
 			if (subiter > 5)
-				System.out.print("converged after " + subiter + " iterations\n");
+				// System.out.print("converged after " + subiter + "
+				// iterations\n");
 			if (subiter == subiterCount) {
 				stop("Convergence failed!", null);
 				break;
@@ -1969,26 +1952,34 @@
 				scopes[i].timeStep();
 			tm = System.currentTimeMillis();
 			lit = tm;
-			if (iter*1000 >= steprate*(tm-lastIterTime) ||
-					(tm-lastFrameTime > 500))
+			if (iter * 1000 >= steprate * (tm - lastIterTime) || (tm - lastFrameTime > 500))
 				break;
 		}
 		lastIterTime = lit;
-		//System.out.println((System.currentTimeMillis()-lastFrameTime)/(double) iter);
+		// System.out.println((System.currentTimeMillis()-lastFrameTime)/(double)
+		// iter);
 	}
 
-	int min(int a, int b) { return (a < b) ? a : b; }
-	int max(int a, int b) { return (a > b) ? a : b; }
+	int min(int a, int b) {
+		return (a < b) ? a : b;
+	}
 
-	void editFuncPoint(int x, int y) {
-		// XXX
+	int max(int a, int b) {
+		return (a > b) ? a : b;
+	}
+
+	void editFuncPoint(@SuppressWarnings("unused") int x, @SuppressWarnings("unused") int y) {
 		cv.repaint(pause);
 	}
 
 	@Override
-	public void componentHidden(ComponentEvent e){}
+	public void componentHidden(ComponentEvent e) {
+	}
+
 	@Override
-	public void componentMoved(ComponentEvent e){}
+	public void componentMoved(ComponentEvent e) {
+	}
+
 	@Override
 	public void componentShown(ComponentEvent e) {
 		cv.repaint();
@@ -1999,6 +1990,7 @@
 		handleResize();
 		cv.repaint(100);
 	}
+
 	@Override
 	public void actionPerformed(ActionEvent e) {
 		String ac = e.getActionCommand();
@@ -2104,8 +2096,7 @@
 		}
 		if (ac.indexOf("setup ") == 0) {
 			pushUndo();
-			readSetupFile(ac.substring(6),
-					((MenuItem) e.getSource()).getLabel());
+			readSetupFile(ac.substring(6), ((MenuItem) e.getSource()).getLabel());
 		}
 	}
 
@@ -2159,7 +2150,8 @@
 			editDialog = null;
 		}
 		editDialog = new EditDialog(eable, this);
-		editDialog.show();
+		editDialog.setModal(true);
+		editDialog.setVisible(true);
 	}
 	
 	///////////////////
@@ -2199,15 +2191,15 @@
 	///////////////////////////
 	void showSetupReadDumpWarningDialog() {
 		Object[] options = {"   Ok   "};
-		JOptionPane.showOptionDialog(this, "Warning. Some elements could not be read.\n"
-				+"Make sure CircuitMod is up to date.", "Warning",
+		JOptionPane.showOptionDialog(this,
+				"Warning. Some elements could not be read.\n" + "Make sure CircuitMod is up to date.", "Warning",
 				JOptionPane.PLAIN_MESSAGE, JOptionPane.WARNING_MESSAGE, null, options, options[0]);
 	}
 	
 	void showSetupReadErrorDialog() {
 		Object[] options = {"   Ok   "};
-		JOptionPane.showOptionDialog(this, "ERROR. The file cannot be opened.", "Error",
-				JOptionPane.PLAIN_MESSAGE, JOptionPane.ERROR_MESSAGE, null, options, options[0]);
+		JOptionPane.showOptionDialog(this, "ERROR. The file cannot be opened.", "Error", JOptionPane.PLAIN_MESSAGE,
+				JOptionPane.ERROR_MESSAGE, null, options, options[0]);
 	}
 	
 	////////////////////////////
@@ -2238,7 +2230,10 @@
 				clearUndoRedo();
 				resetTime();
 				circuitIsModified = false;
-				setTitleName(saveOpenDialog.getFileName());
+				String txt = saveOpenDialog.getFileName();
+				txt = txt.substring(0, txt.lastIndexOf('.'));
+				setTitleName(txt);
+				titleLabel.setText(txt);
 			}
 
 			// If the circuit had a dump warning, tell the user.
@@ -2268,6 +2263,8 @@
 			deleteAll();
 			clearUndoRedo();
 			resetTime();
+			titleLabel.setText("Untitled");
+			setTitleNameStart();
 		}
 	}
 	
@@ -2294,7 +2291,9 @@
 		readSetup(dumpCircuit());
 		if(saveOpenDialog.save(dumpCircuit())) {
 			circuitIsModified = false; // Circuit has been saved.
-			setTitleName(saveOpenDialog.getFileName());
+			String txt = saveOpenDialog.getFileName();
+			txt = txt.substring(0, txt.lastIndexOf('.'));
+			setTitleName(txt);
 			return true;
 		}
 
@@ -2308,7 +2307,9 @@
 		
 		if(saveOpenDialog.saveAs(dumpCircuit())) {
 			circuitIsModified = false; // Circuit has been saved.
-			setTitleName(saveOpenDialog.getFileName());
+			String txt = saveOpenDialog.getFileName();
+			txt = txt.substring(0, txt.lastIndexOf('.'));
+			setTitleName(txt);
 		}
 	}
 
@@ -2317,21 +2318,16 @@
 		return circuitIsModified;
 	}
 	
-	// Checks if circuit needs saving. Returns 0 if saved; 1 if not saved; 2 if cancelled.
+	// Checks if circuit needs saving. Returns 0 if saved; 1 if not saved; 2 if
+	// cancelled.
 	int saveIfModified() {
 		//Check if the circuit has been modified and needs saving
 		if(circuitIsModified()) {
 			//Custom button text
 			Object[] options = {"Yes", "No", "Cancel"};
 
-			int n = JOptionPane.showOptionDialog(null,
-					"Save changes?",
-					"CircuitMod",
-					JOptionPane.YES_NO_CANCEL_OPTION,
-					JOptionPane.QUESTION_MESSAGE,
-					null,
-					options,
-					options[0]);
+			int n = JOptionPane.showOptionDialog(null, "Save changes?", "CircuitMod", JOptionPane.YES_NO_CANCEL_OPTION,
+					JOptionPane.QUESTION_MESSAGE, null, options, options[0]);
 
 			if(n == 0) {
 				if(doSave()) {
@@ -2345,10 +2341,8 @@
 
 			return 2;
 		}
-		else {
 			return 0;
 		}
-	}
 	
 	//////////////////////////////////////
 	// End of Federico Garcia's Methods //
@@ -2374,9 +2368,13 @@
 		}
 		String dump = (imp) ? "" : dumpCircuit();
 		if (url)
-			dump = baseURL + "#" + URLEncoder.encode(dump);
+			try {
+				dump = baseURL + "#" + URLEncoder.encode(dump, "UTF-8");
+			} catch (UnsupportedEncodingException e) {
+				e.printStackTrace();
+			}
 		impDialog = new ImportDialog(this, dump, url);
-		impDialog.show();
+		impDialog.setVisible(true);
 		pushUndo();
 	}
 
@@ -2388,10 +2386,8 @@
 		f |= (powerCheckItem.getState()) ? 8 : 0;
 		f |= (showValuesCheckItem.getState()) ? 0 : 16;
 		// 32 = linear scale in afilter
-		String dump = "$ " + f + " " +
-				timeStep + " " + getIterCount() + " " +
-				currentBar.getValue() + " " + CircuitElm.voltageRange + " " +
-				powerBar.getValue() + "\n";
+		String dump = "$ " + f + " " + timeStep + " " + getIterCount() + " " + currentBar.getValue() + " "
+				+ CircuitElm.voltageRange + " " + powerBar.getValue() + "\n";
 		for (i = 0; i != elmList.size(); i++)
 			dump += getElm(i).dump() + "\n";
 		for (i = 0; i != scopeCount; i++) {
@@ -2400,8 +2396,7 @@
 				dump += d + "\n";
 		}
 		if (hintType != -1)
-			dump += "h " + hintType + " " + hintItem1 + " " +
-					hintItem2 + "\n";
+			dump += "h " + hintType + " " + hintItem1 + " " + hintItem2 + "\n";
 		return dump;
 	}
 
@@ -2439,7 +2434,7 @@
 		}
 	}
 
-	void getSetupList(Menu menu, boolean retry) {
+	void getSetupList(Menu menu, @SuppressWarnings("unused") boolean retry) {
 		Menu stack[] = new Menu[6];
 		int stackptr = 0;
 		stack[stackptr++] = menu;
@@ -2498,13 +2493,13 @@
 	}
 
 	int readSetup(String text, boolean retain) {
-		titleLabel.setText("untitled");
+		titleLabel.setText("Untitled");
 		return readSetup(text.getBytes(), text.length(), retain);
 	}
 
 	void readSetupFile(String str, String title) {
 		t = 0;
-		System.out.println(str);
+		// System.out.println(str);
 		try {
 			URL url = new URL(getCodeBase() + "circuits/" + str);
 			ByteArrayOutputStream ba = readUrlData(url);
@@ -2514,6 +2509,8 @@
 			stop("Unable to read " + str + "!", null);
 		}
 		titleLabel.setText(title);
+		setTitleName(title.trim());
+
 	}
 
 	int readSetup(byte b[], int len, boolean retain) {
@@ -2585,19 +2582,18 @@
 					int y2 = new Integer(st.nextToken()).intValue();
 					int f  = new Integer(st.nextToken()).intValue();
 					CircuitElm ce = null;
-					Class cls = dumpTypes[tint];
+					Class<?> cls = dumpTypes[tint];
 					if (cls == null) {
 						System.out.println("unrecognized dump type: " + type);
 						status = SETUP_READ_DUMP_WARNING;
 						break;
 					}
 					// find element class
-					Class carr[] = new Class[6];
+					Class<?> carr[] = new Class[6];
 					//carr[0] = getClass();
-					carr[0] = carr[1] = carr[2] = carr[3] = carr[4] =
-							int.class;
+					carr[0] = carr[1] = carr[2] = carr[3] = carr[4] = int.class;
 					carr[5] = StringTokenizer.class;
-					Constructor cstr = null;
+					Constructor<?> cstr = null;
 					cstr = cls.getConstructor(carr);
 
 					// invoke constructor with starting coordinates
@@ -2671,7 +2667,7 @@
 		return (x+gridRound) & gridMask;
 	}
 
-	boolean doSwitch(int x, int y) {
+	boolean doSwitch(@SuppressWarnings("unused") int x, @SuppressWarnings("unused") int y) {
 		if (mouseElm == null || !(mouseElm instanceof SwitchElm))
 			return false;
 		SwitchElm se = (SwitchElm) mouseElm;
@@ -2695,10 +2691,8 @@
 		// ignore right mouse button with no modifiers (needed on PC)
 		if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0) {
 			int ex = e.getModifiersEx();
-			if ((ex & (InputEvent.META_DOWN_MASK|
-					InputEvent.SHIFT_DOWN_MASK|
-					InputEvent.CTRL_DOWN_MASK|
-					InputEvent.ALT_DOWN_MASK)) == 0)
+			if ((ex & (InputEvent.META_DOWN_MASK | InputEvent.SHIFT_DOWN_MASK | InputEvent.CTRL_DOWN_MASK
+					| InputEvent.ALT_DOWN_MASK)) == 0)
 				return;
 		}
 		if (!circuitArea.contains(e.getX(), e.getY()))
@@ -2735,9 +2729,11 @@
 		dragging = true;
 		if (success) {
 			if (tempMouseMode == MODE_DRAG_SELECTED && mouseElm instanceof TextElm) {
-				dragX = e.getX(); dragY = e.getY();
+				dragX = e.getX();
+				dragY = e.getY();
 			} else {
-				dragX = snapGrid(e.getX()); dragY = snapGrid(e.getY());
+				dragX = snapGrid(e.getX());
+				dragY = snapGrid(e.getY());
 			}
 		}
 		cv.repaint(pause);
@@ -2756,7 +2752,7 @@
 		removeZeroLengthElements();
 	}
 
-	void dragRow(int x, int y) {
+	void dragRow(@SuppressWarnings("unused") int x, int y) {
 		int dy = y-dragY;
 		if (dy == 0)
 			return;
@@ -2771,7 +2767,7 @@
 		removeZeroLengthElements();
 	}
 
-	void dragColumn(int x, int y) {
+	void dragColumn(int x, @SuppressWarnings("unused") int y) {
 		int dx = x-dragX;
 		if (dx == 0)
 			return;
@@ -2838,9 +2834,8 @@
 
 	void dragPost(int x, int y) {
 		if (draggingPost == -1) {
-			draggingPost =
-					(distanceSq(mouseElm.x , mouseElm.y , x, y) >
-					distanceSq(mouseElm.x2, mouseElm.y2, x, y)) ? 1 : 0;
+			draggingPost = (distanceSq(mouseElm.x, mouseElm.y, x, y) > distanceSq(mouseElm.x2, mouseElm.y2, x, y)) ? 1
+					: 0;
 		}
 		int dx = x-dragX;
 		int dy = y-dragY;
@@ -2892,7 +2887,8 @@
 			return;
 		int x = e.getX();
 		int y = e.getY();
-		dragX = snapGrid(x); dragY = snapGrid(y);
+		dragX = snapGrid(x);
+		dragY = snapGrid(y);
 		draggingPost = -1;
 		int i;
 		CircuitElm origMouse = mouseElm;
@@ -2978,9 +2974,11 @@
 				clearSelection();
 		}
 	}
+
 	@Override
 	public void mouseEntered(MouseEvent e) {
 	}
+
 	@Override
 	public void mouseExited(MouseEvent e) {
 		scopeSelected = -1;
@@ -2990,35 +2988,30 @@
 
 	@Override
 	public void mousePressed(MouseEvent e) {
-		System.out.println(e.getModifiers());
+		// System.out.println("mod="+e.getModifiers());
 		int ex = e.getModifiersEx();
-		if ((ex & (InputEvent.META_DOWN_MASK|
-				InputEvent.SHIFT_DOWN_MASK)) == 0 && e.isPopupTrigger()) {
+		if ((ex & (InputEvent.META_DOWN_MASK | InputEvent.SHIFT_DOWN_MASK)) == 0 && e.isPopupTrigger()) {
 			doPopupMenu(e);
 			return;
 		}
 		if ((e.getModifiers() & InputEvent.BUTTON1_MASK) != 0) {
 			// left mouse
 			tempMouseMode = mouseMode;
-			if ((ex & InputEvent.ALT_DOWN_MASK) != 0 &&
-					(ex & InputEvent.META_DOWN_MASK) != 0)
+			if ((ex & InputEvent.ALT_DOWN_MASK) != 0 && (ex & InputEvent.META_DOWN_MASK) != 0)
 				tempMouseMode = MODE_DRAG_COLUMN;
-			else if ((ex & InputEvent.ALT_DOWN_MASK) != 0 &&
-					(ex & InputEvent.SHIFT_DOWN_MASK) != 0)
+			else if ((ex & InputEvent.ALT_DOWN_MASK) != 0 && (ex & InputEvent.SHIFT_DOWN_MASK) != 0)
 				tempMouseMode = MODE_DRAG_ROW;
 			else if ((ex & InputEvent.SHIFT_DOWN_MASK) != 0)
 				tempMouseMode = MODE_SELECT;
 			else if ((ex & InputEvent.ALT_DOWN_MASK) != 0)
 				tempMouseMode = MODE_DRAG_ALL;
-			else if ((ex & (InputEvent.CTRL_DOWN_MASK|
-					InputEvent.META_DOWN_MASK)) != 0)
+			else if ((ex & (InputEvent.CTRL_DOWN_MASK | InputEvent.META_DOWN_MASK)) != 0)
 				tempMouseMode = MODE_DRAG_POST;
 		} else if ((e.getModifiers() & InputEvent.BUTTON3_MASK) != 0) {
 			// right mouse
 			if ((ex & InputEvent.SHIFT_DOWN_MASK) != 0)
 				tempMouseMode = MODE_DRAG_ROW;
-			else if ((ex & (InputEvent.CTRL_DOWN_MASK|
-					InputEvent.META_DOWN_MASK)) != 0)
+			else if ((ex & (InputEvent.CTRL_DOWN_MASK | InputEvent.META_DOWN_MASK)) != 0)
 				tempMouseMode = MODE_DRAG_COLUMN;
 			else
 				return;
@@ -3043,16 +3036,17 @@
 		dragElm = constructElement(addingClass, x0, y0);
 	}
 
-	CircuitElm constructElement(Class c, int x0, int y0) {
+	CircuitElm constructElement(Class<?> c, int x0, int y0) {
 		// find element class
-		Class carr[] = new Class[2];
+		Class<?> carr[] = new Class[2];
 		//carr[0] = getClass();
 		carr[0] = carr[1] = int.class;
-		Constructor cstr = null;
+		Constructor<?> cstr = null;
 		try {
 			cstr = c.getConstructor(carr);
 		} catch (NoSuchMethodException ee) {
-			System.out.println("caught NoSuchMethodException " + c);
+			ee.printStackTrace();
+			// System.out.println("caught NoSuchMethodException " + c);
 			return null;
 		} catch (Exception ee) {
 			ee.printStackTrace();
@@ -3065,7 +3059,9 @@
 		oarr[1] = new Integer(y0);
 		try {
 			return (CircuitElm) cstr.newInstance(oarr);
-		} catch (Exception ee) { ee.printStackTrace(); }
+		} catch (Exception ee) {
+			ee.printStackTrace();
+		}
 		return null;
 	}
 
@@ -3097,8 +3093,7 @@
 				doMainMenuChecks((Menu) mc);
 			if (mc instanceof CheckboxMenuItem) {
 				CheckboxMenuItem cmi = (CheckboxMenuItem) mc;
-				cmi.setState(
-						mouseModeStr.compareTo(cmi.getActionCommand()) == 0);
+				cmi.setState(mouseModeStr.compareTo(cmi.getActionCommand()) == 0);
 			}
 		}
 	}
@@ -3106,8 +3101,8 @@
 	@Override
 	public void mouseReleased(MouseEvent e) {
 		int ex = e.getModifiersEx();
-		if ((ex & (InputEvent.SHIFT_DOWN_MASK|InputEvent.CTRL_DOWN_MASK|
-				InputEvent.META_DOWN_MASK)) == 0 && e.isPopupTrigger()) {
+		if ((ex & (InputEvent.SHIFT_DOWN_MASK | InputEvent.CTRL_DOWN_MASK | InputEvent.META_DOWN_MASK)) == 0
+				&& e.isPopupTrigger()) {
 			doPopupMenu(e);
 			return;
 		}
@@ -3140,11 +3135,11 @@
 
 	void enableItems() {
 		if (powerCheckItem.getState()) {
-			powerBar.enable();
-			powerLabel.enable();
+			powerBar.setEnabled(true);
+			powerLabel.setEnabled(true);
 		} else {
-			powerBar.disable();
-			powerLabel.disable();
+			powerBar.setEnabled(false);
+			powerLabel.setEnabled(false);
 		}
 		enableUndoRedo();
 	}
@@ -3174,21 +3169,29 @@
 			MenuItem mmi = (MenuItem) mi;
 			mouseMode = MODE_ADD_ELM;
 			String s = mmi.getActionCommand();
-			if (s.length() > 0)
+			if (s.length() > 0) {
 				mouseModeStr = s;
-			if (s.compareTo("DragAll") == 0)
+				modeInfoLabel.setText(mmi.getLabel());
+			}
+			if (s.compareTo("DragAll") == 0) {
 				mouseMode = MODE_DRAG_ALL;
-			else if (s.compareTo("DragRow") == 0)
+				modeInfoLabel.setText("Drag All");
+			} else if (s.compareTo("DragRow") == 0) {
 				mouseMode = MODE_DRAG_ROW;
-			else if (s.compareTo("DragColumn") == 0)
+				modeInfoLabel.setText("Drag Row");
+			} else if (s.compareTo("DragColumn") == 0) {
 				mouseMode = MODE_DRAG_COLUMN;
-			else if (s.compareTo("DragSelected") == 0)
+				modeInfoLabel.setText("Drag Column");
+			} else if (s.compareTo("DragSelected") == 0) {
 				mouseMode = MODE_DRAG_SELECTED;
-			else if (s.compareTo("DragPost") == 0)
+				modeInfoLabel.setText("Drag Selected");
+			} else if (s.compareTo("DragPost") == 0) {
 				mouseMode = MODE_DRAG_POST;
-			else if (s.compareTo("Select") == 0)
+				modeInfoLabel.setText("Drag Post");
+			} else if (s.compareTo("Select") == 0) {
 				mouseMode = MODE_SELECT;
-			else if (s.length() > 0) {
+				modeInfoLabel.setText("Select");
+			} else if (s.length() > 0) {
 				try {
 					addingClass = Class.forName(s);
 				} catch (Exception ee) {
@@ -3255,6 +3258,8 @@
 	void doCut() {
 		int i;
 		pushUndo();
+		if (mouseElm != null)
+			menuElm = mouseElm;
 		setMenuSelection();
 		clipboard = "";
 		for (i = elmList.size()-1; i >= 0; i--) {
@@ -3272,6 +3277,8 @@
 	void doDelete() {
 		int i;
 		pushUndo();
+		if (mouseElm != null)
+			menuElm = mouseElm;
 		setMenuSelection();
 		for (i = elmList.size()-1; i >= 0; i--) {
 			CircuitElm ce = getElm(i);
@@ -3296,6 +3303,8 @@
 	void doCopy() {
 		int i;
 		clipboard = "";
+		if (mouseElm != null)
+			menuElm = mouseElm;
 		setMenuSelection();
 		for (i = elmList.size()-1; i >= 0; i--) {
 			CircuitElm ce = getElm(i);
@@ -3373,13 +3382,12 @@
 
 	// Init keyboard detection
 	void keyboardInit() {
-		KeyboardFocusManager.getCurrentKeyboardFocusManager()
-		.addKeyEventDispatcher(new KeyEventDispatcher() {
+		KeyboardFocusManager.getCurrentKeyboardFocusManager().addKeyEventDispatcher(new KeyEventDispatcher() {
 			@Override
 			public boolean dispatchKeyEvent(KeyEvent e) {
 				if (e.getID() == KeyEvent.KEY_PRESSED) {
 					if (e.getKeyChar() > ' ' && e.getKeyChar() < 127) {
-						Class c = dumpTypes[e.getKeyChar()];
+						Class<?> c = dumpTypes[e.getKeyChar()];
 						if (c == null || c == Scope.class)
 							return false;
 						CircuitElm elm = null;
@@ -3394,9 +3402,24 @@
 						mouseMode = MODE_SELECT;
 						mouseModeStr = "Select";
 					}
-					if(e.getKeyCode() == KeyEvent.VK_DELETE) {
+					if (e.getKeyCode() == KeyEvent.VK_DELETE && editDialog == null) {
 						doDelete();
 					}
+					if (e.isControlDown() && e.getKeyCode() == KeyEvent.VK_Z) {
+						doUndo();
+					}
+					if (e.isControlDown() && e.isShiftDown() && e.getKeyCode() == KeyEvent.VK_Z) {
+						doRedo();
+					}
+					if (e.isControlDown() && e.getKeyCode() == KeyEvent.VK_X) {
+						doCut();
+					}
+					if (e.isControlDown() && e.getKeyCode() == KeyEvent.VK_C) {
+						doCopy();
+					}
+					if (e.isControlDown() && e.getKeyCode() == KeyEvent.VK_V) {
+						doPaste();
+					}
 
 					tempMouseMode = mouseMode;
 	            } else if (e.getID() == KeyEvent.KEY_RELEASED) {
@@ -3476,7 +3499,7 @@
 
 			// avoid zeros
 			if (a[j][j] == 0.0) {
-				System.out.println("avoided zero");
+				// System.out.println("avoided zero");
 				a[j][j]=1e-18;
 			}
 
@@ -3528,5 +3551,4 @@
 			b[i] = tot/a[i][i];
 		}
 	}
-
 }
# diff -Naurw src.org/ClockElm.java src/ClockElm.java...
--- src.org/ClockElm.java	2015-12-05 20:47:02.000000000 +0100
+++ src/ClockElm.java	2016-03-16 13:08:25.638719723 +0100
@@ -1,4 +1,3 @@
-
     class ClockElm extends RailElm {
 	public ClockElm(int xx, int yy) {
 	    super(xx, yy, WF_SQUARE);
@@ -7,6 +6,9 @@
 	    frequency = 100;
 	    flags |= FLAG_CLOCK;
 	}
+
 	@Override
-	Class getDumpClass() { return RailElm.class; }
+	Class<RailElm> getDumpClass() {
+		return RailElm.class;
+	}
     }
# diff -Naurw src.org/CounterElm.java src/CounterElm.java...
--- src.org/CounterElm.java	2015-12-05 20:47:02.000000000 +0100
+++ src/CounterElm.java	2016-03-16 13:08:32.202601250 +0100
@@ -1,17 +1,26 @@
-
 import java.util.StringTokenizer;
 
     class CounterElm extends ChipElm {
 	final int FLAG_ENABLE = 2;
-	public CounterElm(int xx, int yy) { super(xx, yy); }
-	public CounterElm(int xa, int ya, int xb, int yb, int f,
-			    StringTokenizer st) {
+
+	public CounterElm(int xx, int yy) {
+		super(xx, yy);
+	}
+
+	public CounterElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	    super(xa, ya, xb, yb, f, st);
 	}
+
 	@Override
-	boolean needsBits() { return true; }
+	boolean needsBits() {
+		return true;
+	}
+
 	@Override
-	String getChipName() { return "Counter"; }
+	String getChipName() {
+		return "Counter";
+	}
+
 	@Override
 	void setupPins() {
 	    sizeX = 2;
@@ -31,15 +40,23 @@
 		pins[bits+2] = new Pin(sizeY-2, SIDE_W, "En");
 	    allocNodes();
 	}
+
 	@Override
 	int getPostCount() {
 	    if (hasEnable())
 		return bits+3;
 	    return bits+2;
 	}
-	boolean hasEnable() { return (flags & FLAG_ENABLE) != 0; }
+
+	boolean hasEnable() {
+		return (flags & FLAG_ENABLE) != 0;
+	}
+
 	@Override
-	int getVoltageSourceCount() { return bits; }
+	int getVoltageSourceCount() {
+		return bits;
+	}
+
 	@Override
 	void execute() {
 	    boolean en = true;
@@ -63,6 +80,9 @@
 	    }
 	    lastClock = pins[0].value;
 	}
+
 	@Override
-	int getDumpType() { return 164; }
+	int getDumpType() {
+		return 164;
+	}
     }
# diff -Naurw src.org/CurrentElm.java src/CurrentElm.java...
--- src.org/CurrentElm.java	2015-12-05 20:46:58.000000000 +0100
+++ src/CurrentElm.java	2016-03-16 13:08:38.302491152 +0100
@@ -1,4 +1,3 @@
-
 import java.awt.Graphics;
 import java.awt.Point;
 import java.awt.Polygon;
@@ -6,12 +5,13 @@
 
     class CurrentElm extends CircuitElm {
 	double currentValue;
+
 	public CurrentElm(int xx, int yy) {
 	    super(xx, yy);
 	    currentValue = .01;
 	}
-	public CurrentElm(int xa, int ya, int xb, int yb, int f,
-		   StringTokenizer st) {
+
+	public CurrentElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	    super(xa, ya, xb, yb, f);
 	    try {
 		currentValue = new Double(st.nextToken()).doubleValue();
@@ -19,15 +19,20 @@
 		currentValue = .01;
 	    }
 	}
+
 	@Override
 	String dump() {
 	    return super.dump() + " " + currentValue;
 	}
+
 	@Override
-	int getDumpType() { return 'i'; }
+	int getDumpType() {
+		return 'i';
+	}
 	
 	Polygon arrow;
 	Point ashaft1, ashaft2, center;
+
 	@Override
 	void setPoints() {
 	    super.setPoints();
@@ -38,6 +43,7 @@
 	    Point p2 = interpPoint(lead1, lead2, .75);
 	    arrow = calcArrow(center, p2, 4, 4);
 	}
+
 	@Override
 	void draw(Graphics g) {
 	    int cr = 12;
@@ -58,26 +64,31 @@
 	    }
 	    drawPosts(g);
 	}
+
 	@Override
 	void stamp() {
 	    current = currentValue;
 	    sim.stampCurrentSource(nodes[0], nodes[1], current);
 	}
+
 	@Override
 	public EditInfo getEditInfo(int n) {
 	    if (n == 0)
 		return new EditInfo("Current (A)", currentValue, 0, .1);
 	    return null;
 	}
+
 	@Override
 	public void setEditValue(int n, EditInfo ei) {
 	    currentValue = ei.value;
 	}
+
 	@Override
 	void getInfo(String arr[]) {
 	    arr[0] = "current source";
 	    getBasicInfo(arr);
 	}
+
 	@Override
 	double getVoltageDiff() {
 	    return volts[1] - volts[0];
# diff -Naurw src.org/DACElm.java src/DACElm.java...
--- src.org/DACElm.java	2015-12-05 20:47:00.000000000 +0100
+++ src/DACElm.java	2016-03-16 13:08:43.894390224 +0100
@@ -1,16 +1,24 @@
-
 import java.util.StringTokenizer;
 
 class DACElm extends ChipElm {
-    public DACElm(int xx, int yy) { super(xx, yy); }
-    public DACElm(int xa, int ya, int xb, int yb, int f,
-		  StringTokenizer st) {
+	public DACElm(int xx, int yy) {
+		super(xx, yy);
+	}
+
+	public DACElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	super(xa, ya, xb, yb, f, st);
     }
+
     @Override
-	String getChipName() { return "DAC"; }
+	String getChipName() {
+		return "DAC";
+	}
+
     @Override
-	boolean needsBits() { return true; }
+	boolean needsBits() {
+		return true;
+	}
+
     @Override
 	void setupPins() {
 	sizeX = 2;
@@ -24,6 +32,7 @@
 	pins[bits+1] = new Pin(sizeY-1, SIDE_E, "V+");
 	allocNodes();
     }
+
     @Override
 	void doStep() {
 	int ival = 0;
@@ -35,11 +44,19 @@
 	double v = ival*volts[bits+1]/ivalmax;
 	sim.updateVoltageSource(0, nodes[bits], pins[bits].voltSource, v);
     }
+
     @Override
-	int getVoltageSourceCount() { return 1; }
-    @Override
-	int getPostCount() { return bits+2; }
+	int getVoltageSourceCount() {
+		return 1;
+	}
+
     @Override
-	int getDumpType() { return 166; }
+	int getPostCount() {
+		return bits + 2;
 }
     
+	@Override
+	int getDumpType() {
+		return 166;
+	}
+}
# diff -Naurw src.org/DCVoltageElm.java src/DCVoltageElm.java...
--- src.org/DCVoltageElm.java	2015-12-05 20:46:58.000000000 +0100
+++ src/DCVoltageElm.java	2016-03-16 13:08:51.082260490 +0100
@@ -1,6 +1,10 @@
-
     class DCVoltageElm extends VoltageElm {
-	public DCVoltageElm(int xx, int yy) { super(xx, yy, WF_DC); }
+	public DCVoltageElm(int xx, int yy) {
+		super(xx, yy, WF_DC);
+	}
+
 	@Override
-	Class getDumpClass() { return VoltageElm.class; }
+	Class<VoltageElm> getDumpClass() {
+		return VoltageElm.class;
+	}
     }
# diff -Naurw src.org/DecadeElm.java src/DecadeElm.java...
--- src.org/DecadeElm.java	2015-12-05 20:47:02.000000000 +0100
+++ src/DecadeElm.java	2016-03-16 13:08:56.722158695 +0100
@@ -1,16 +1,24 @@
-
 import java.util.StringTokenizer;
 
     class DecadeElm extends ChipElm {
-	public DecadeElm(int xx, int yy) { super(xx, yy); }
-	public DecadeElm(int xa, int ya, int xb, int yb, int f,
-			    StringTokenizer st) {
+	public DecadeElm(int xx, int yy) {
+		super(xx, yy);
+	}
+
+	public DecadeElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	    super(xa, ya, xb, yb, f, st);
 	}
+
 	@Override
-	String getChipName() { return "decade counter"; }
+	String getChipName() {
+		return "decade counter";
+	}
+
 	@Override
-	boolean needsBits() { return true; }
+	boolean needsBits() {
+		return true;
+	}
+
 	@Override
 	void setupPins() {
 	    sizeX = bits > 2 ? bits : 2;
@@ -28,16 +36,24 @@
 	    }
 	    allocNodes();
 	}
+
 	@Override
-	int getPostCount() { return bits+2; }
+	int getPostCount() {
+		return bits + 2;
+	}
+
 	@Override
-	int getVoltageSourceCount() { return bits; }
+	int getVoltageSourceCount() {
+		return bits;
+	}
+
 	@Override
 	void execute() {
 	    int i;
 	    if (pins[0].value && !lastClock) {
 			for (i = 0; i != bits; i++)
-			    if (pins[i+2].value) break;
+				if (pins[i + 2].value)
+					break;
 			if (i < bits)
 			    pins[i++ +2].value = false;
 			i %= bits;
@@ -54,5 +70,7 @@
 	}
 	
 	@Override
-	int getDumpType() { return 163; }
+	int getDumpType() {
+		return 163;
+	}
     }
# diff -Naurw src.org/DFlipFlopElm.java src/DFlipFlopElm.java...
--- src.org/DFlipFlopElm.java	2015-12-05 20:46:58.000000000 +0100
+++ src/DFlipFlopElm.java	2016-03-16 13:09:03.366038781 +0100
@@ -1,18 +1,27 @@
-
 import java.awt.Checkbox;
 import java.util.StringTokenizer;
 
     class DFlipFlopElm extends ChipElm {
 	final int FLAG_RESET = 2;
-	boolean hasReset() { return (flags & FLAG_RESET) != 0; }
-	public DFlipFlopElm(int xx, int yy) { super(xx, yy); }
-	public DFlipFlopElm(int xa, int ya, int xb, int yb, int f,
-			    StringTokenizer st) {
+
+	boolean hasReset() {
+		return (flags & FLAG_RESET) != 0;
+	}
+
+	public DFlipFlopElm(int xx, int yy) {
+		super(xx, yy);
+	}
+
+	public DFlipFlopElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	    super(xa, ya, xb, yb, f, st);
 	    pins[2].value = !pins[1].value;
 	}
+
 	@Override
-	String getChipName() { return "D flip-flop"; }
+	String getChipName() {
+		return "D flip-flop";
+	}
+
 	@Override
 	void setupPins() {
 	    sizeX = 2;
@@ -29,12 +38,17 @@
 	    if (hasReset())
 		pins[4] = new Pin(2, SIDE_W, "R");
 	}
+
 	@Override
 	int getPostCount() {
 	    return hasReset() ? 5 : 4;
 	}
+
 	@Override
-	int getVoltageSourceCount() { return 2; }
+	int getVoltageSourceCount() {
+		return 2;
+	}
+
 	@Override
 	void execute() {
 	    if (pins[3].value && !lastClock) {
@@ -47,8 +61,12 @@
 	    }
 	    lastClock = pins[3].value;
 	}
+
 	@Override
-	int getDumpType() { return 155; }
+	int getDumpType() {
+		return 155;
+	}
+
 	@Override
 	public EditInfo getEditInfo(int n) {
 	    if (n == 2) {
@@ -58,6 +76,7 @@
 	    }
 	    return super.getEditInfo(n);
 	}
+
 	@Override
 	public void setEditValue(int n, EditInfo ei) {
 	    if (n == 2) {
# diff -Naurw src.org/DiacElm.java src/DiacElm.java...
--- src.org/DiacElm.java	2015-12-05 20:46:58.000000000 +0100
+++ src/DiacElm.java	2016-03-16 13:09:10.069917782 +0100
@@ -1,5 +1,3 @@
-
-
 import java.awt.Graphics;
 import java.awt.Point;
 import java.util.StringTokenizer;
@@ -7,6 +5,7 @@
 class DiacElm extends CircuitElm {
     double onresistance, offresistance, breakdown, holdcurrent;
     boolean state;
+
     public DiacElm(int xx, int yy) {
 	super(xx, yy);
 	// FIXME need to adjust defaults to make sense for diac
@@ -16,24 +15,32 @@
 	holdcurrent = 0.001;
 	state = false;
     }
-    public DiacElm(int xa, int ya, int xb, int yb, int f,
-		       StringTokenizer st) {
+
+	public DiacElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	super(xa, ya, xb, yb, f);
 	onresistance = new Double(st.nextToken()).doubleValue();
 	offresistance = new Double(st.nextToken()).doubleValue();
 	breakdown = new Double(st.nextToken()).doubleValue();
 	holdcurrent = new Double(st.nextToken()).doubleValue();
     }
+
     @Override
-	boolean nonLinear() {return true;}
+	boolean nonLinear() {
+		return true;
+	}
+
     @Override
-	int getDumpType() { return 185; }
+	int getDumpType() {
+		return 185;
+	}
+
     @Override
 	String dump() {
-	return super.dump() + " " + onresistance + " " + offresistance + " "
-	    + breakdown + " " + holdcurrent;
+		return super.dump() + " " + onresistance + " " + offresistance + " " + breakdown + " " + holdcurrent;
     }
+
     Point ps3, ps4;
+
     @Override
 	void setPoints() {
 	super.setPoints();
@@ -63,13 +70,17 @@
 	else
 	    current = vd/offresistance;
     }
+
     @Override
 	void startIteration() {
 	double vd = volts[0] - volts[1];
-	if(Math.abs(current) < holdcurrent) state = false;
-	if(Math.abs(vd) > breakdown) state = true;
+		if (Math.abs(current) < holdcurrent)
+			state = false;
+		if (Math.abs(vd) > breakdown)
+			state = true;
 	//System.out.print(this + " res current set to " + current + "\n");
     }
+
     @Override
 	void doStep() {
 	if(state)
@@ -77,11 +88,13 @@
 	else
 	    sim.stampResistor(nodes[0], nodes[1], offresistance);
     }
+
     @Override
 	void stamp() {
 	sim.stampNonLinear(nodes[0]);
 	sim.stampNonLinear(nodes[1]);
     }
+
     @Override
 	void getInfo(String arr[]) {
 	// FIXME
@@ -93,6 +106,7 @@
 	arr[6] = "Vbrkdn = " + getUnitText(breakdown, "V");
 	arr[7] = "Ihold = " + getUnitText(holdcurrent, "A");
     }
+
     @Override
 	public EditInfo getEditInfo(int n) {
 	if (n == 0)
@@ -105,6 +119,7 @@
 	    return new EditInfo("Hold current (amps)", holdcurrent, 0, 0);
 	return null;
     }
+
     @Override
 	public void setEditValue(int n, EditInfo ei) {
 	if (ei.value > 0 && n == 0)
@@ -116,7 +131,9 @@
 	if (ei.value > 0 && n == 3)
 	    holdcurrent = ei.value;
     }
+
     @Override
-	boolean needsShortcut() { return false; }
+	boolean needsShortcut() {
+		return false;
+	}
 }
-
# diff -Naurw src.org/DiodeElm.java src/DiodeElm.java...
--- src.org/DiodeElm.java	2015-12-05 20:46:58.000000000 +0100
+++ src/DiodeElm.java	2016-03-16 13:09:21.221716505 +0100
@@ -1,4 +1,3 @@
-
 import java.awt.Graphics;
 import java.awt.Point;
 import java.awt.Polygon;
@@ -17,8 +16,8 @@
 	zvoltage = 0;
 	setup();
     }
-    public DiodeElm(int xa, int ya, int xb, int yb, int f,
-		    StringTokenizer st) {
+
+	public DiodeElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	super(xa, ya, xb, yb, f);
 	diode = new Diode(sim);
 	fwdrop = defaultdrop;
@@ -31,22 +30,27 @@
 	}
 	setup();
     }
+
     @Override
-	boolean nonLinear() { return true; }
+	boolean nonLinear() {
+		return true;
+	}
     
     void setup() {
 	diode.setup(fwdrop, zvoltage);
     }
     
     @Override
-	int getDumpType() { return 'd'; }
+	int getDumpType() {
+		return 'd';
+	}
+
     @Override
 	String dump() {
 	flags |= FLAG_FWDROP;
 	return super.dump() + " " + fwdrop;
     }
     
-
     final int hs = 8;
     Polygon poly;
     Point cathode[];
@@ -94,15 +98,20 @@
     }
 	
     @Override
-	void stamp() { diode.stamp(nodes[0], nodes[1]); }
+	void stamp() {
+		diode.stamp(nodes[0], nodes[1]);
+	}
+
     @Override
 	void doStep() {
 	diode.doStep(volts[0]-volts[1]);
     }
+
     @Override
 	void calculateCurrent() {
 	current = diode.calculateCurrent(volts[0]-volts[1]);
     }
+
     @Override
 	void getInfo(String arr[]) {
 	arr[0] = "diode";
@@ -111,17 +120,22 @@
 	arr[3] = "P = " + getUnitText(getPower(), "W");
 	arr[4] = "Vf = " + getVoltageText(fwdrop);
     }
+
     @Override
 	public EditInfo getEditInfo(int n) {
 	if (n == 0)
 	    return new EditInfo("Fwd Voltage @ 1A", fwdrop, 10, 1000);
 	return null;
     } 
+
     @Override
 	public void setEditValue(int n, EditInfo ei) {
 	fwdrop = ei.value;
 	setup();
     }
+
     @Override
-	boolean needsShortcut() { return getClass() == DiodeElm.class; }
+	boolean needsShortcut() {
+		return getClass() == DiodeElm.class;
+	}
 }
# diff -Naurw src.org/Diode.java src/Diode.java...
--- src.org/Diode.java	2015-12-05 20:47:00.000000000 +0100
+++ src/Diode.java	2016-03-16 13:09:15.513819528 +0100
@@ -1,13 +1,12 @@
-
 class Diode {
     int nodes[];
     CirSim sim;
 
-    
     Diode(CirSim s) {
 	sim = s;
 	nodes = new int[2];
     }
+
     void setup(double fw, double zv) {
 	fwdrop = fw;
 	zvoltage = zv;
@@ -117,19 +116,13 @@
 	    /* 
 	     * I(Vd) = Is * (exp[Vd*C] - exp[(-Vd-Vz)*C] - 1 )
 	     *
-	     * geq is I'(Vd)
-	     * nc is I(Vd) + I'(Vd)*(-Vd)
+			 * geq is I'(Vd) nc is I(Vd) + I'(Vd)*(-Vd)
 	     */
 
-	    double geq = leakage*vdcoef* ( 
-		Math.exp(voltdiff*vdcoef) + Math.exp((-voltdiff-zoffset)*vdcoef)
-		);
-
-	    double nc = leakage* (
-		Math.exp(voltdiff*vdcoef) 
-		- Math.exp((-voltdiff-zoffset)*vdcoef) 
-		- 1
-		) + geq*(-voltdiff);
+			double geq = leakage * vdcoef * (Math.exp(voltdiff * vdcoef) + Math.exp((-voltdiff - zoffset) * vdcoef));
+
+			double nc = leakage * (Math.exp(voltdiff * vdcoef) - Math.exp((-voltdiff - zoffset) * vdcoef) - 1)
+					+ geq * (-voltdiff);
 
 	    sim.stampConductance(nodes[0], nodes[1], geq);
 	    sim.stampCurrentSource(nodes[0], nodes[1],  nc);
@@ -139,10 +132,6 @@
     double calculateCurrent(double voltdiff) {
 	if (voltdiff >= 0 || zvoltage == 0)
 	    return leakage*(Math.exp(voltdiff*vdcoef)-1);
-	return leakage* (
-	    Math.exp(voltdiff*vdcoef)  
-	    - Math.exp((-voltdiff-zoffset)*vdcoef)  
-	    - 1
-	    );
+		return leakage * (Math.exp(voltdiff * vdcoef) - Math.exp((-voltdiff - zoffset) * vdcoef) - 1);
     }
 }
# diff -Naurw src.org/EditDialog.java src/EditDialog.java...
--- src.org/EditDialog.java	2015-12-05 20:47:00.000000000 +0100
+++ src/EditDialog.java	2016-03-16 13:53:42.793687311 +0100
@@ -1,8 +1,6 @@
-
 import java.awt.Button;
 import java.awt.Dialog;
 import java.awt.Dimension;
-import java.awt.Event;
 import java.awt.Label;
 import java.awt.Point;
 import java.awt.Scrollbar;
@@ -13,18 +11,27 @@
 import java.awt.event.AdjustmentListener;
 import java.awt.event.ItemEvent;
 import java.awt.event.ItemListener;
-import java.text.DecimalFormat;
+import java.awt.event.KeyEvent;
+import java.awt.event.KeyListener;
+import java.awt.event.WindowEvent;
+import java.awt.event.WindowListener;
 import java.text.NumberFormat;
 
 interface Editable {
     EditInfo getEditInfo(int n);
+
     void setEditValue(int n, EditInfo ei);
 }
 
-class EditDialog extends Dialog implements AdjustmentListener, ActionListener, ItemListener {
+class EditDialog extends Dialog
+		implements AdjustmentListener, ActionListener, ItemListener, KeyListener, WindowListener {
+	/**
+	 *
+	 */
+	private static final long serialVersionUID = 1L;
     Editable elm;
     CirSim cframe;
-    Button applyButton, okButton;
+	Button applyButton, okButton, cancelButton;
     EditInfo einfos[];
     int einfocount;
     final int barmax = 1000;
@@ -53,14 +60,13 @@
 		add(ei.checkbox);
 		ei.checkbox.addItemListener(this);
 	    } else {
-		add(ei.textf =
-		    new TextField(unitString(ei), 10));
+				add(ei.textf = new TextField(unitString(ei), 10));
 		if (ei.text != null)
 		    ei.textf.setText(ei.text);
 		ei.textf.addActionListener(this);
+				ei.textf.addKeyListener(this);
 		if (ei.text == null) {
-		    add(ei.bar = new Scrollbar(Scrollbar.HORIZONTAL,
-					       50, 10, 0, barmax+2));
+					add(ei.bar = new Scrollbar(Scrollbar.HORIZONTAL, 50, 10, 0, barmax + 2));
 		    setBar(ei);
 		    ei.bar.addAdjustmentListener(this);
 		}
@@ -71,10 +77,12 @@
 	applyButton.addActionListener(this);
 	add(okButton = new Button("OK"));
 	okButton.addActionListener(this);
+		add(cancelButton = new Button("Cancel"));
+		cancelButton.addActionListener(this);
 	Point x = CirSim.main.getLocationOnScreen();
 	Dimension d = getSize();
-	setLocation(x.x + (cframe.winSize.width-d.width)/2,
-		    x.y + (cframe.winSize.height-d.height)/2);
+		setLocation(x.x + (cframe.winSize.width - d.width) / 2, x.y + (cframe.winSize.height - d.height) / 2);
+		addWindowListener(this);
     }
 
     String unitString(EditInfo ei) {
@@ -82,13 +90,14 @@
 	double va = Math.abs(v);
 	if (ei.dimensionless)
 	    return noCommaFormat.format(v);
-	if (v == 0) return "0";
+		if (v == 0)
+			return "0";
 	if (va < 1e-9)
 	    return noCommaFormat.format(v*1e12) + "p";
 	if (va < 1e-6)
 	    return noCommaFormat.format(v*1e9) + "n";
 	if (va < 1e-3)
-	    return noCommaFormat.format(v*1e6) + "u";
+			return noCommaFormat.format(v * 1e6) + "Î¼";
 	if (va < 1 && !ei.forceLargeM)
 	    return noCommaFormat.format(v*1e3) + "m";
 	if (va < 1e3)
@@ -107,16 +116,37 @@
 	char uc = s.charAt(len-1);
 	double mult = 1;
 	switch (uc) {
-	case 'p': case 'P': mult = 1e-12; break;
-	case 'n': case 'N': mult = 1e-9; break;
-	case 'u': case 'U': mult = 1e-6; break;
+		case 'p':
+		case 'P':
+			mult = 1e-12;
+			break;
+		case 'n':
+		case 'N':
+			mult = 1e-9;
+			break;
+		case 'u':
+		case 'U':
+			mult = 1e-6;
+			break;
+		case 'Î¼':
+			mult = 1e-6;
+			break;
 	    
 	// for ohm values, we assume mega for lowercase m, otherwise milli
-	case 'm': mult = (ei.forceLargeM) ? 1e6 : 1e-3; break;
-	
-	case 'k': case 'K': mult = 1e3; break;
-	case 'M': mult = 1e6; break;
-	case 'G': case 'g': mult = 1e9; break;
+		case 'm':
+			mult = (ei.forceLargeM) ? 1e6 : 1e-3;
+			break;
+		case 'k':
+		case 'K':
+			mult = 1e3;
+			break;
+		case 'M':
+			mult = 1e6;
+			break;
+		case 'G':
+		case 'g':
+			mult = 1e9;
+			break;
 	}
 	if (mult != 1)
 	    s = s.substring(0, len-1).trim();
@@ -133,7 +163,8 @@
 		try {
 		    double d = parseUnits(ei);
 		    ei.value = d;
-		} catch (Exception ex) { /* ignored */ }
+				} catch (Exception ex) {
+					/* ignored */ }
 	    }
 	    elm.setEditValue(i, ei);
 	    if (ei.text == null)
@@ -153,7 +184,8 @@
 		    try {
 			double d = parseUnits(ei);
 			ei.value = d;
-		    } catch (Exception ex) { /* ignored */ }
+					} catch (Exception ex) {
+						/* ignored */ }
 		}
 		elm.setEditValue(i, ei);
 		if (ei.text == null)
@@ -169,6 +201,11 @@
 	}
 	if (e.getSource() == applyButton)
 	    apply();
+		if (e.getSource() == cancelButton) {
+			CirSim.main.requestFocus();
+			setVisible(false);
+			CirSim.editDialog = null;
+		}
     }
 	
     @Override
@@ -184,10 +221,11 @@
 		if (v > 1)
 		    v = 1;
 		ei.value = (ei.maxval-ei.minval)*v + ei.minval;
-		/*if (ei.maxval-ei.minval > 100)
-		    ei.value = Math.round(ei.value);
-		else
-		ei.value = Math.round(ei.value*100)/100.;*/
+				/*
+				 * if (ei.maxval-ei.minval > 100) ei.value =
+				 * Math.round(ei.value); else ei.value =
+				 * Math.round(ei.value*100)/100.;
+				 */
 		ei.value = Math.round(ei.value/ei.minval)*ei.minval;
 		elm.setEditValue(i, ei);
 		ei.textf.setText(unitString(ei));
@@ -213,24 +251,71 @@
 	if (changed) {
 	    setVisible(false);
 	    CirSim.editDialog = new EditDialog(elm, cframe);
-	    CirSim.editDialog.show();
+			CirSim.editDialog.setVisible(true);
 	}
     }
 	
-    @Override
-	public boolean handleEvent(Event ev) {
-	if (ev.id == Event.WINDOW_DESTROY) {
+	// @Override
+	// public boolean handleEvent(Event ev) {
+	// if (ev.id == Event.WINDOW_DESTROY) {
+	// CirSim.main.requestFocus();
+	// setVisible(false);
+	// CirSim.editDialog = null;
+	// return true;
+	// }
+	// return super.handleEvent(ev);
+	// }
+
+	void setBar(EditInfo ei) {
+		int x = (int) (barmax * (ei.value - ei.minval) / (ei.maxval - ei.minval));
+		ei.bar.setValue(x);
+	}
+
+	public void windowClosed(WindowEvent event) {
+	}
+
+	public void windowDeiconified(WindowEvent event) {
+	}
+
+	public void windowIconified(WindowEvent event) {
+	}
+
+	public void windowActivated(WindowEvent event) {
+	}
+
+	public void windowDeactivated(WindowEvent event) {
+	}
+
+	public void windowOpened(WindowEvent event) {
+	}
+
+	public void windowClosing(WindowEvent event) {
 	    CirSim.main.requestFocus();
 	    setVisible(false);
 	    CirSim.editDialog = null;
-	    return true;
 	}
-	return super.handleEvent(ev);
+
+	@Override
+	public void keyTyped(KeyEvent e) {
     }
 
-    void setBar(EditInfo ei) {
-	int x = (int) (barmax*(ei.value-ei.minval)/(ei.maxval-ei.minval));
-	ei.bar.setValue(x);
+	@Override
+	public void keyPressed(KeyEvent e) {
+	}
+
+	@Override
+	public void keyReleased(KeyEvent e) {
+		if (e.getKeyCode() == KeyEvent.VK_ENTER) {
+			apply();
+			CirSim.main.requestFocus();
+			setVisible(false);
+			CirSim.editDialog = null;
+		}
+		if (e.getKeyCode() == KeyEvent.VK_ESCAPE) {
+			CirSim.main.requestFocus();
+			setVisible(false);
+			CirSim.editDialog = null;
     }
 }
 
+}
# diff -Naurw src.org/EditDialogLayout.java src/EditDialogLayout.java...
--- src.org/EditDialogLayout.java	2015-12-05 20:47:00.000000000 +0100
+++ src/EditDialogLayout.java	2016-03-16 13:09:44.353299013 +0100
@@ -1,4 +1,3 @@
-
 import java.awt.Button;
 import java.awt.Choice;
 import java.awt.Component;
@@ -10,24 +9,32 @@
 import java.awt.Scrollbar;
 
 class EditDialogLayout implements LayoutManager {
-    public EditDialogLayout() {}
+	public EditDialogLayout() {
+	}
+
     @Override
-	public void addLayoutComponent(String name, Component c) {}
+	public void addLayoutComponent(String name, Component c) {
+	}
+
     @Override
-	public void removeLayoutComponent(Component c) {}
+	public void removeLayoutComponent(Component c) {
+	}
+
     @Override
 	public Dimension preferredLayoutSize(Container target) {
 	return new Dimension(500, 500);
     }
+
     @Override
 	public Dimension minimumLayoutSize(Container target) {
 	return new Dimension(100,100);
     }
+
     @Override
 	public void layoutContainer(Container target) {
-	Insets insets = target.insets();
-	int targetw = target.size().width - insets.left - insets.right;
-	int targeth = target.size().height - (insets.top+insets.bottom);
+		Insets insets = target.getInsets();
+		int targetw = target.getSize().width - insets.left - insets.right;
+		int targeth = target.getSize().height - (insets.top + insets.bottom);
 	int i;
 	int h = insets.top;
 	int pw = 300;
@@ -46,8 +53,7 @@
 		if (m instanceof Choice && d.width > targetw)
 		    d.width = targetw-x;
 		if (m instanceof Label) {
-		    Dimension d2 =
-			target.getComponent(i+1).getPreferredSize();
+					Dimension d2 = target.getComponent(i + 1).getPreferredSize();
 		    if (d.height < d2.height)
 			d.height = d2.height;
 		    h += d.height/5;
@@ -59,8 +65,8 @@
 		    if (i != target.getComponentCount()-1)
 			newline = false;
 		}
-		m.move(insets.left+x, h);
-		m.resize(d.width, d.height);
+				m.setLocation(insets.left + x, h);
+				m.setSize(d.width, d.height);
 		if (newline) {
 		    h += d.height;
 		    x = 0;
@@ -68,8 +74,7 @@
 		    x += d.width;
 	    }
 	}
-	if (target.size().height < h)
-	    target.resize(pw + insets.right, h + insets.bottom);
+		if (target.getSize().height < h)
+			target.setSize(pw + insets.right, h + insets.bottom);
     }
 };
-
# diff -Naurw src.org/EditInfo.java src/EditInfo.java...
--- src.org/EditInfo.java	2015-12-05 20:46:58.000000000 +0100
+++ src/EditInfo.java	2016-03-16 13:09:50.597186322 +0100
@@ -1,4 +1,3 @@
-
 import java.awt.Checkbox;
 import java.awt.Choice;
 import java.awt.Scrollbar;
@@ -17,11 +16,15 @@
 	    minval = mn;
 	    maxval = mx;
 	}
-	forceLargeM = name.indexOf("(ohms)") > 0 ||
-	    name.indexOf("(Hz)") > 0;
+		forceLargeM = name.indexOf("(ohms)") > 0 || name.indexOf("(Hz)") > 0;
 	dimensionless = false;
     }
-    EditInfo setDimensionless() { dimensionless = true; return this; }
+
+	EditInfo setDimensionless() {
+		dimensionless = true;
+		return this;
+	}
+
     String name, text;
     double value, minval, maxval;
     TextField textf;
@@ -32,4 +35,3 @@
     boolean forceLargeM;
     boolean dimensionless;
 }
-    
# diff -Naurw src.org/EditOptions.java src/EditOptions.java...
--- src.org/EditOptions.java	2015-12-05 20:47:02.000000000 +0100
+++ src/EditOptions.java	2016-03-16 13:10:20.408648277 +0100
@@ -1,17 +1,20 @@
-
 class EditOptions implements Editable {
     CirSim sim;
-    public EditOptions(CirSim s) { sim = s; }
+
+	public EditOptions(CirSim s) {
+		sim = s;
+	}
+
     @Override
 	public EditInfo getEditInfo(int n) {
 	if (n == 0)
 	    return new EditInfo("Time step size (s)", sim.timeStep, 0, 0);
 	if (n == 1)
-	    return new EditInfo("Range for voltage color (V)",
-				CircuitElm.voltageRange, 0, 0);
+			return new EditInfo("Range for voltage color (V)", CircuitElm.voltageRange, 0, 0);
 	    
 	return null;
     }
+
     @Override
 	public void setEditValue(int n, EditInfo ei) {
 	if (n == 0 && ei.value > 0)
# diff -Naurw src.org/GateElm.java src/GateElm.java...
--- src.org/GateElm.java	2015-12-05 20:46:58.000000000 +0100
+++ src/GateElm.java	2016-03-16 13:10:27.040528578 +0100
@@ -1,4 +1,3 @@
-
 import java.awt.Graphics;
 import java.awt.Point;
 import java.awt.Polygon;
@@ -15,16 +14,21 @@
 	    inputCount = 2;
 	    setSize(sim.smallGridCheckItem.getState() ? 1 : 2);
 	}
-	public GateElm(int xa, int ya, int xb, int yb, int f,
-			StringTokenizer st) {
+
+	public GateElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	    super(xa, ya, xb, yb, f);
 	    inputCount = new Integer(st.nextToken()).intValue();
 	    lastOutput = new Double (st.nextToken()).doubleValue() > 2.5;
 	    noDiagonal = true;
 	    setSize((f & FLAG_SMALL) != 0 ? 1 : 2);
 	}
-	boolean isInverting() { return false; }
+
+	boolean isInverting() {
+		return false;
+	}
+
 	int gsize, gwidth, gwidth2, gheight, hs2;
+
 	void setSize(int s) {
 	    gsize = s;
 	    gwidth = 7*s;
@@ -32,12 +36,15 @@
 	    gheight = 8*s;
 	    flags = (s == 1) ? FLAG_SMALL : 0;
 	}
+
 	@Override
 	String dump() {
 	    return super.dump() + " " + inputCount + " " + volts[inputCount];
 	}
+
 	Point inPosts[], inGates[];
 	int ww;
+
 	@Override
 	void setPoints() {
 	    super.setPoints();
@@ -65,6 +72,7 @@
 	    hs2 = gwidth*(inputCount/2+1);
 	    setBbox(point1, point2, hs2);
 	}
+
 	@Override
 	void draw(Graphics g) {
 	    int i;
@@ -85,33 +93,47 @@
 	    drawDots(g, lead2, point2, curcount);
 	    drawPosts(g);
 	}
+
 	Polygon gatePoly;
 	Point pcircle, linePoints[];
+
 	@Override
-	int getPostCount() { return inputCount+1; }
+	int getPostCount() {
+		return inputCount + 1;
+	}
+
 	@Override
 	Point getPost(int n) {
 	    if (n == inputCount)
 		return point2;
 	    return inPosts[n];
 	}
+
 	@Override
-	int getVoltageSourceCount() { return 1; }
+	int getVoltageSourceCount() {
+		return 1;
+	}
+
 	abstract String getGateName();
+
 	@Override
 	void getInfo(String arr[]) {
 	    arr[0] = getGateName();
 	    arr[1] = "Vout = " + getVoltageText(volts[inputCount]);
 	    arr[2] = "Iout = " + getCurrentText(getCurrent());
 	}
+
 	@Override
 	void stamp() {
 	    sim.stampVoltageSource(0, nodes[inputCount], voltSource);
 	}
+
 	boolean getInput(int x) {
 	    return volts[x] > 2.5;
 	}
+
 	abstract boolean calcFunction();
+
 	@Override
 	void doStep() {
 	    int i;
@@ -122,25 +144,29 @@
 	    double res = f ? 5 : 0;
 	    sim.updateVoltageSource(0, nodes[inputCount], voltSource, res);
 	}
+
 	@Override
 	public EditInfo getEditInfo(int n) {
 	    if (n == 0)
-		return new EditInfo("# of Inputs", inputCount, 1, 8).
-		    setDimensionless();
+			return new EditInfo("# of Inputs", inputCount, 1, 8).setDimensionless();
 	    return null;
 	}
+
 	@Override
 	public void setEditValue(int n, EditInfo ei) {
 	    inputCount = (int) ei.value;
 	    setPoints();
 	}
+
 	// there is no current path through the gate inputs, but there
 	// is an indirect path through the output to ground.
 	@Override
-	boolean getConnection(int n1, int n2) { return false; }
+	boolean getConnection(int n1, int n2) {
+		return false;
+	}
+
 	@Override
 	boolean hasGroundConnection(int n1) {
 	    return (n1 == inputCount);
 	}
     }
-
# diff -Naurw src.org/GroundElm.java src/GroundElm.java...
--- src.org/GroundElm.java	2015-12-05 20:46:58.000000000 +0100
+++ src/GroundElm.java	2016-03-16 13:10:37.184345506 +0100
@@ -1,17 +1,25 @@
-
 import java.awt.Graphics;
 import java.util.StringTokenizer;
 
     class GroundElm extends CircuitElm {
-	public GroundElm(int xx, int yy) { super(xx, yy); }
-	public GroundElm(int xa, int ya, int xb, int yb, int f,
-			 StringTokenizer st) {
+	public GroundElm(int xx, int yy) {
+		super(xx, yy);
+	}
+
+	public GroundElm(int xa, int ya, int xb, int yb, int f, @SuppressWarnings("unused") StringTokenizer st) {
 	    super(xa, ya, xb, yb, f);
 	}
+
 	@Override
-	int getDumpType() { return 'g'; }
+	int getDumpType() {
+		return 'g';
+	}
+
 	@Override
-	int getPostCount() { return 1; }
+	int getPostCount() {
+		return 1;
+	}
+
 	@Override
 	void draw(Graphics g) {
 	    setVoltageColor(g, 0);
@@ -28,23 +36,40 @@
 	    setBbox(point1, ps2, 11);
 	    drawPost(g, x, y, nodes[0]);
 	}
+
 	@Override
-	void setCurrent(int x, double c) { current = -c; }
+	void setCurrent(int x, double c) {
+		current = -c;
+	}
+
 	@Override
 	void stamp() {
 	    sim.stampVoltageSource(0, nodes[0], voltSource, 0);
 	}
+
 	@Override
-	double getVoltageDiff() { return 0; }
+	double getVoltageDiff() {
+		return 0;
+	}
+
 	@Override
-	int getVoltageSourceCount() { return 1; }
+	int getVoltageSourceCount() {
+		return 1;
+	}
+
 	@Override
 	void getInfo(String arr[]) {
 	    arr[0] = "ground";
 	    arr[1] = "I = " + getCurrentText(getCurrent());
 	}
+
 	@Override
-	boolean hasGroundConnection(int n1) { return true; }
+	boolean hasGroundConnection(int n1) {
+		return true;
+	}
+
 	@Override
-	boolean needsShortcut() { return true; }
+	boolean needsShortcut() {
+		return true;
+	}
     }
# diff -Naurw src.org/ImportDialog.java src/ImportDialog.java...
--- src.org/ImportDialog.java	2015-12-05 20:46:58.000000000 +0100
+++ src/ImportDialog.java	2016-03-16 13:10:42.464250215 +0100
@@ -1,14 +1,19 @@
-
 import java.awt.Button;
 import java.awt.Dialog;
 import java.awt.Dimension;
-import java.awt.Event;
+//import java.awt.Event;
 import java.awt.Point;
 import java.awt.TextArea;
 import java.awt.event.ActionEvent;
 import java.awt.event.ActionListener;
+import java.awt.event.WindowEvent;
+import java.awt.event.WindowListener;
 
-class ImportDialog extends Dialog implements ActionListener {
+class ImportDialog extends Dialog implements ActionListener, WindowListener {
+	/**
+	 *
+	 */
+	private static final long serialVersionUID = 1L;
     CirSim cframe;
     Button importButton, closeButton;
     TextArea text;
@@ -27,18 +32,17 @@
 	add(closeButton = new Button("Close"));
 	closeButton.addActionListener(this);
 	Point x = CirSim.main.getLocationOnScreen();
-	resize(400, 300);
+		setSize(400, 300);
 	Dimension d = getSize();
-	setLocation(x.x + (cframe.winSize.width-d.width)/2,
-		    x.y + (cframe.winSize.height-d.height)/2);
-	show();
+		setLocation(x.x + (cframe.winSize.width - d.width) / 2, x.y + (cframe.winSize.height - d.height) / 2);
+		setVisible(true);
 	if (str.length() > 0)
 	    text.selectAll();
+		addWindowListener(this);
     }
 
     @Override
 	public void actionPerformed(ActionEvent e) {
-	int i;
 	Object src = e.getSource();
 	if (src == importButton) {
 	    cframe.readSetup(text.getText());
@@ -48,15 +52,37 @@
 	    setVisible(false);
     }
 	
-    @Override
-	public boolean handleEvent(Event ev) {
-	if (ev.id == Event.WINDOW_DESTROY) {
+	// @Override
+	// public boolean handleEvent(Event ev) {
+	// if (ev.id == Event.WINDOW_DESTROY) {
+	// CirSim.main.requestFocus();
+	// setVisible(false);
+	// CirSim.impDialog = null;
+	// return true;
+	// }
+	// return super.handleEvent(ev);
+	// }
+	public void windowClosed(WindowEvent event) {
+	}
+
+	public void windowDeiconified(WindowEvent event) {
+	}
+
+	public void windowIconified(WindowEvent event) {
+	}
+
+	public void windowActivated(WindowEvent event) {
+	}
+
+	public void windowDeactivated(WindowEvent event) {
+	}
+
+	public void windowOpened(WindowEvent event) {
+	}
+
+	public void windowClosing(WindowEvent event) {
 	    CirSim.main.requestFocus();
 	    setVisible(false);
 	    CirSim.impDialog = null;
-	    return true;
 	}
-	return super.handleEvent(ev);
     }
-}
-    
# diff -Naurw src.org/ImportDialogLayout.java src/ImportDialogLayout.java...
--- src.org/ImportDialogLayout.java	2015-12-05 20:47:00.000000000 +0100
+++ src/ImportDialogLayout.java	2016-03-16 13:10:47.376161565 +0100
@@ -1,4 +1,3 @@
-
 import java.awt.Component;
 import java.awt.Container;
 import java.awt.Dimension;
@@ -6,46 +5,52 @@
 import java.awt.LayoutManager;
 
 class ImportDialogLayout implements LayoutManager {
-    public ImportDialogLayout() {}
+	public ImportDialogLayout() {
+	}
+
     @Override
-	public void addLayoutComponent(String name, Component c) {}
+	public void addLayoutComponent(String name, Component c) {
+	}
+
     @Override
-	public void removeLayoutComponent(Component c) {}
+	public void removeLayoutComponent(Component c) {
+	}
+
     @Override
 	public Dimension preferredLayoutSize(Container target) {
 	return new Dimension(500, 500);
     }
+
     @Override
 	public Dimension minimumLayoutSize(Container target) {
 	return new Dimension(100,100);
     }
+
     @Override
 	public void layoutContainer(Container target) {
-	Insets insets = target.insets();
-	int targetw = target.size().width - insets.left - insets.right;
-	int targeth = target.size().height - (insets.top+insets.bottom);
+		Insets insets = target.getInsets();
+		int targetw = target.getSize().width - insets.left - insets.right;
+		int targeth = target.getSize().height - (insets.top + insets.bottom);
 	int i;
 	int pw = 300;
 	if (target.getComponentCount() == 0)
 	    return;
 	Component cl = target.getComponent(target.getComponentCount()-1);
 	Dimension dl = cl.getPreferredSize();
-	target.getComponent(0).move(insets.left, insets.top);
-	int cw = target.size().width - insets.left - insets.right;
-	int ch = target.size().height - insets.top - insets.bottom -
-	    dl.height;
-	target.getComponent(0).resize(cw, ch);
+		target.getComponent(0).setLocation(insets.left, insets.top);
+		int cw = target.getSize().width - insets.left - insets.right;
+		int ch = target.getSize().height - insets.top - insets.bottom - dl.height;
+		target.getComponent(0).setSize(cw, ch);
 	int h = ch + insets.top;
 	int x = 0;
 	for (i = 1; i < target.getComponentCount(); i++) {
 	    Component m = target.getComponent(i);
 	    if (m.isVisible()) {
 		Dimension d = m.getPreferredSize();
-		m.move(insets.left+x, h);
-		m.resize(d.width, d.height);
+				m.setLocation(insets.left + x, h);
+				m.setSize(d.width, d.height);
 		x += d.width;
 	    }
 	}
     }
 };
-
# diff -Naurw src.org/InductorElm.java src/InductorElm.java...
--- src.org/InductorElm.java	2015-12-05 20:47:02.000000000 +0100
+++ src/InductorElm.java	2016-03-16 13:10:57.523978418 +0100
@@ -1,4 +1,3 @@
-
 import java.awt.Checkbox;
 import java.awt.Graphics;
 import java.util.StringTokenizer;
@@ -6,31 +5,38 @@
     class InductorElm extends CircuitElm {
 	Inductor ind;
 	double inductance;
+
 	public InductorElm(int xx, int yy) {
 	    super(xx, yy);
 	    ind = new Inductor(sim);
 	    inductance = 1;
 	    ind.setup(inductance, current, flags);
 	}
-	public InductorElm(int xa, int ya, int xb, int yb, int f,
-		    StringTokenizer st) {
+
+	public InductorElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	    super(xa, ya, xb, yb, f);
 	    ind = new Inductor(sim);
 	    inductance = new Double(st.nextToken()).doubleValue();
 	    current = new Double(st.nextToken()).doubleValue();
 	    ind.setup(inductance, current, flags);
 	}
+
 	@Override
-	int getDumpType() { return 'l'; }
+	int getDumpType() {
+		return 'l';
+	}
+
 	@Override
 	String dump() {
 	    return super.dump() + " " + inductance + " " + current;
 	}
+
 	@Override
 	void setPoints() {
 	    super.setPoints();
 	    calcLeads(32);
 	}
+
 	@Override
 	void draw(Graphics g) {
 	    double v1 = volts[0];
@@ -48,29 +54,40 @@
 	    doDots(g);
 	    drawPosts(g);
 	}
+
 	@Override
 	void reset() {
 	    current = volts[0] = volts[1] = curcount = 0;
 	    ind.reset();
 	}
+
 	@Override
-	void stamp() { ind.stamp(nodes[0], nodes[1]); }
+	void stamp() {
+		ind.stamp(nodes[0], nodes[1]);
+	}
+
 	@Override
 	void startIteration() {
 	    ind.startIteration(volts[0]-volts[1]);
 	}
+
 	@Override
-	boolean nonLinear() { return ind.nonLinear(); }
+	boolean nonLinear() {
+		return ind.nonLinear();
+	}
+
 	@Override
 	void calculateCurrent() {
 	    double voltdiff = volts[0]-volts[1];
 	    current = ind.calculateCurrent(voltdiff);
 	}
+
 	@Override
 	void doStep() {
 	    double voltdiff = volts[0]-volts[1];
 	    ind.doStep(voltdiff);
 	}
+
 	@Override
 	void getInfo(String arr[]) {
 	    arr[0] = "inductor";
@@ -78,18 +95,19 @@
 	    arr[3] = "L = " + getUnitText(inductance, "H");
 	    arr[4] = "P = " + getUnitText(getPower(), "W");
 	}
+
 	@Override
 	public EditInfo getEditInfo(int n) {
 	    if (n == 0)
 		return new EditInfo("Inductance (H)", inductance, 0, 0);
 	    if (n == 1) {
 		EditInfo ei = new EditInfo("", 0, -1, -1);
-		ei.checkbox = new Checkbox("Trapezoidal Approximation",
-					   ind.isTrapezoidal());
+			ei.checkbox = new Checkbox("Trapezoidal Approximation", ind.isTrapezoidal());
 		return ei;
 	    }
 	    return null;
 	}
+
 	@Override
 	public void setEditValue(int n, EditInfo ei) {
 	    if (n == 0)
# diff -Naurw src.org/Inductor.java src/Inductor.java...
--- src.org/Inductor.java	2015-12-05 20:47:02.000000000 +0100
+++ src/Inductor.java	2016-03-16 13:10:52.676065913 +0100
@@ -1,4 +1,3 @@
-
 class Inductor {
     public static final int FLAG_BACK_EULER = 2;
     int nodes[];
@@ -8,19 +7,26 @@
     double inductance;
     double compResistance, current;
     double curSourceValue;
+
     Inductor(CirSim s) {
 	sim = s;
 	nodes = new int[2];
     }
+
     void setup(double ic, double cr, int f) {
 	inductance = ic;
 	current = cr;
 	flags = f;
     }
-    boolean isTrapezoidal() { return (flags & FLAG_BACK_EULER) == 0; }
+
+	boolean isTrapezoidal() {
+		return (flags & FLAG_BACK_EULER) == 0;
+	}
+
     void reset() {
 	current = 0;
     }
+
     void stamp(int n0, int n1) {
 	// inductor companion model using trapezoidal or backward euler
 	// approximations (Norton equivalent) consists of a current
@@ -37,7 +43,10 @@
 	sim.stampRightSide(nodes[0]);
 	sim.stampRightSide(nodes[1]);
     }
-    boolean nonLinear() { return false; }
+
+	boolean nonLinear() {
+		return false;
+	}
 
     void startIteration(double voltdiff) {
 	if (isTrapezoidal())
@@ -54,7 +63,8 @@
 	    current = voltdiff/compResistance + curSourceValue;
 	return current;
     }
-    void doStep(double voltdiff) {
+
+	void doStep(@SuppressWarnings("unused") double voltdiff) {
 	sim.stampCurrentSource(nodes[0], nodes[1], curSourceValue);
     }
 }
# diff -Naurw src.org/InverterElm.java src/InverterElm.java...
--- src.org/InverterElm.java	2015-12-05 20:47:00.000000000 +0100
+++ src/InverterElm.java	2016-03-16 13:11:03.119877424 +0100
@@ -1,4 +1,3 @@
-
 import java.awt.Graphics;
 import java.awt.Point;
 import java.awt.Polygon;
@@ -6,13 +5,14 @@
 
     class InverterElm extends CircuitElm {
 	double slewRate; // V/ns
+
 	public InverterElm(int xx, int yy) {
 	    super(xx, yy);
 	    noDiagonal = true;
 	    slewRate = .5;
 	}
-	public InverterElm(int xa, int ya, int xb, int yb, int f,
-			      StringTokenizer st) {
+
+	public InverterElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	    super(xa, ya, xb, yb, f);
 	    noDiagonal = true;
 	    try {
@@ -21,13 +21,17 @@
 		slewRate = .5;
 	    }
 	}
+
 	@Override
 	String dump() {
 	    return super.dump() + " " + slewRate;
 	}
 	
 	@Override
-	int getDumpType() { return 'I'; }
+	int getDumpType() {
+		return 'I';
+	}
+
 	@Override
 	void draw(Graphics g) {
 	    drawPosts(g);
@@ -38,8 +42,10 @@
 	    curcount = updateDotCount(current, curcount);
 	    drawDots(g, lead2, point2, curcount);
 	}
+
 	Polygon gatePoly;
 	Point pcircle;
+
 	@Override
 	void setPoints() {
 	    super.setPoints();
@@ -56,12 +62,17 @@
 	    gatePoly = createPolygon(triPoints);
 	    setBbox(point1, point2, hs);
 	}
+
 	@Override
-	int getVoltageSourceCount() { return 1; }
+	int getVoltageSourceCount() {
+		return 1;
+	}
+
 	@Override
 	void stamp() {
 	    sim.stampVoltageSource(0, nodes[1], voltSource);
 	}
+
 	@Override
 	void doStep() {
 	    double v0 = volts[1];
@@ -70,28 +81,38 @@
 	    out = Math.max(Math.min(v0+maxStep, out), v0-maxStep);
 	    sim.updateVoltageSource(0, nodes[1], voltSource, out);
 	}
+
 	@Override
-	double getVoltageDiff() { return volts[0]; }
+	double getVoltageDiff() {
+		return volts[0];
+	}
+
 	@Override
 	void getInfo(String arr[]) {
 	    arr[0] = "inverter";
 	    arr[1] = "Vi = " + getVoltageText(volts[0]);
 	    arr[2] = "Vo = " + getVoltageText(volts[1]);
 	}
+
 	@Override
 	public EditInfo getEditInfo(int n) {
 	    if (n == 0)
 		return new EditInfo("Slew Rate (V/ns)", slewRate, 0, 0);
 	    return null;
 	}
+
 	@Override
 	public void setEditValue(int n, EditInfo ei) {
 	    slewRate = ei.value;
 	}
+
 	// there is no current path through the inverter input, but there
 	// is an indirect path through the output to ground.
 	@Override
-	boolean getConnection(int n1, int n2) { return false; }
+	boolean getConnection(int n1, int n2) {
+		return false;
+	}
+
 	@Override
 	boolean hasGroundConnection(int n1) {
 	    return (n1 == 1);
# diff -Naurw src.org/InverterSTElm.java src/InverterSTElm.java...
--- src.org/InverterSTElm.java	2015-04-06 06:14:39.000000000 +0200
+++ src/InverterSTElm.java	2016-03-16 12:18:19.280880114 +0100
@@ -13,8 +13,7 @@
 	    slewRate = 0.5;
 	}
 	
-	public InverterSTElm(int xa, int ya, int xb, int yb, int f,
-			      StringTokenizer st) {
+	public InverterSTElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	    super(xa, ya, xb, yb, f);
 	    noDiagonal = true;
 	    try {
@@ -30,7 +29,9 @@
 	}
 	
 	@Override
-	int getDumpType() { return 186; }
+	int getDumpType() {
+		return 186;
+	}
 	
 	@Override
 	void draw(Graphics g) {
@@ -85,7 +86,9 @@
 	}
 	
 	@Override
-	int getVoltageSourceCount() { return 1; }
+	int getVoltageSourceCount() {
+		return 1;
+	}
 	
 	@Override
 	void stamp() {
@@ -103,8 +106,10 @@
 	    	out = 0;
 	    }
 	    if(volts[0] > 1.65 && volts[0] < 3.32) {
-	    	if(v0 == 0) out = 0;
-	    	if(v0 == 5) out = 5;
+			if (v0 == 0)
+				out = 0;
+			if (v0 == 5)
+				out = 5;
 	    }
 	    double maxStep = slewRate * sim.timeStep * 1e9;
 	    out = Math.max(Math.min(v0+maxStep, out), v0-maxStep);
@@ -112,7 +117,9 @@
 	}
 	
 	@Override
-	double getVoltageDiff() { return volts[0]; }
+	double getVoltageDiff() {
+		return volts[0];
+	}
 	
 	@Override
 	void getInfo(String arr[]) {
@@ -136,7 +143,9 @@
 	// there is no current path through the inverter input, but there
 	// is an indirect path through the output to ground.
 	@Override
-	boolean getConnection(int n1, int n2) { return false; }
+	boolean getConnection(int n1, int n2) {
+		return false;
+	}
 	
 	@Override
 	boolean hasGroundConnection(int n1) {
# diff -Naurw src.org/JfetElm.java src/JfetElm.java...
--- src.org/JfetElm.java	2015-12-05 20:47:02.000000000 +0100
+++ src/JfetElm.java	2016-03-16 13:11:15.367656380 +0100
@@ -1,4 +1,3 @@
-
 import java.awt.Graphics;
 import java.awt.Point;
 import java.awt.Polygon;
@@ -9,8 +8,8 @@
 	    super(xx, yy, pnpflag);
 	    noDiagonal = true;
 	}
-	public JfetElm(int xa, int ya, int xb, int yb, int f,
-		       StringTokenizer st) {
+
+	public JfetElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	    super(xa, ya, xb, yb, f, st);
 	    noDiagonal = true;
 	}
@@ -42,6 +41,7 @@
 	    }
 	    drawPosts(g);
 	}
+
 	@Override
 	void setPoints() {
 	    super.setPoints();
@@ -67,13 +67,23 @@
 	    } else
 		arrowPoly = calcArrow(point1, gatePt, 8, 3);
 	}
+
 	@Override
-	int getDumpType() { return 'j'; }
+	int getDumpType() {
+		return 'j';
+	}
+
 	// these values are taken from Hayes+Horowitz p155
 	@Override
-	double getDefaultThreshold() { return -4; }
+	double getDefaultThreshold() {
+		return -4;
+	}
+
 	@Override
-	double getBeta() { return .00125; }
+	double getBeta() {
+		return .00125;
+	}
+
 	@Override
 	void getInfo(String arr[]) {
 	    getFetInfo(arr, "JFET");
# diff -Naurw src.org/JKFlipFlopElm.java src/JKFlipFlopElm.java...
--- src.org/JKFlipFlopElm.java	2015-12-05 20:47:02.000000000 +0100
+++ src/JKFlipFlopElm.java	2016-03-16 13:11:21.055553727 +0100
@@ -1,15 +1,20 @@
-
 import java.util.StringTokenizer;
 
     class JKFlipFlopElm extends ChipElm {
-	public JKFlipFlopElm(int xx, int yy) { super(xx, yy); }
-	public JKFlipFlopElm(int xa, int ya, int xb, int yb, int f,
-			    StringTokenizer st) {
+	public JKFlipFlopElm(int xx, int yy) {
+		super(xx, yy);
+	}
+
+	public JKFlipFlopElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	    super(xa, ya, xb, yb, f, st);
 	    pins[4].value = !pins[3].value;
 	}
+
 	@Override
-	String getChipName() { return "JK flip-flop"; }
+	String getChipName() {
+		return "JK flip-flop";
+	}
+
 	@Override
 	void setupPins() {
 	    sizeX = 2;
@@ -26,10 +31,17 @@
 	    pins[4].output = true;
 	    pins[4].lineOver = true;
 	}
+
 	@Override
-	int getPostCount() { return 5; }
+	int getPostCount() {
+		return 5;
+	}
+
 	@Override
-	int getVoltageSourceCount() { return 2; }
+	int getVoltageSourceCount() {
+		return 2;
+	}
+
 	@Override
 	void execute() {
 	    if (!pins[1].value && lastClock) {
@@ -46,6 +58,9 @@
 	    }
 	    lastClock = pins[1].value;
 	}
+
 	@Override
-	int getDumpType() { return 156; }
+	int getDumpType() {
+		return 156;
+	}
     }
# diff -Naurw src.org/LampElm.java src/LampElm.java...
--- src.org/LampElm.java	2015-12-05 20:46:58.000000000 +0100
+++ src/LampElm.java	2016-03-16 13:11:26.639452951 +0100
@@ -1,4 +1,3 @@
-
 import java.awt.Color;
 import java.awt.Graphics;
 import java.awt.Point;
@@ -8,6 +7,7 @@
 	double resistance;
 	final double roomTemp = 300;
 	double temp, nom_pow, nom_v, warmTime, coolTime;
+
 	public LampElm(int xx, int yy) {
 	    super(xx, yy);
 	    temp = roomTemp;
@@ -16,8 +16,8 @@
 	    warmTime = .4;
 	    coolTime = .4;
 	}
-	public LampElm(int xa, int ya, int xb, int yb, int f,
-		    StringTokenizer st) {
+
+	public LampElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	    super(xa, ya, xb, yb, f);
 	    temp = new Double(st.nextToken()).doubleValue();
 	    nom_pow = new Double(st.nextToken()).doubleValue();
@@ -25,13 +25,16 @@
 	    warmTime = new Double(st.nextToken()).doubleValue();
 	    coolTime = new Double(st.nextToken()).doubleValue();
 	}
+
 	@Override
 	String dump() {
-	    return super.dump() + " " + temp + " " + nom_pow + " " + nom_v +
-		" " + warmTime + " " + coolTime;
+		return super.dump() + " " + temp + " " + nom_pow + " " + nom_v + " " + warmTime + " " + coolTime;
 	}
+
 	@Override
-	int getDumpType() { return 181; }
+	int getDumpType() {
+		return 181;
+	}
 
 	Point bulbLead[], filament[], bulb;
 	int bulbR;
@@ -41,7 +44,9 @@
 	    super.reset();
 	    temp = roomTemp;
 	}
+
 	final int filament_len = 24;
+
 	@Override
 	void setPoints() {
 	    super.setPoints();
@@ -85,8 +90,7 @@
 	    double v1 = volts[0];
 	    double v2 = volts[1];
 	    setBbox(point1, point2, 4);
-	    adjustBbox(bulb.x-bulbR, bulb.y-bulbR,
-		       bulb.x+bulbR, bulb.y+bulbR);
+		adjustBbox(bulb.x - bulbR, bulb.y - bulbR, bulb.x + bulbR, bulb.y + bulbR);
 	    // adjustbbox
 	    draw2Leads(g);
 	    setPowerColor(g, true);
@@ -120,22 +124,25 @@
 	    current = (volts[0]-volts[1])/resistance;
 	    //System.out.print(this + " res current set to " + current + "\n");
 	}
+
 	@Override
 	void stamp() {
 	    sim.stampNonLinear(nodes[0]);
 	    sim.stampNonLinear(nodes[1]);
 	}
+
 	@Override
-	boolean nonLinear() { return true; }
+	boolean nonLinear() {
+		return true;
+	}
+
 	@Override
 	void startIteration() {
 	    // based on http://www.intusoft.com/nlpdf/nl11.pdf
 	    double nom_r = nom_v*nom_v/nom_pow;
 	    // this formula doesn't work for values over 5390
 	    double tp = (temp > 5390) ? 5390 : temp;
-	    resistance = nom_r*(1.26104 -
-				4.90662*Math.sqrt(17.1839/tp - 0.00318794) -
-				7.8569/(tp - 187.56));
+		resistance = nom_r * (1.26104 - 4.90662 * Math.sqrt(17.1839 / tp - 0.00318794) - 7.8569 / (tp - 187.56));
 	    double cap = 1.57e-4*nom_pow;
 	    double capw = cap * warmTime/.4;
 	    double capc = cap * coolTime/.4;
@@ -145,10 +152,12 @@
 	    temp -= sim.timeStep*(temp-roomTemp)/(capc*cr);
 	    //System.out.println(capw + " " + capc + " " + temp + " " +resistance);
 	}
+
 	@Override
 	void doStep() {
 	    sim.stampResistor(nodes[0], nodes[1], resistance);
 	}
+
 	@Override
 	void getInfo(String arr[]) {
 	    arr[0] = "lamp";
@@ -157,6 +166,7 @@
 	    arr[4] = "P = " + getUnitText(getPower(), "W");
 	    arr[5] = "T = " + ((int) temp) + " K";
 	}
+
 	@Override
 	public EditInfo getEditInfo(int n) {
 	    // ohmString doesn't work here on linux
@@ -170,6 +180,7 @@
 		return new EditInfo("Cooldown Time (s)", coolTime, 0, 0);
 	    return null;
 	}
+
 	@Override
 	public void setEditValue(int n, EditInfo ei) {
 	    if (n == 0 && ei.value > 0)
# diff -Naurw src.org/LatchElm.java src/LatchElm.java...
--- src.org/LatchElm.java	2015-12-05 20:47:00.000000000 +0100
+++ src/LatchElm.java	2016-03-16 13:11:32.279351165 +0100
@@ -1,17 +1,26 @@
-
 import java.util.StringTokenizer;
 
 class LatchElm extends ChipElm {
-    public LatchElm(int xx, int yy) { super(xx, yy); }
-    public LatchElm(int xa, int ya, int xb, int yb, int f,
-		    StringTokenizer st) {
+	public LatchElm(int xx, int yy) {
+		super(xx, yy);
+	}
+
+	public LatchElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	super(xa, ya, xb, yb, f, st);
     }
+
     @Override
-	String getChipName() { return "Latch"; }
+	String getChipName() {
+		return "Latch";
+	}
+
     @Override
-	boolean needsBits() { return true; }
+	boolean needsBits() {
+		return true;
+	}
+
     int loadPin;
+
     @Override
 	void setupPins() {
 	sizeX = 2;
@@ -28,6 +37,7 @@
 	pins[loadPin] = new Pin(bits, SIDE_W, "Ld");
 	allocNodes();
     }
+
     boolean lastLoad = false;
     
     @Override
@@ -40,10 +50,17 @@
     }
     
     @Override
-	int getVoltageSourceCount() { return bits; }
-    @Override
-	int getPostCount() { return bits*2+1; }
+	int getVoltageSourceCount() {
+		return bits;
+	}
+
     @Override
-	int getDumpType() { return 168; }
+	int getPostCount() {
+		return bits * 2 + 1;
 }
     
+	@Override
+	int getDumpType() {
+		return 168;
+	}
+}
# diff -Naurw src.org/LEDArrayElm.java src/LEDArrayElm.java...
--- src.org/LEDArrayElm.java	2015-12-05 20:47:02.000000000 +0100
+++ src/LEDArrayElm.java	2016-03-16 13:11:38.639236385 +0100
@@ -1,19 +1,22 @@
-
 import java.awt.Color;
 import java.awt.Graphics;
 import java.util.StringTokenizer;
 
 class LEDArrayElm extends ChipElm {
-	public LEDArrayElm(int xx, int yy) { super(xx, yy); }
-	public LEDArrayElm(int xa, int ya, int xb, int yb, int f,
-			   StringTokenizer st) {
+	public LEDArrayElm(int xx, int yy) {
+		super(xx, yy);
+	}
+
+	public LEDArrayElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	    super(xa, ya, xb, yb, f, st);
 	}
 	
 	@Override
-	String getChipName() { return "LED Array"; }
-	Color darkgreen;
+	String getChipName() {
+		return "LED Array";
+	}
 	
+	Color darkgreen;
 	
 	@Override
 	void setupPins() {
@@ -74,14 +77,21 @@
 	}
 	
 	void setColor(Graphics g, int p) {
-	    g.setColor(pins[p].value ? Color.green :
-		       sim.printableCheckItem.getState() ? Color.white : darkgreen);
+		g.setColor(pins[p].value ? Color.green : sim.printableCheckItem.getState() ? Color.white : darkgreen);
 	}
 	
 	@Override
-	int getPostCount() { return 10; }
+	int getPostCount() {
+		return 10;
+	}
+
 	@Override
-	int getVoltageSourceCount() { return 0; }
+	int getVoltageSourceCount() {
+		return 0;
+	}
+
 	@Override
-	int getDumpType() { return 176; }
+	int getDumpType() {
+		return 176;
+	}
 }
# diff -Naurw src.org/LEDElm.java src/LEDElm.java...
--- src.org/LEDElm.java	2015-12-05 20:47:00.000000000 +0100
+++ src/LEDElm.java	2016-03-16 13:11:56.754909444 +0100
@@ -1,4 +1,3 @@
-
 import java.awt.Color;
 import java.awt.Graphics;
 import java.awt.Point;
@@ -6,14 +5,16 @@
 
     class LEDElm extends DiodeElm {
 	double colorR, colorG, colorB;
+
 	public LEDElm(int xx, int yy) {
 	    super(xx, yy);
 	    fwdrop = 2.1024259;
 	    setup();
-	    colorR = 1; colorG = colorB = 0;
+		colorR = 1;
+		colorG = colorB = 0;
 	}
-	public LEDElm(int xa, int ya, int xb, int yb, int f,
-		      StringTokenizer st) {
+
+	public LEDElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	    super(xa, ya, xb, yb, f, st);
 	    if ((f & FLAG_FWDROP) == 0)
 		fwdrop = 2.1024259;
@@ -22,14 +23,19 @@
 	    colorG = new Double(st.nextToken()).doubleValue();
 	    colorB = new Double(st.nextToken()).doubleValue();
 	}
+
 	@Override
-	int getDumpType() { return 162; }
+	int getDumpType() {
+		return 162;
+	}
+
 	@Override
 	String dump() {
 	    return super.dump() + " " + colorR + " " + colorG + " " + colorB;
 	}
 
 	Point ledLead1, ledLead2, ledCenter;
+
 	@Override
 	void setPoints() {
 	    super.setPoints();
@@ -57,8 +63,7 @@
 	    double w = 255*current/.01;
 	    if (w > 255)
 		w = 255;
-	    Color cc = new Color((int) (colorR*w), (int) (colorG*w),
-				 (int) (colorB*w));
+		Color cc = new Color((int) (colorR * w), (int) (colorG * w), (int) (colorB * w));
 	    g.setColor(cc);
 	    g.fillOval(ledCenter.x-cr, ledCenter.y-cr, cr*2, cr*2);
 	    setBbox(point1, point2, cr);
@@ -79,16 +84,14 @@
 	    if (n == 0)
 		return super.getEditInfo(n);
 	    if (n == 1)
-		return new EditInfo("Red Value (0-1)", colorR, 0, 1).
-		    setDimensionless();
+			return new EditInfo("Red Value (0-1)", colorR, 0, 1).setDimensionless();
 	    if (n == 2)
-		return new EditInfo("Green Value (0-1)", colorG, 0, 1).
-		    setDimensionless();
+			return new EditInfo("Green Value (0-1)", colorG, 0, 1).setDimensionless();
 	    if (n == 3)
-		return new EditInfo("Blue Value (0-1)", colorB, 0, 1).
-		    setDimensionless();
+			return new EditInfo("Blue Value (0-1)", colorB, 0, 1).setDimensionless();
 	    return null;
 	}
+
 	@Override
 	public void setEditValue(int n, EditInfo ei) {
 	    if (n == 0)
# diff -Naurw src.org/LogicInputElm.java src/LogicInputElm.java...
--- src.org/LogicInputElm.java	2015-12-05 20:47:02.000000000 +0100
+++ src/LogicInputElm.java	2016-03-16 13:12:01.862817261 +0100
@@ -1,4 +1,3 @@
-
 import java.awt.Checkbox;
 import java.awt.Font;
 import java.awt.Graphics;
@@ -8,13 +7,14 @@
 	final int FLAG_TERNARY = 1;
 	final int FLAG_NUMERIC = 2;
 	double hiV, loV;
+
 	public LogicInputElm(int xx, int yy) {
 	    super(xx, yy, false);
 	    hiV = 5;
 	    loV = 0;
 	}
-	public LogicInputElm(int xa, int ya, int xb, int yb, int f,
-			     StringTokenizer st) {
+
+	public LogicInputElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	    super(xa, ya, xb, yb, f, st);
 	    try {
 		hiV = new Double(st.nextToken()).doubleValue();
@@ -26,21 +26,36 @@
 	    if (isTernary())
 		posCount = 3;
 	}
-	boolean isTernary() { return (flags & FLAG_TERNARY) != 0; }
-	boolean isNumeric() { return (flags & (FLAG_TERNARY|FLAG_NUMERIC)) != 0; }
+
+	boolean isTernary() {
+		return (flags & FLAG_TERNARY) != 0;
+	}
+
+	boolean isNumeric() {
+		return (flags & (FLAG_TERNARY | FLAG_NUMERIC)) != 0;
+	}
+
 	@Override
-	int getDumpType() { return 'L'; }
+	int getDumpType() {
+		return 'L';
+	}
+
 	@Override
 	String dump() {
 	    return super.dump() + " " + hiV + " " + loV;
 	}
+
 	@Override
-	int getPostCount() { return 1; }
+	int getPostCount() {
+		return 1;
+	}
+
 	@Override
 	void setPoints() {
 	    super.setPoints();
 	    lead1 = interpPoint(point1, point2, 1-12/dn);
 	}
+
 	@Override
 	void draw(Graphics g) {
 	    Font f = new Font("SansSerif", Font.BOLD, 20);
@@ -57,8 +72,12 @@
 	    drawDots(g, point1, lead1, curcount);
 	    drawPosts(g);
 	}
+
 	@Override
-	void setCurrent(int vs, double c) { current = -c; }
+	void setCurrent(int vs, double c) {
+		current = -c;
+	}
+
 	@Override
 	void stamp() {
 	    double v = (position == 0) ? loV : hiV;
@@ -66,10 +85,17 @@
 		v = position * 2.5;
 	    sim.stampVoltageSource(0, nodes[0], voltSource, v);
 	}
+
 	@Override
-	int getVoltageSourceCount() { return 1; }
+	int getVoltageSourceCount() {
+		return 1;
+	}
+
 	@Override
-	double getVoltageDiff() { return volts[0]; }
+	double getVoltageDiff() {
+		return volts[0];
+	}
+
 	@Override
 	void getInfo(String arr[]) {
 	    arr[0] = "logic input";
@@ -79,8 +105,12 @@
 	    arr[1] += " (" + getVoltageText(volts[0]) + ")";
 	    arr[2] = "I = " + getCurrentText(getCurrent());
 	}
+
 	@Override
-	boolean hasGroundConnection(int n1) { return true; }
+	boolean hasGroundConnection(int n1) {
+		return true;
+	}
+
 	@Override
 	public EditInfo getEditInfo(int n) {
 	    if (n == 0) {
@@ -94,6 +124,7 @@
 		return new EditInfo("Low Voltage", loV, 10, -10);
 	    return null;
 	}
+
 	@Override
 	public void setEditValue(int n, EditInfo ei) {
 	    if (n == 0)
# diff -Naurw src.org/LogicOutputElm.java src/LogicOutputElm.java...
--- src.org/LogicOutputElm.java	2015-12-05 20:47:00.000000000 +0100
+++ src/LogicOutputElm.java	2016-03-16 13:12:08.070705225 +0100
@@ -1,4 +1,3 @@
-
 import java.awt.Checkbox;
 import java.awt.Font;
 import java.awt.Graphics;
@@ -10,12 +9,13 @@
 	final int FLAG_PULLDOWN = 4;
 	double threshold;
 	String value;
+
 	public LogicOutputElm(int xx, int yy) {
 	    super(xx, yy);
 	    threshold = 2.5;
 	}
-	public LogicOutputElm(int xa, int ya, int xb, int yb, int f,
-			      StringTokenizer st) {
+
+	public LogicOutputElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	    super(xa, ya, xb, yb, f);
 	    try {
 		threshold = new Double(st.nextToken()).doubleValue();
@@ -23,22 +23,40 @@
 		threshold = 2.5;
 	    }
 	}
+
 	@Override
 	String dump() {
 	    return super.dump() + " " + threshold;
 	}
+
 	@Override
-	int getDumpType() { return 'M'; }
+	int getDumpType() {
+		return 'M';
+	}
+
 	@Override
-	int getPostCount() { return 1; }
-	boolean isTernary() { return (flags & FLAG_TERNARY) != 0; }
-	boolean isNumeric() { return (flags & (FLAG_TERNARY|FLAG_NUMERIC)) != 0; }
-	boolean needsPullDown() { return (flags & FLAG_PULLDOWN) != 0; }
+	int getPostCount() {
+		return 1;
+	}
+
+	boolean isTernary() {
+		return (flags & FLAG_TERNARY) != 0;
+	}
+
+	boolean isNumeric() {
+		return (flags & (FLAG_TERNARY | FLAG_NUMERIC)) != 0;
+	}
+
+	boolean needsPullDown() {
+		return (flags & FLAG_PULLDOWN) != 0;
+	}
+
 	@Override
 	void setPoints() {
 	    super.setPoints();
 	    lead1 = interpPoint(point1, point2, 1-12/dn);
 	}
+
 	@Override
 	void draw(Graphics g) {
 	    Font f = new Font("SansSerif", Font.BOLD, 20);
@@ -62,13 +80,18 @@
 	    drawThickLine(g, point1, lead1);
 	    drawPosts(g);
 	}
+
 	@Override
 	void stamp() {
 	    if (needsPullDown())
 		sim.stampResistor(nodes[0], 0, 1e6);
 	}
+
 	@Override
-	double getVoltageDiff() { return volts[0]; }
+	double getVoltageDiff() {
+		return volts[0];
+	}
+
 	@Override
 	void getInfo(String arr[]) {
 	    arr[0] = "logic output";
@@ -77,6 +100,7 @@
 		arr[1] = value;
 	    arr[2] = "V = " + getVoltageText(volts[0]);
 	}
+
 	@Override
 	public EditInfo getEditInfo(int n) {
 	    if (n == 0)
@@ -88,6 +112,7 @@
 	    }
 	    return null;
 	}
+
 	@Override
 	public void setEditValue(int n, EditInfo ei) {
 	    if (n == 0)
# diff -Naurw src.org/LogoFrame.java src/LogoFrame.java...
--- src.org/LogoFrame.java	2015-12-06 06:24:32.000000000 +0100
+++ src/LogoFrame.java	2016-03-16 12:18:19.360878675 +0100
@@ -1,10 +1,8 @@
-import java.awt.Color;
 import java.awt.Dimension;
 import java.awt.Graphics;
 import java.awt.Graphics2D;
 import java.awt.Toolkit;
 import java.awt.image.BufferedImage;
-import java.io.File;
 import java.io.IOException;
 
 import javax.imageio.ImageIO;
@@ -12,14 +10,18 @@
 import javax.swing.JDialog;
 
 /*
- * Code by Federico García García.
+ * Code by Federico GarcÃ­a GarcÃ­a.
  * 06/12/2015.
  * 
  * Frame that shows the logo at startup.
  */
 
-
 public class LogoFrame extends JDialog {
+	/**
+	 *
+	 */
+	private static final long serialVersionUID = 1L;
+
 	public LogoFrame() {
 		super();
 		setUndecorated(true);
@@ -34,6 +36,10 @@
 }
 
 class LogoFrameCanvas extends JComponent {
+	/**
+	 *
+	 */
+	private static final long serialVersionUID = 1L;
 	private BufferedImage img = null;
 	
 	public LogoFrameCanvas() {
# diff -Naurw src.org/Matrix5x7Elm.java src/Matrix5x7Elm.java...
--- src.org/Matrix5x7Elm.java	2015-12-05 20:47:00.000000000 +0100
+++ src/Matrix5x7Elm.java	2016-03-16 13:12:17.502535008 +0100
@@ -1,21 +1,26 @@
-
 import java.awt.Color;
 import java.awt.Graphics;
 import java.util.StringTokenizer;
 
 class Matrix5x7Elm extends ChipElm {
-	public Matrix5x7Elm(int xx, int yy) { super(xx, yy); }
-	public Matrix5x7Elm(int xa, int ya, int xb, int yb, int f,
-			   StringTokenizer st) {
+	public Matrix5x7Elm(int xx, int yy) {
+		super(xx, yy);
+	}
+
+	public Matrix5x7Elm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	    super(xa, ya, xb, yb, f, st);
 	}
 	
 	@Override
-	String getChipName() { return "5x7 matrix driver/display"; }
+	String getChipName() {
+		return "5x7 matrix driver/display";
+	}
 	
 	Color darkred;
 	
-	boolean needsBits() { return true; }
+	boolean needsBits() {
+		return true;
+	}
 	
 	@Override
 	void setupPins() {
@@ -55,7 +60,6 @@
 	    int ys = csize*12;
 	    int p = csize*5;
 	    
-	    
 	    for(int b=0; b<5; b++) {
 		    for(int a=0; a<7; a++) {
 			    g.setColor(darkred);
@@ -63,7 +67,6 @@
 		    }
 	    }
 	    
-	    
 	    for(int b=0; b<7; b++) {
 	    	if(pins[b].value == true) {
 			    for(int a=0; a<5; a++) {
@@ -74,27 +77,33 @@
 	    }
 	    
 	    /*
-		if(pins[0].value == true) {
-			g.setColor(pins[7].value ? Color.red : darkred);
-			g.fillOval(xl+(xs*(1)), yl+(ys*(1)), p, p);
-			
-			g.setColor(pins[8].value ? Color.red : darkred);
-			g.fillOval(xl+(xs*(2)), yl+(ys*(1)), p, p);
-			
-		}
+		 * if(pins[0].value == true) { g.setColor(pins[7].value ? Color.red :
+		 * darkred); g.fillOval(xl+(xs*(1)), yl+(ys*(1)), p, p);
+		 *
+		 * g.setColor(pins[8].value ? Color.red : darkred);
+		 * g.fillOval(xl+(xs*(2)), yl+(ys*(1)), p, p);
+		 *
+		 * }
 	    */
 	    //System.out.println("+");
 	}
 	
 	void setColor(Graphics g, int p) {
-	    g.setColor(pins[p].value ? Color.red :
-		       sim.printableCheckItem.getState() ? Color.white : darkred);
+		g.setColor(pins[p].value ? Color.red : sim.printableCheckItem.getState() ? Color.white : darkred);
 	}
 	
 	@Override
-	int getVoltageSourceCount() { return 0; }	
+	int getVoltageSourceCount() {
+		return 0;
+	}
+
 	@Override
-	int getPostCount() { return 7+5; }
+	int getPostCount() {
+		return 7 + 5;
+	}
+
 	@Override
-	int getDumpType() { return 180; }
+	int getDumpType() {
+		return 180;
+	}
 }
# diff -Naurw src.org/MemristorElm.java src/MemristorElm.java...
--- src.org/MemristorElm.java	2015-12-05 20:47:00.000000000 +0100
+++ src/MemristorElm.java	2016-03-16 13:12:23.474427233 +0100
@@ -1,10 +1,10 @@
-
 import java.awt.Graphics;
 import java.awt.Point;
 import java.util.StringTokenizer;
 
 class MemristorElm extends CircuitElm {
     double r_on, r_off, dopeWidth, totalWidth, mobility, resistance;
+
     public MemristorElm(int xx, int yy) {
 	super(xx, yy);
 	r_on = 100;
@@ -14,8 +14,8 @@
 	mobility = 1e-10;   // m^2/sV
 	resistance = 100;
     }
-    public MemristorElm(int xa, int ya, int xb, int yb, int f,
-			StringTokenizer st) {
+
+	public MemristorElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	super(xa, ya, xb, yb, f);
 	r_on = new Double(st.nextToken()).doubleValue();
 	r_off = new Double(st.nextToken()).doubleValue();
@@ -24,15 +24,19 @@
 	mobility = new Double(st.nextToken()).doubleValue();
 	resistance = 100;
     }
+
     @Override
-	int getDumpType() { return 'm'; }
+	int getDumpType() {
+		return 'm';
+	}
+
     @Override
 	String dump() {
-	return super.dump() + " " + r_on + " " + r_off + " " + dopeWidth + " " +
-	    totalWidth + " " + mobility;
+		return super.dump() + " " + r_on + " " + r_off + " " + dopeWidth + " " + totalWidth + " " + mobility;
     }
 
     Point ps3, ps4;
+
     @Override
 	void setPoints() {
 	super.setPoints();
@@ -76,15 +80,20 @@
     }
     
     @Override
-	boolean nonLinear() { return true; }
+	boolean nonLinear() {
+		return true;
+	}
+
     @Override
 	void calculateCurrent() {
 	current = (volts[0]-volts[1])/resistance;
     }
+
     @Override
 	void reset() {
 	dopeWidth = 0;
     }
+
     @Override
 	void startIteration() {
 	double wd = dopeWidth/totalWidth;
@@ -95,15 +104,18 @@
 	    dopeWidth = totalWidth;
 	resistance = r_on * wd + r_off * (1-wd);
     }
+
     @Override
 	void stamp() {
 	sim.stampNonLinear(nodes[0]);
 	sim.stampNonLinear(nodes[1]);
     }
+
     @Override
 	void doStep() {
 	sim.stampResistor(nodes[0], nodes[1], resistance);
     }
+
     @Override
 	void getInfo(String arr[]) {
 	arr[0] = "memristor";
@@ -111,14 +123,17 @@
 	arr[3] = "R = " + getUnitText(resistance, CirSim.ohmString);
 	arr[4] = "P = " + getUnitText(getPower(), "W");
     }
+
     @Override
 	double getScopeValue(int x) {
 	return (x == 2) ? resistance : (x == 1) ? getPower() : getVoltageDiff();
     }
+
     @Override
 	String getScopeUnits(int x) {
 	return (x == 2) ? CirSim.ohmString : (x == 1) ? "W" : "V";
     }
+
     @Override
 	public EditInfo getEditInfo(int n) {
 	if (n == 0)
@@ -133,6 +148,7 @@
 	    return new EditInfo("Mobility (um^2/(s*V))", mobility*1e12, 0, 0);
 	return null;
     }
+
     @Override
 	public void setEditValue(int n, EditInfo ei) {
 	if (n == 0)
@@ -147,4 +163,3 @@
 	    mobility = ei.value*1e-12;
     }
 }
-
# diff -Naurw src.org/MosfetElm.java src/MosfetElm.java...
--- src.org/MosfetElm.java	2015-12-05 20:47:02.000000000 +0100
+++ src/MosfetElm.java	2016-03-16 13:12:28.670333462 +0100
@@ -1,4 +1,3 @@
-
 import java.awt.Checkbox;
 import java.awt.Color;
 import java.awt.Graphics;
@@ -12,6 +11,7 @@
 	int FLAG_SHOWVT = 2;
 	int FLAG_DIGITAL = 4;
 	double vt;
+
 	MosfetElm(int xx, int yy, boolean pnpflag) {
 	    super(xx, yy);
 	    pnp = (pnpflag) ? -1 : 1;
@@ -19,31 +19,50 @@
 	    noDiagonal = true;
 	    vt = getDefaultThreshold();
 	}
-	public MosfetElm(int xa, int ya, int xb, int yb, int f,
-			 StringTokenizer st) {
+
+	public MosfetElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	    super(xa, ya, xb, yb, f);
 	    pnp = ((f & FLAG_PNP) != 0) ? -1 : 1;
 	    noDiagonal = true;
 	    vt = getDefaultThreshold();
 	    try {
 		vt = new Double(st.nextToken()).doubleValue();
-	    } catch (Exception e) {}
+		} catch (Exception e) {
 	}
-	double getDefaultThreshold() { return 1.5; }
-	double getBeta() { return .02; }
+	}
+
+	double getDefaultThreshold() {
+		return 1.5;
+	}
+
+	double getBeta() {
+		return .02;
+	}
+
 	@Override
-	boolean nonLinear() { return true; }
-	boolean drawDigital() { return (flags & FLAG_DIGITAL) != 0; }
+	boolean nonLinear() {
+		return true;
+	}
+
+	boolean drawDigital() {
+		return (flags & FLAG_DIGITAL) != 0;
+	}
+
 	@Override
 	void reset() {
 	    lastv1 = lastv2 = volts[0] = volts[1] = volts[2] = curcount = 0;
 	}
+
 	@Override
 	String dump() {
 	    return super.dump() + " " + vt;
 	}
+
 	@Override
-	int getDumpType() { return 'f'; }
+	int getDumpType() {
+		return 'f';
+	}
+
 	final int hs = 16;
 	
 	@Override
@@ -90,7 +109,12 @@
 		g.setFont(unitsFont);
 		int ds = sign(dx);
 		g.drawString("G", gate[1].x-10*ds, gate[1].y-5);
-		g.drawString(pnp == -1 ? "D" : "S", src[0].x-3+9*ds, src[0].y+4); // x+6 if ds=1, -12 if -1
+			g.drawString(pnp == -1 ? "D" : "S", src[0].x - 3 + 9 * ds, src[0].y + 4); // x+6
+																						// if
+																						// ds=1,
+																						// -12
+																						// if
+																						// -1
 		g.drawString(pnp == -1 ? "S" : "D", drn[0].x-3+9*ds, drn[0].y+4);
 	    }	    
 	    curcount = updateDotCount(-ids, curcount);
@@ -99,16 +123,26 @@
 	    drawDots(g, drn[1], drn[0], curcount);
 	    drawPosts(g);
 	}
+
 	@Override
 	Point getPost(int n) {
 	    return (n == 0) ? point1 : (n == 1) ? src[0] : drn[0];
 	}
+
 	@Override
-	double getCurrent() { return ids; }
+	double getCurrent() {
+		return ids;
+	}
+
 	@Override
-	double getPower() { return ids*(volts[2]-volts[1]); }
+	double getPower() {
+		return ids * (volts[2] - volts[1]);
+	}
+
 	@Override
-	int getPostCount() { return 3; }
+	int getPostCount() {
+		return 3;
+	}
 
 	int pcircler;
 	Point src[], drn[], gate[], pcircle;
@@ -128,7 +162,8 @@
 	    interpPoint2(point1, point2, src[2], drn[2], 1-22/dn, -hs2*4/3);
 
 	    gate = newPointArray(3);
-	    interpPoint2(point1, point2, gate[0], gate[2], 1-28/dn, hs2/2); // was 1-20/dn
+		interpPoint2(point1, point2, gate[0], gate[2], 1 - 28 / dn, hs2 / 2); // was
+																				// 1-20/dn
 	    interpPoint(gate[0], gate[2], gate[1], .5);
 
 	    if (!drawDigital()) {
@@ -154,6 +189,7 @@
 	    sim.stampNonLinear(nodes[1]);
 	    sim.stampNonLinear(nodes[2]);
 	}
+
 	@Override
 	void doStep() {
 	    double vs[] = new double[3];
@@ -177,8 +213,7 @@
 	    int gate = 0;
 	    double vgs = vs[gate ]-vs[source];
 	    double vds = vs[drain]-vs[source];
-	    if (Math.abs(lastv1-vs[1]) > .01 ||
-		Math.abs(lastv2-vs[2]) > .01)
+		if (Math.abs(lastv1 - vs[1]) > .01 || Math.abs(lastv2 - vs[2]) > .01)
 		sim.converged = false;
 	    lastv1 = vs[1];
 	    lastv2 = vs[2];
@@ -215,7 +250,9 @@
 		mode = 2;
 	    }
 	    double rs = -pnp*ids + Gds*realvds + gm*realvgs;
-	    //System.out.println("M " + vds + " " + vgs + " " + ids + " " + gm + " "+ Gds + " " + volts[0] + " " + volts[1] + " " + volts[2] + " " + source + " " + rs + " " + this);
+		// System.out.println("M " + vds + " " + vgs + " " + ids + " " + gm + "
+		// "+ Gds + " " + volts[0] + " " + volts[1] + " " + volts[2] + " " +
+		// source + " " + rs + " " + this);
 	    sim.stampMatrix(nodes[drain],  nodes[drain],  Gds);
 	    sim.stampMatrix(nodes[drain],  nodes[source], -Gds-gm); 
 	    sim.stampMatrix(nodes[drain],  nodes[gate],   gm);
@@ -226,32 +263,40 @@
 	    
 	    sim.stampRightSide(nodes[drain],  rs);
 	    sim.stampRightSide(nodes[source], -rs);
-	    if (source == 2 && pnp == 1 ||
-		source == 1 && pnp == -1)
+		if (source == 2 && pnp == 1 || source == 1 && pnp == -1)
 		ids = -ids;
 	}
+
 	void getFetInfo(String arr[], String n) {
 	    arr[0] = ((pnp == -1) ? "p-" : "n-") + n;
 	    arr[0] += " (Vt = " + getVoltageText(pnp*vt) + ")";
 	    arr[1] = ((pnp == 1) ? "Ids = " : "Isd = ") + getCurrentText(ids);
 	    arr[2] = "Vgs = " + getVoltageText(volts[0]-volts[pnp == -1 ? 2 : 1]);
 	    arr[3] = ((pnp == 1) ? "Vds = " : "Vsd = ") + getVoltageText(volts[2]-volts[1]);
-	    arr[4] = (mode == 0) ? "off" :
-		(mode == 1) ? "linear" : "saturation";
+		arr[4] = (mode == 0) ? "off" : (mode == 1) ? "linear" : "saturation";
 	    arr[5] = "gm = " + getUnitText(gm, "A/V");
 	}
+
 	@Override
 	void getInfo(String arr[]) {
 	    getFetInfo(arr, "MOSFET");
 	}
+
 	@Override
-	boolean canViewInScope() { return true; }
+	boolean canViewInScope() {
+		return true;
+	}
+
 	@Override
-	double getVoltageDiff() { return volts[2] - volts[1]; }
+	double getVoltageDiff() {
+		return volts[2] - volts[1];
+	}
+
 	@Override
 	boolean getConnection(int n1, int n2) {
 	    return !(n1 == 0 || n2 == 0);
 	}
+
 	@Override
 	public EditInfo getEditInfo(int n) {
 	    if (n == 0)
@@ -264,13 +309,13 @@
 		
 	    return null;
 	}
+
 	@Override
 	public void setEditValue(int n, EditInfo ei) {
 	    if (n == 0)
 		vt = pnp*ei.value;
 	    if (n == 1) {
-		flags = (ei.checkbox.getState()) ? (flags | FLAG_DIGITAL) :
-		    (flags & ~FLAG_DIGITAL);
+			flags = (ei.checkbox.getState()) ? (flags | FLAG_DIGITAL) : (flags & ~FLAG_DIGITAL);
 		setPoints();
 	    }
 	}
# diff -Naurw src.org/NandGateElm.java src/NandGateElm.java...
--- src.org/NandGateElm.java	2015-12-05 20:46:58.000000000 +0100
+++ src/NandGateElm.java	2016-03-16 13:12:34.482228575 +0100
@@ -1,16 +1,26 @@
-
 import java.util.StringTokenizer;
 
     class NandGateElm extends AndGateElm {
-	public NandGateElm(int xx, int yy) { super(xx, yy); }
-	public NandGateElm(int xa, int ya, int xb, int yb, int f,
-			   StringTokenizer st) {
+	public NandGateElm(int xx, int yy) {
+		super(xx, yy);
+	}
+
+	public NandGateElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	    super(xa, ya, xb, yb, f, st);
 	}
+
 	@Override
-	boolean isInverting() { return true; }
+	boolean isInverting() {
+		return true;
+	}
+
 	@Override
-	String getGateName() { return "NAND gate"; }
+	String getGateName() {
+		return "NAND gate";
+	}
+
 	@Override
-	int getDumpType() { return 151; }
+	int getDumpType() {
+		return 151;
+	}
     }
# diff -Naurw src.org/NJfetElm.java src/NJfetElm.java...
--- src.org/NJfetElm.java	2015-12-05 20:47:00.000000000 +0100
+++ src/NJfetElm.java	2016-03-16 13:12:43.386067888 +0100
@@ -1,13 +1,21 @@
-
     class NJfetElm extends JfetElm {
-	public NJfetElm(int xx, int yy) { super(xx, yy, false); }
+	public NJfetElm(int xx, int yy) {
+		super(xx, yy, false);
+	}
+
 	@Override
-	Class getDumpClass() { return JfetElm.class; }
+	Class<JfetElm> getDumpClass() {
+		return JfetElm.class;
+	}
     }
 
     class PJfetElm extends JfetElm {
-	public PJfetElm(int xx, int yy) { super(xx, yy, true); }
-	@Override
-	Class getDumpClass() { return JfetElm.class; }
+	public PJfetElm(int xx, int yy) {
+		super(xx, yy, true);
     }
 
+	@Override
+	Class<JfetElm> getDumpClass() {
+		return JfetElm.class;
+	}
+}
# diff -Naurw src.org/NMosfetElm.java src/NMosfetElm.java...
--- src.org/NMosfetElm.java	2015-12-05 20:46:58.000000000 +0100
+++ src/NMosfetElm.java	2016-03-16 13:12:51.429922722 +0100
@@ -1,6 +1,10 @@
-
     class NMosfetElm extends MosfetElm {
-	public NMosfetElm(int xx, int yy) { super(xx, yy, false); }
+	public NMosfetElm(int xx, int yy) {
+		super(xx, yy, false);
+	}
+
 	@Override
-	Class getDumpClass() { return MosfetElm.class; }
+	Class<MosfetElm> getDumpClass() {
+		return MosfetElm.class;
+	}
     }
# diff -Naurw src.org/NorGateElm.java src/NorGateElm.java...
--- src.org/NorGateElm.java	2015-12-05 20:46:58.000000000 +0100
+++ src/NorGateElm.java	2016-03-16 13:12:58.953786938 +0100
@@ -1,16 +1,26 @@
-
 import java.util.StringTokenizer;
 
     class NorGateElm extends OrGateElm {
-	public NorGateElm(int xx, int yy) { super(xx, yy); }
-	public NorGateElm(int xa, int ya, int xb, int yb, int f,
-			   StringTokenizer st) {
+	public NorGateElm(int xx, int yy) {
+		super(xx, yy);
+	}
+
+	public NorGateElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	    super(xa, ya, xb, yb, f, st);
 	}
+
 	@Override
-	String getGateName() { return "NOR gate"; }
+	String getGateName() {
+		return "NOR gate";
+	}
+
 	@Override
-	boolean isInverting() { return true; }
+	boolean isInverting() {
+		return true;
+	}
+
 	@Override
-	int getDumpType() { return 153; }
+	int getDumpType() {
+		return 153;
+	}
     }
# diff -Naurw src.org/NTransistorElm.java src/NTransistorElm.java...
--- src.org/NTransistorElm.java	2015-12-05 20:47:00.000000000 +0100
+++ src/NTransistorElm.java	2016-03-16 13:13:06.549649860 +0100
@@ -1,6 +1,10 @@
-
     class NTransistorElm extends TransistorElm {
-	public NTransistorElm(int xx, int yy) { super(xx, yy, false); }
+	public NTransistorElm(int xx, int yy) {
+		super(xx, yy, false);
+	}
+
 	@Override
-	Class getDumpClass() { return TransistorElm.class; }
+	Class<TransistorElm> getDumpClass() {
+		return TransistorElm.class;
+	}
     }
# diff -Naurw src.org/OpAmpElm.java src/OpAmpElm.java...
--- src.org/OpAmpElm.java	2015-12-05 20:47:02.000000000 +0100
+++ src/OpAmpElm.java	2016-03-16 13:13:13.241529093 +0100
@@ -1,4 +1,3 @@
-
 import java.awt.Font;
 import java.awt.Graphics;
 import java.awt.Point;
@@ -12,6 +11,7 @@
 	final int FLAG_SWAP = 1;
 	final int FLAG_SMALL = 2;
 	final int FLAG_LOWGAIN = 4;
+
 	public OpAmpElm(int xx, int yy) {
 	    super(xx, yy);
 	    noDiagonal = true;
@@ -21,8 +21,8 @@
 	    setSize(sim.smallGridCheckItem.getState() ? 1 : 2);
 	    setGain();
 	}
-	public OpAmpElm(int xa, int ya, int xb, int yb, int f,
-			StringTokenizer st) {
+
+	public OpAmpElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	    super(xa, ya, xb, yb, f);
 	    maxOut = 15;
 	    minOut = -15;
@@ -39,18 +39,24 @@
 	    setSize((f & FLAG_SMALL) != 0 ? 1 : 2);
 	    setGain();
 	}
+
 	void setGain() {
 	    // gain of 100000 breaks e-amp-dfdx.txt
 	    // gain was 1000, but it broke amp-schmitt.txt
 	    gain = ((flags & FLAG_LOWGAIN) != 0) ? 1000 : 100000;
 	    
 	}
+
 	@Override
 	String dump() {
 	    return super.dump() + " " + maxOut + " " + minOut + " " + gbw;
 	}
+
 	@Override
-	boolean nonLinear() { return true; }
+	boolean nonLinear() {
+		return true;
+	}
+
 	@Override
 	void draw(Graphics g) {
 	    setBbox(point1, point2, opheight*2);
@@ -70,17 +76,23 @@
 	    drawDots(g, point2, lead2, curcount);
 	    drawPosts(g);
 	}
+
 	@Override
-	double getPower() { return volts[2]*current; }
+	double getPower() {
+		return volts[2] * current;
+	}
+
 	Point in1p[], in2p[], textp[];
 	Polygon triangle;
 	Font plusFont;
+
 	void setSize(int s) {
 	    opsize = s;
 	    opheight = 8*s;
 	    opwidth = 13*s;
 	    flags = (flags & ~FLAG_SMALL) | ((s == 1) ? FLAG_SMALL : 0);
 	}
+
 	@Override
 	void setPoints() {
 	    super.setPoints();
@@ -104,14 +116,22 @@
 	    triangle = createPolygon(tris[0], tris[1], lead2);
 	    plusFont = new Font("SansSerif", 0, opsize == 2 ? 14 : 10);
 	}
+
 	@Override
-	int getPostCount() { return 3; }
+	int getPostCount() {
+		return 3;
+	}
+
 	@Override
 	Point getPost(int n) {
 	    return (n == 0) ? in1p[0] : (n == 1) ? in2p[0] : point2;
 	}
+
 	@Override
-	int getVoltageSourceCount() { return 1; }
+	int getVoltageSourceCount() {
+		return 1;
+	}
+
 	@Override
 	void getInfo(String arr[]) {
 	    arr[0] = "op-amp";
@@ -122,8 +142,7 @@
 	    double vo = Math.max(Math.min(volts[2], maxOut), minOut);
 	    arr[3] = "Vout = " + getVoltageText(vo);
 	    arr[4] = "Iout = " + getCurrentText(getCurrent());
-	    arr[5] = "range = " + getVoltageText(minOut) + " to " +
-		getVoltageText(maxOut);
+		arr[5] = "range = " + getVoltageText(minOut) + " to " + getVoltageText(maxOut);
 	}
 
 	double lastvd;
@@ -134,6 +153,7 @@
 	    sim.stampNonLinear(vn);
 	    sim.stampMatrix(nodes[2], vn, 1);
 	}
+
 	@Override
 	void doStep() {
 	    double vd = volts[1] - volts[0];
@@ -152,7 +172,8 @@
 		x = minOut - dx*minOut/gain;
 	    } else
 		dx = gain;
-	    //System.out.println("opamp " + vd + " " + volts[2] + " " + dx + " "  + x + " " + lastvd + " " + sim.converged);
+		// System.out.println("opamp " + vd + " " + volts[2] + " " + dx + " " +
+		// x + " " + lastvd + " " + sim.converged);
 	    
 	    // newton-raphson
 	    sim.stampMatrix(vn, nodes[0], dx);
@@ -161,21 +182,34 @@
 	    sim.stampRightSide(vn, x);
 	    
 	    lastvd = vd;
-	    /*if (sim.converged)
-	      System.out.println((volts[1]-volts[0]) + " " + volts[2] + " " + initvd);*/
+		/*
+		 * if (sim.converged) System.out.println((volts[1]-volts[0]) + " " +
+		 * volts[2] + " " + initvd);
+		 */
 	}
+
 	// there is no current path through the op-amp inputs, but there
 	// is an indirect path through the output to ground.
 	@Override
-	boolean getConnection(int n1, int n2) { return false; }
+	boolean getConnection(int n1, int n2) {
+		return false;
+	}
+
 	@Override
 	boolean hasGroundConnection(int n1) {
 	    return (n1 == 2);
 	}
+
 	@Override
-	double getVoltageDiff() { return volts[2] - volts[1]; }
+	double getVoltageDiff() {
+		return volts[2] - volts[1];
+	}
+
 	@Override
-	int getDumpType() { return 'a'; }
+	int getDumpType() {
+		return 'a';
+	}
+
 	@Override
 	public EditInfo getEditInfo(int n) {
 	    if (n == 0)
@@ -184,6 +218,7 @@
 		return new EditInfo("Min Output (V)", minOut, -20, 0);
 	    return null;
 	}
+
 	@Override
 	public void setEditValue(int n, EditInfo ei) {
 	    if (n == 0)
# diff -Naurw src.org/OpAmpSwapElm.java src/OpAmpSwapElm.java...
--- src.org/OpAmpSwapElm.java	2015-12-05 20:46:58.000000000 +0100
+++ src/OpAmpSwapElm.java	2016-03-16 13:13:20.305401614 +0100
@@ -1,9 +1,11 @@
-
     class OpAmpSwapElm extends OpAmpElm {
 	public OpAmpSwapElm(int xx, int yy) {
 	    super(xx, yy);
 	    flags |= FLAG_SWAP;
 	}
+
 	@Override
-	Class getDumpClass() { return OpAmpElm.class; }
+	Class<OpAmpElm> getDumpClass() {
+		return OpAmpElm.class;
+	}
     }
# diff -Naurw src.org/OrGateElm.java src/OrGateElm.java...
--- src.org/OrGateElm.java	2015-12-05 20:47:00.000000000 +0100
+++ src/OrGateElm.java	2016-03-16 13:13:25.245312467 +0100
@@ -1,15 +1,20 @@
-
 import java.awt.Point;
 import java.util.StringTokenizer;
 
     class OrGateElm extends GateElm {
-	public OrGateElm(int xx, int yy) { super(xx, yy); }
-	public OrGateElm(int xa, int ya, int xb, int yb, int f,
-			  StringTokenizer st) {
+	public OrGateElm(int xx, int yy) {
+		super(xx, yy);
+	}
+
+	public OrGateElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	    super(xa, ya, xb, yb, f, st);
 	}
+
 	@Override
-	String getGateName() { return "OR gate"; }
+	String getGateName() {
+		return "OR gate";
+	}
+
 	@Override
 	void setPoints() {
 	    super.setPoints();
@@ -23,19 +28,15 @@
 	    for (i = 0; i != 16; i++) {
 		double a = i/16.;
 		double b = 1-a*a;
-		interpPoint2(lead1, lead2,
-			     triPoints[i], triPoints[32-i],
-			     .5+a/2, b*hs2);
+			interpPoint2(lead1, lead2, triPoints[i], triPoints[32 - i], .5 + a / 2, b * hs2);
 	    }
 	    double ww2 = (ww == 0) ? dn*2 : ww*2;
 	    for (i = 0; i != 5; i++) {
 		double a = (i-2)/2.;
 		double b = 4*(1-a*a)-2;
-		interpPoint(lead1, lead2,
-			    triPoints[33+i], b/(ww2), a*hs2);
+			interpPoint(lead1, lead2, triPoints[33 + i], b / (ww2), a * hs2);
 		if (this instanceof XorGateElm)
-		    linePoints[i] = interpPoint(lead1, lead2,
-						(b-5)/(ww2), a*hs2);
+				linePoints[i] = interpPoint(lead1, lead2, (b - 5) / (ww2), a * hs2);
 	    }
 	    triPoints[16] = new Point(lead2);
 	    if (isInverting()) {
@@ -44,6 +45,7 @@
 	    }
 	    gatePoly = createPolygon(triPoints);
 	}
+
 	@Override
 	boolean calcFunction() {
 	    int i;
@@ -52,6 +54,9 @@
 		f |= getInput(i);
 	    return f;
 	}
+
 	@Override
-	int getDumpType() { return 152; }
+	int getDumpType() {
+		return 152;
+	}
     }
# diff -Naurw src.org/OutputElm.java src/OutputElm.java...
--- src.org/OutputElm.java	2015-12-05 20:47:02.000000000 +0100
+++ src/OutputElm.java	2016-03-16 13:13:31.345202384 +0100
@@ -1,4 +1,3 @@
-
 import java.awt.Checkbox;
 import java.awt.Font;
 import java.awt.FontMetrics;
@@ -8,20 +7,31 @@
 
     class OutputElm extends CircuitElm {
 	final int FLAG_VALUE = 1;
-	public OutputElm(int xx, int yy) { super(xx, yy); }
-	public OutputElm(int xa, int ya, int xb, int yb, int f,
-			 StringTokenizer st) {
+
+	public OutputElm(int xx, int yy) {
+		super(xx, yy);
+	}
+
+	public OutputElm(int xa, int ya, int xb, int yb, int f, @SuppressWarnings("unused") StringTokenizer st) {
 	    super(xa, ya, xb, yb, f);
 	}
+
 	@Override
-	int getDumpType() { return 'O'; }
+	int getDumpType() {
+		return 'O';
+	}
+
 	@Override
-	int getPostCount() { return 1; }
+	int getPostCount() {
+		return 1;
+	}
+
 	@Override
 	void setPoints() {
 	    super.setPoints();
 	    lead1 = new Point();
 	}
+
 	@Override
 	void draw(Graphics g) {
 	    boolean selected = (needsHighlight() || sim.plotYElm == this);
@@ -43,28 +53,31 @@
 	    drawThickLine(g, point1, lead1);
 	    drawPosts(g);
 	}
+
 	@Override
-	double getVoltageDiff() { return volts[0]; }
+	double getVoltageDiff() {
+		return volts[0];
+	}
+
 	@Override
 	void getInfo(String arr[]) {
 	    arr[0] = "output";
 	    arr[1] = "V = " + getVoltageText(volts[0]);
 	}
+
 	@Override
 	public EditInfo getEditInfo(int n) {
 	    if (n == 0) {
 		EditInfo ei = new EditInfo("", 0, -1, -1);
-		ei.checkbox = new Checkbox("Show Voltage",
-					   (flags & FLAG_VALUE) != 0);
+			ei.checkbox = new Checkbox("Show Voltage", (flags & FLAG_VALUE) != 0);
 		return ei;
 	    }
 	    return null;
 	}
+
 	@Override
 	public void setEditValue(int n, EditInfo ei) {
 	    if (n == 0)
-		flags = (ei.checkbox.getState()) ?
-		    (flags | FLAG_VALUE) :
-		    (flags & ~FLAG_VALUE);
+			flags = (ei.checkbox.getState()) ? (flags | FLAG_VALUE) : (flags & ~FLAG_VALUE);
 	}
     }
# diff -Naurw src.org/PhaseCompElm.java src/PhaseCompElm.java...
--- src.org/PhaseCompElm.java	2015-12-05 20:46:58.000000000 +0100
+++ src/PhaseCompElm.java	2016-03-16 13:13:40.841031020 +0100
@@ -1,14 +1,19 @@
-
 import java.util.StringTokenizer;
 
 class PhaseCompElm extends ChipElm {
-    public PhaseCompElm(int xx, int yy) { super(xx, yy); }
-    public PhaseCompElm(int xa, int ya, int xb, int yb, int f,
-			StringTokenizer st) {
+	public PhaseCompElm(int xx, int yy) {
+		super(xx, yy);
+	}
+
+	public PhaseCompElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	super(xa, ya, xb, yb, f, st);
     }
+
     @Override
-	String getChipName() { return "phase comparator"; }
+	String getChipName() {
+		return "phase comparator";
+	}
+
     @Override
 	void setupPins() {
 	sizeX = 2;
@@ -19,8 +24,12 @@
 	pins[2] = new Pin(0, SIDE_E, "O");
 	pins[2].output = true;
     }
+
     @Override
-	boolean nonLinear() { return true; }
+	boolean nonLinear() {
+		return true;
+	}
+
     @Override
 	void stamp() {
 	int vn = sim.nodeList.size()+pins[2].voltSource;
@@ -28,7 +37,9 @@
 	sim.stampNonLinear(0);
 	sim.stampNonLinear(nodes[2]);
     }
+
     boolean ff1, ff2;
+
     @Override
 	void doStep() {
 	boolean v1 = volts[0] > 2.5;
@@ -51,11 +62,19 @@
 	pins[0].value = v1;
 	pins[1].value = v2;
     }
+
     @Override
-	int getPostCount() { return 3; }
-    @Override
-	int getVoltageSourceCount() { return 1; }
+	int getPostCount() {
+		return 3;
+	}
+
     @Override
-	int getDumpType() { return 161; }
+	int getVoltageSourceCount() {
+		return 1;
 }
     
+	@Override
+	int getDumpType() {
+		return 161;
+	}
+}
# diff -Naurw src.org/PhotoResistorElm.java src/PhotoResistorElm.java...
--- src.org/PhotoResistorElm.java	2015-12-05 20:47:02.000000000 +0100
+++ src/PhotoResistorElm.java	2016-03-16 13:13:46.344931693 +0100
@@ -1,5 +1,3 @@
-
-
 import java.awt.Graphics;
 import java.awt.Label;
 import java.awt.Point;
@@ -11,34 +9,45 @@
     double resistance;
     Scrollbar slider;
     Label label;
+
     public PhotoResistorElm(int xx, int yy) {
 	super(xx, yy);
 	maxresistance = 1e9;
 	minresistance = 1e3;
 	createSlider();
     }
-    public PhotoResistorElm(int xa, int ya, int xb, int yb, int f,
-		       StringTokenizer st) {
+
+	public PhotoResistorElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	super(xa, ya, xb, yb, f);
 	minresistance = new Double(st.nextToken()).doubleValue();
 	maxresistance = new Double(st.nextToken()).doubleValue();
 	createSlider();
     }
+
     @Override
-	boolean nonLinear() {return true;}
+	boolean nonLinear() {
+		return true;
+	}
+
     @Override
-	int getDumpType() { return 186; }
+	int getDumpType() {
+		return 186;
+	}
+
     @Override
 	String dump() {
 	return super.dump() + " " + minresistance + " " + maxresistance;
     }
+
     Point ps3, ps4;
+
     void createSlider() {
 	CirSim.main.add(label = new Label("Light Level", Label.CENTER));
 	int value = 50;
 	CirSim.main.add(slider = new Scrollbar(Scrollbar.HORIZONTAL, value, 1, 0, 101));
 	CirSim.main.validate();
     }
+
     @Override
 	void setPoints() {
 	super.setPoints();
@@ -46,6 +55,7 @@
 	ps3 = new Point();
 	ps4 = new Point();
     }
+
     @Override
 	void delete() {
 	CirSim.main.remove(label);
@@ -70,6 +80,7 @@
 	double vd = volts[0] - volts[1];
 	current = vd/resistance;
     }
+
     @Override
 	void startIteration() {
 	double vd = volts[0] - volts[1];
@@ -77,15 +88,18 @@
 	resistance = minresistance;
 	//System.out.print(this + " res current set to " + current + "\n");
     }
+
     @Override
 	void doStep() {
 	sim.stampResistor(nodes[0], nodes[1], resistance);
     }
+
     @Override
 	void stamp() {
 	sim.stampNonLinear(nodes[0]);
 	sim.stampNonLinear(nodes[1]);
     }
+
     @Override
 	void getInfo(String arr[]) {
 	// FIXME
@@ -95,6 +109,7 @@
 	arr[4] = "Ron = " + getUnitText(minresistance, CirSim.ohmString);
 	arr[5] = "Roff = " + getUnitText(maxresistance, CirSim.ohmString);
     }
+
     @Override
 	public EditInfo getEditInfo(int n) {
 	// ohmString doesn't work here on linux
@@ -104,6 +119,7 @@
 	    return new EditInfo("Max resistance (ohms)", maxresistance, 0, 0);
 	return null;
     }
+
     @Override
 	public void setEditValue(int n, EditInfo ei) {
 	if (ei.value > 0 && n == 0)
@@ -112,4 +128,3 @@
 	    maxresistance = ei.value;
     }
 }
-
# diff -Naurw src.org/PMosfetElm.java src/PMosfetElm.java...
--- src.org/PMosfetElm.java	2015-12-05 20:47:00.000000000 +0100
+++ src/PMosfetElm.java	2016-03-16 13:13:52.636818151 +0100
@@ -1,6 +1,10 @@
-
     class PMosfetElm extends MosfetElm {
-	public PMosfetElm(int xx, int yy) { super(xx, yy, true); }
+	public PMosfetElm(int xx, int yy) {
+		super(xx, yy, true);
+	}
+
 	@Override
-	Class getDumpClass() { return MosfetElm.class; }
+	Class<MosfetElm> getDumpClass() {
+		return MosfetElm.class;
+	}
     }
# diff -Naurw src.org/PotElm.java src/PotElm.java...
--- src.org/PotElm.java	2015-12-05 20:46:58.000000000 +0100
+++ src/PotElm.java	2016-03-16 13:13:59.108701355 +0100
@@ -1,4 +1,3 @@
-
 import java.awt.Graphics;
 import java.awt.Label;
 import java.awt.Point;
@@ -14,6 +13,7 @@
     Scrollbar slider;
     Label label;
     String sliderText;
+
     public PotElm(int xx, int yy) {
 	super(xx, yy);
 	setup();
@@ -22,8 +22,8 @@
 	sliderText = "Resistance";
 	createSlider();
     }
-    public PotElm(int xa, int ya, int xb, int yb, int f,
-		  StringTokenizer st) {
+
+	public PotElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	super(xa, ya, xb, yb, f);
 	maxResistance = new Double(st.nextToken()).doubleValue();
 	position = new Double(st.nextToken()).doubleValue();
@@ -32,19 +32,30 @@
 	    sliderText += ' ' + st.nextToken();
 	createSlider();
     }
+
     void setup() {
     }
+
     @Override
-	int getPostCount() { return 3; }
+	int getPostCount() {
+		return 3;
+	}
+
     @Override
-	int getDumpType() { return 174; }
+	int getDumpType() {
+		return 174;
+	}
+
     @Override
 	Point getPost(int n) {
 	return (n == 0) ? point1 : (n == 1) ? point2 : post3;
     }
+
     @Override
-	String dump() { return super.dump() + " " + maxResistance + " " +
-	    position + " " + sliderText; }
+	String dump() {
+		return super.dump() + " " + maxResistance + " " + position + " " + sliderText;
+	}
+
     void createSlider() {
 	CirSim.main.add(label = new Label(sliderText, Label.CENTER));
 	int value = (int) (position*100);
@@ -52,19 +63,23 @@
 	CirSim.main.validate();
 	slider.addAdjustmentListener(this);
     }
+
     @Override
 	public void adjustmentValueChanged(AdjustmentEvent e) {
 	sim.analyzeFlag = true;
 	setPoints();
     }
+
     @Override
 	void delete() {
 	CirSim.main.remove(label);
 	CirSim.main.remove(slider);
     }
+
     Point post3, corner2, arrowPoint, midpoint, arrow1, arrow2;
     Point ps3, ps4;
     int bodyLen;
+
     @Override
 	void setPoints() {
 	super.setPoints();
@@ -90,8 +105,7 @@
 	//int offset2 = offset - sign(offset)*4;
 	post3 =      interpPoint(point1, point2, .5, offset);
 	corner2 =    interpPoint(point1, point2, soff/dn+.5, offset);
-	arrowPoint = interpPoint(point1, point2, soff/dn+.5,
-				 8*sign(offset));
+		arrowPoint = interpPoint(point1, point2, soff / dn + .5, 8 * sign(offset));
 	midpoint = interpPoint(point1, point2, soff/dn+.5);
 	arrow1 = new Point();
 	arrow2 = new Point();
@@ -120,9 +134,15 @@
 	    for (i = 0; i != segments; i++) {
 		int nx = 0;
 		switch (i & 3) {
-		case 0: nx = 1; break;
-		case 2: nx = -1; break;
-		default: nx = 0; break;
+				case 0:
+					nx = 1;
+					break;
+				case 2:
+					nx = -1;
+					break;
+				default:
+					nx = 0;
+					break;
 		}
 		double v = v1+(v3-v1)*i/divide;
 		if (i >= divide)
@@ -163,17 +183,18 @@
 	    drawDots(g, point1, midpoint, curcount1);
 	    drawDots(g, point2, midpoint, curcount2);
 	    drawDots(g, post3, corner2, curcount3);
-	    drawDots(g, corner2, midpoint,
-		     curcount3+distance(post3, corner2));
+			drawDots(g, corner2, midpoint, curcount3 + distance(post3, corner2));
 	}
 	drawPosts(g);
     }
+
     @Override
 	void calculateCurrent() {
 	current1 = (volts[0]-volts[2])/resistance1;
 	current2 = (volts[1]-volts[2])/resistance2;
 	current3 = -current1-current2;
     }
+
     @Override
 	void stamp() {
 	resistance1 = maxResistance*position;
@@ -181,6 +202,7 @@
 	sim.stampResistor(nodes[0], nodes[2], resistance1);
 	sim.stampResistor(nodes[2], nodes[1], resistance2);
     }
+
     @Override
 	void getInfo(String arr[]) {
 	arr[0] = "potentiometer";
@@ -190,6 +212,7 @@
 	arr[4] = "I1 = " + getCurrentDText(current1);
 	arr[5] = "I2 = " + getCurrentDText(current2);
     }
+
     @Override
 	public EditInfo getEditInfo(int n) {
 	// ohmString doesn't work here on linux
@@ -202,6 +225,7 @@
 	}
 	return null;
     }
+
     @Override
 	public void setEditValue(int n, EditInfo ei) {
 	if (n == 0)
@@ -212,4 +236,3 @@
 	}
     }
 }
-
# diff -Naurw src.org/ProbeElm.java src/ProbeElm.java...
--- src.org/ProbeElm.java	2015-12-05 20:47:00.000000000 +0100
+++ src/ProbeElm.java	2016-03-16 13:14:04.920596472 +0100
@@ -1,4 +1,3 @@
-
 import java.awt.Checkbox;
 import java.awt.Font;
 import java.awt.Graphics;
@@ -7,15 +6,22 @@
 
 class ProbeElm extends CircuitElm {
     static final int FLAG_SHOWVOLTAGE = 1;
-    public ProbeElm(int xx, int yy) { super(xx, yy); }
-    public ProbeElm(int xa, int ya, int xb, int yb, int f,
-		    StringTokenizer st) {
+
+	public ProbeElm(int xx, int yy) {
+		super(xx, yy);
+	}
+
+	public ProbeElm(int xa, int ya, int xb, int yb, int f, @SuppressWarnings("unused") StringTokenizer st) {
 	super(xa, ya, xb, yb, f);
     }
+
     @Override
-	int getDumpType() { return 'p'; }
+	int getDumpType() {
+		return 'p';
+	}
 	
     Point center;
+
     @Override
 	void setPoints() {
 	super.setPoints();
@@ -27,6 +33,7 @@
 	}
 	center = interpPoint(point1, point2, .5);
     }
+
     @Override
 	void draw(Graphics g) {
 	int hs = 8;
@@ -64,8 +71,11 @@
 	arr[0] = "scope probe";
 	arr[1] = "Vd = " + getVoltageText(getVoltageDiff());
     }
+
     @Override
-	boolean getConnection(int n1, int n2) { return false; }
+	boolean getConnection(int n1, int n2) {
+		return false;
+	}
 
 	@Override
 	public EditInfo getEditInfo(int n) {
@@ -76,6 +86,7 @@
 	    }
 	    return null;
 	}
+
 	@Override
 	public void setEditValue(int n, EditInfo ei) {
 	    if (n == 0) {
@@ -86,4 +97,3 @@
 	    }
 	}
 }
-
# diff -Naurw src.org/PTransistorElm.java src/PTransistorElm.java...
--- src.org/PTransistorElm.java	2015-12-05 20:47:00.000000000 +0100
+++ src/PTransistorElm.java	2016-03-16 13:14:10.892488705 +0100
@@ -1,6 +1,10 @@
-
     class PTransistorElm extends TransistorElm {
-	public PTransistorElm(int xx, int yy) { super(xx, yy, true); }
+	public PTransistorElm(int xx, int yy) {
+		super(xx, yy, true);
+	}
+
 	@Override
-	Class getDumpClass() { return TransistorElm.class; }
+	Class<TransistorElm> getDumpClass() {
+		return TransistorElm.class;
+	}
     }
# diff -Naurw src.org/PushSwitchElm.java src/PushSwitchElm.java...
--- src.org/PushSwitchElm.java	2015-12-05 20:47:02.000000000 +0100
+++ src/PushSwitchElm.java	2016-03-16 13:14:15.808399987 +0100
@@ -1,6 +1,10 @@
-
     class PushSwitchElm extends SwitchElm {
-	public PushSwitchElm(int xx, int yy) { super(xx, yy, true); }
+	public PushSwitchElm(int xx, int yy) {
+		super(xx, yy, true);
+	}
+
 	@Override
-	Class getDumpClass() { return SwitchElm.class; }
+	Class<SwitchElm> getDumpClass() {
+		return SwitchElm.class;
+	}
     }
# diff -Naurw src.org/RailElm.java src/RailElm.java...
--- src.org/RailElm.java	2015-12-05 20:47:00.000000000 +0100
+++ src/RailElm.java	2016-03-16 13:14:31.628114508 +0100
@@ -1,26 +1,38 @@
-
 import java.awt.Font;
 import java.awt.Graphics;
 import java.util.StringTokenizer;
 
 class RailElm extends VoltageElm {
-    public RailElm(int xx, int yy) { super(xx, yy, WF_DC); }
-    RailElm(int xx, int yy, int wf) { super(xx, yy, wf); }
-    public RailElm(int xa, int ya, int xb, int yb, int f,
-		   StringTokenizer st) {
+	public RailElm(int xx, int yy) {
+		super(xx, yy, WF_DC);
+	}
+
+	RailElm(int xx, int yy, int wf) {
+		super(xx, yy, wf);
+	}
+
+	public RailElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	super(xa, ya, xb, yb, f, st);
     }
+
     final int FLAG_CLOCK = 1;
+
     @Override
-	int getDumpType() { return 'R'; }
+	int getDumpType() {
+		return 'R';
+	}
+
     @Override
-	int getPostCount() { return 1; }
+	int getPostCount() {
+		return 1;
+	}
 	
     @Override
 	void setPoints() {
 	super.setPoints();
 	lead1 = interpPoint(point1, point2, 1-circleSize/dn);
     }
+
     @Override
 	void draw(Graphics g) {
 	setBbox(point1, point2, circleSize);
@@ -51,8 +63,12 @@
 	if (sim.dragElm != this)
 	    drawDots(g, point1, lead1, curcount);
     }
+
     @Override
-	double getVoltageDiff() { return volts[0]; }
+	double getVoltageDiff() {
+		return volts[0];
+	}
+
     @Override
 	void stamp() {
 	if (waveform == WF_DC)
@@ -60,11 +76,15 @@
 	else
 	    sim.stampVoltageSource(0, nodes[0], voltSource);
     }
+
     @Override
 	void doStep() {
 	if (waveform != WF_DC)
 	    sim.updateVoltageSource(0, nodes[0], voltSource, getVoltage());
     }
+
     @Override
-	boolean hasGroundConnection(int n1) { return true; }
+	boolean hasGroundConnection(int n1) {
+		return true;
+	}
 }
# diff -Naurw src.org/RelayElm.java src/RelayElm.java...
--- src.org/RelayElm.java	2015-12-05 20:47:02.000000000 +0100
+++ src/RelayElm.java	2016-03-16 13:14:39.363974907 +0100
@@ -1,4 +1,3 @@
-
 import java.awt.Checkbox;
 import java.awt.Color;
 import java.awt.Graphics;
@@ -44,8 +43,8 @@
 	poleCount = 1;
 	setupPoles();
     }
-    public RelayElm(int xa, int ya, int xb, int yb, int f,
-		    StringTokenizer st) {
+
+	public RelayElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	super(xa, ya, xb, yb, f);
 	poleCount = new Integer(st.nextToken()).intValue();
 	inductance = new Double(st.nextToken()).doubleValue();
@@ -71,13 +70,14 @@
     }
     
     @Override
-	int getDumpType() { return 178; }
+	int getDumpType() {
+		return 178;
+	}
     
     @Override
 	String dump() {
-	return super.dump() + " " + poleCount + " " +
-	    inductance + " " + coilCurrent + " " +
-	    r_on + " " + r_off + " " + onCurrent + " " + coilR;
+		return super.dump() + " " + poleCount + " " + inductance + " " + coilCurrent + " " + r_on + " " + r_off + " "
+				+ onCurrent + " " + coilR;
     }
     
     @Override
@@ -88,20 +88,17 @@
 	    drawThickLine(g, coilLeads[i], coilPosts[i]);
 	}
 	int x = ((flags & FLAG_SWAP_COIL) != 0) ? 1 : 0;
-	drawCoil(g, dsign*6, coilLeads[x], coilLeads[1-x],
-		 volts[nCoil1+x], volts[nCoil2-x]);
+		drawCoil(g, dsign * 6, coilLeads[x], coilLeads[1 - x], volts[nCoil1 + x], volts[nCoil2 - x]);
 
 	// draw lines
 	g.setColor(Color.darkGray);
 	for (i = 0; i != poleCount; i++) {
 	    if (i == 0)
-		interpPoint(point1, point2, lines[i*2  ], .5,
-			    openhs*2+5*dsign-i*openhs*3);
+				interpPoint(point1, point2, lines[i * 2], .5, openhs * 2 + 5 * dsign - i * openhs * 3);
 	    else
 		interpPoint(point1, point2, lines[i*2], .5,
 			    (int) (openhs*(-i*3+3-.5+d_position))+5*dsign);
-	    interpPoint(point1, point2, lines[i*2+1], .5,
-			(int) (openhs*(-i*3-.5+d_position))-5*dsign);
+			interpPoint(point1, point2, lines[i * 2 + 1], .5, (int) (openhs * (-i * 3 - .5 + d_position)) - 5 * dsign);
 	    g.drawLine(lines[i*2].x, lines[i*2].y, lines[i*2+1].x, lines[i*2+1].y);
 	}
 	
@@ -117,13 +114,11 @@
 	    //setVoltageColor(g, volts[nSwitch0]);
 	    g.setColor(Color.lightGray);
 	    drawThickLine(g, swpoles[p][0], ptSwitch[p]);
-	    switchCurCount[p] = updateDotCount(switchCurrent[p],
-					       switchCurCount[p]);
+			switchCurCount[p] = updateDotCount(switchCurrent[p], switchCurCount[p]);
 	    drawDots(g, swposts[p][0], swpoles[p][0], switchCurCount[p]);
 	    
 	    if (i_position != 2)
-		drawDots(g, swpoles[p][i_position+1], swposts[p][i_position+1],
-			 switchCurCount[p]);
+				drawDots(g, swpoles[p][i_position + 1], swposts[p][i_position + 1], switchCurCount[p]);
 	}
 	
 	coilCurCount = updateDotCount(coilCurrent, coilCurCount);
@@ -176,16 +171,24 @@
 	// lines
 	lines = newPointArray(poleCount*2);
     }
+
     @Override
 	Point getPost(int n) {
 	if (n < 3*poleCount)
 	    return swposts[n / 3][n % 3];
 	return coilPosts[n-3*poleCount];
     }
+
     @Override
-	int getPostCount() { return 2+poleCount*3; }
+	int getPostCount() {
+		return 2 + poleCount * 3;
+	}
+
     @Override
-	int getInternalNodeCount() { return 1; }
+	int getInternalNodeCount() {
+		return 1;
+	}
+
     @Override
 	void reset() {
 	super.reset();
@@ -195,7 +198,9 @@
 	for (i = 0; i != poleCount; i++)
 	    switchCurrent[i] = switchCurCount[i] = 0;
     }
+
     double a1, a2, a3, a4;
+
     @Override
 	void stamp() {
 	// inductor from coil post 1 to internal node
@@ -207,11 +212,13 @@
 	for (i = 0; i != poleCount*3; i++)
 	    sim.stampNonLinear(nodes[nSwitch0+i]);
     }
+
     @Override
 	void startIteration() {
 	ind.startIteration(volts[nCoil1]-volts[nCoil3]);
 
-	// magic value to balance operate speed with reset speed semi-realistically
+		// magic value to balance operate speed with reset speed
+		// semi-realistically
 	double magic = 1.3;
 	double pmult = Math.sqrt(magic+1);
 	double p = coilCurrent*pmult/onCurrent;
@@ -231,7 +238,9 @@
     	
     // we need this to be able to change the matrix for each step
     @Override
-	boolean nonLinear() { return true; }
+	boolean nonLinear() {
+		return true;
+	}
 
     @Override
 	void doStep() {
@@ -239,12 +248,11 @@
 	ind.doStep(voltdiff);
 	int p;
 	for (p = 0; p != poleCount*3; p += 3) {
-	    sim.stampResistor(nodes[nSwitch0+p], nodes[nSwitch1+p],
-			      i_position == 0 ? r_on : r_off);
-	    sim.stampResistor(nodes[nSwitch0+p], nodes[nSwitch2+p],
-			      i_position == 1 ? r_on : r_off);
+			sim.stampResistor(nodes[nSwitch0 + p], nodes[nSwitch1 + p], i_position == 0 ? r_on : r_off);
+			sim.stampResistor(nodes[nSwitch0 + p], nodes[nSwitch2 + p], i_position == 1 ? r_on : r_off);
 	}
     }
+
     @Override
 	void calculateCurrent() {
 	double voltdiff = volts[nCoil1]-volts[nCoil3];
@@ -257,22 +265,21 @@
 	    if (i_position == 2)
 		switchCurrent[p] = 0;
 	    else
-		switchCurrent[p] =
-		    (volts[nSwitch0+p*3]-volts[nSwitch1+p*3+i_position])/r_on;
+				switchCurrent[p] = (volts[nSwitch0 + p * 3] - volts[nSwitch1 + p * 3 + i_position]) / r_on;
 	}
     }
+
     @Override
 	void getInfo(String arr[]) {
-	arr[0] = i_position == 0 ? "relay (off)" :
-	    i_position == 1 ? "relay (on)" : "relay";
+		arr[0] = i_position == 0 ? "relay (off)" : i_position == 1 ? "relay (on)" : "relay";
 	int i;
 	int ln = 1;
 	for (i = 0; i != poleCount; i++)
 	    arr[ln++] = "I" + (i+1) + " = " + getCurrentDText(switchCurrent[i]);
 	arr[ln++] = "coil I = " + getCurrentDText(coilCurrent);
-	arr[ln++] = "coil Vd = " +
-	    getVoltageDText(volts[nCoil1] - volts[nCoil2]);
+		arr[ln++] = "coil Vd = " + getVoltageDText(volts[nCoil1] - volts[nCoil2]);
     }
+
     @Override
 	public EditInfo getEditInfo(int n) {
 	if (n == 0)
@@ -284,18 +291,17 @@
 	if (n == 3)
 	    return new EditInfo("On Current (A)", onCurrent, 0, 0);
 	if (n == 4)
-	    return new EditInfo("Number of Poles", poleCount, 1, 4).
-		setDimensionless();
+			return new EditInfo("Number of Poles", poleCount, 1, 4).setDimensionless();
 	if (n == 5)
 	    return new EditInfo("Coil Resistance (ohms)", coilR, 0, 0);
 	if (n == 6) {
 	    EditInfo ei = new EditInfo("", 0, -1, -1);
-	    ei.checkbox = new Checkbox("Swap Coil Direction",
-				       (flags & FLAG_SWAP_COIL) != 0);
+			ei.checkbox = new Checkbox("Swap Coil Direction", (flags & FLAG_SWAP_COIL) != 0);
 	    return ei;
 	}
 	return null;
     }
+
     @Override
 	public void setEditValue(int n, EditInfo ei) {
 	if (n == 0 && ei.value > 0) {
@@ -322,9 +328,9 @@
 	    setPoints();
 	}
     }
+
     @Override
 	boolean getConnection(int n1, int n2) {
 	return (n1 / 3 == n2 / 3);
     }
 }
-    
# diff -Naurw src.org/ResistorElm.java src/ResistorElm.java...
--- src.org/ResistorElm.java	2015-12-05 20:47:00.000000000 +0100
+++ src/ResistorElm.java	2016-03-16 13:14:45.783859055 +0100
@@ -1,24 +1,32 @@
-
 import java.awt.Graphics;
 import java.awt.Point;
 import java.util.StringTokenizer;
 
     class ResistorElm extends CircuitElm {
 	double resistance;
-	public ResistorElm(int xx, int yy) { super(xx, yy); resistance = 100; }
-	public ResistorElm(int xa, int ya, int xb, int yb, int f,
-		    StringTokenizer st) {
+
+	public ResistorElm(int xx, int yy) {
+		super(xx, yy);
+		resistance = 100;
+	}
+
+	public ResistorElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	    super(xa, ya, xb, yb, f);
 	    resistance = new Double(st.nextToken()).doubleValue();
 	}
+
 	@Override
-	int getDumpType() { return 'r'; }
+	int getDumpType() {
+		return 'r';
+	}
+
 	@Override
 	String dump() {
 	    return super.dump() + " " + resistance;
 	}
 
 	Point ps3, ps4;
+
 	@Override
 	void setPoints() {
 	    super.setPoints();
@@ -44,9 +52,15 @@
 		for (i = 0; i != segments; i++) {
 		    int nx = 0;
 		    switch (i & 3) {
-		    case 0: nx = 1; break;
-		    case 2: nx = -1; break;
-		    default: nx = 0; break;
+				case 0:
+					nx = 1;
+					break;
+				case 2:
+					nx = -1;
+					break;
+				default:
+					nx = 0;
+					break;
 		    }
 		    double v = v1+(v2-v1)*i/segments;
 		    setVoltageColor(g, v);
@@ -84,10 +98,12 @@
 	    current = (volts[0]-volts[1])/resistance;
 	    //System.out.print(this + " res current set to " + current + "\n");
 	}
+
 	@Override
 	void stamp() {
 	    sim.stampResistor(nodes[0], nodes[1], resistance);
 	}
+
 	@Override
 	void getInfo(String arr[]) {
 	    arr[0] = "resistor";
@@ -95,6 +111,7 @@
 	    arr[3] = "R = " + getUnitText(resistance, CirSim.ohmString);
 	    arr[4] = "P = " + getUnitText(getPower(), "W");
 	}
+
 	@Override
 	public EditInfo getEditInfo(int n) {
 	    // ohmString doesn't work here on linux
@@ -102,11 +119,15 @@
 		return new EditInfo("Resistance (ohms)", resistance, 0, 0);
 	    return null;
 	}
+
 	@Override
 	public void setEditValue(int n, EditInfo ei) {
 	    if (ei.value > 0)
 	        resistance = ei.value;
 	}
+
 	@Override
-	boolean needsShortcut() { return true; }
+	boolean needsShortcut() {
+		return true;
+	}
     }
# diff -Naurw src.org/RowInfo.java src/RowInfo.java...
--- src.org/RowInfo.java	2015-12-05 20:47:02.000000000 +0100
+++ src/RowInfo.java	2016-03-16 13:14:55.947675641 +0100
@@ -1,4 +1,3 @@
-
     // info about each row/column of the matrix for simplification purposes
     class RowInfo {
 	static final int ROW_NORMAL = 0;  // ordinary value
@@ -9,5 +8,8 @@
 	boolean rsChanges; // row's right side changes
 	boolean lsChanges; // row's left side changes
 	boolean dropRow;   // row is not needed in matrix
-	RowInfo() { type = ROW_NORMAL; }
+
+	RowInfo() {
+		type = ROW_NORMAL;
+	}
     }
# diff -Naurw src.org/SaveOpenDialog.java src/SaveOpenDialog.java...
--- src.org/SaveOpenDialog.java	2015-12-06 04:59:04.000000000 +0100
+++ src/SaveOpenDialog.java	2016-03-16 13:15:24.215165537 +0100
@@ -1,5 +1,6 @@
+
 /*
- * Code by Federico García García.
+ * Code by Federico GarcÃ­a GarcÃ­a.
  * 27/11/2015.
  * 
  * Class that allows to save and open files in .cmf (CircuitMod File) extension.
@@ -7,19 +8,16 @@
  */
 
 import java.awt.Frame;
-import java.awt.Image;
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.PrintWriter;
-import java.util.List;
 
 import javax.swing.JFileChooser;
 import javax.swing.JOptionPane;
 import javax.swing.UIManager;
-import javax.swing.UnsupportedLookAndFeelException;
 import javax.swing.filechooser.FileFilter;
 import javax.swing.filechooser.FileNameExtensionFilter;
 
@@ -28,7 +26,7 @@
 	
 	// File extension
 	private final String FILE_EXTENSION = "cmf";
-	private final FileFilter FILE_FILTER = new FileNameExtensionFilter("CircuitMod | *."+FILE_EXTENSION, FILE_EXTENSION);
+	private final FileFilter FILE_FILTER = new FileNameExtensionFilter("*." + FILE_EXTENSION, FILE_EXTENSION);
 
 	private String currentFilePath = null; // Path of current file.
 	private String currentFileName = null; // Name of current file.
@@ -45,13 +43,19 @@
 		
 		// Create file chooser with custom file filter
 		fc = new JFileChooser(){
+			/**
+			 *
+			 */
+			private static final long serialVersionUID = 1L;
+
 		    @Override
 		    public void approveSelection(){
 		    	String s = getExtension(getSelectedFile().getAbsolutePath());
 		    	File f = new File(s);
 		        
 		        if(f.exists() && getDialogType() == SAVE_DIALOG){
-		            int result = JOptionPane.showConfirmDialog(this,"The file exists, overwrite?","Existing file",JOptionPane.YES_NO_CANCEL_OPTION);
+					int result = JOptionPane.showConfirmDialog(this, "The file exists, overwrite?", "Existing file",
+							JOptionPane.YES_NO_CANCEL_OPTION);
 		            switch(result){
 		                case JOptionPane.YES_OPTION:
 		                    super.approveSelection();
@@ -93,11 +97,9 @@
 		if(currentFilePath == null) {
 			return saveAs(s);
 		}
-		else {
 			saveFile(s);
 			return true;
 		}
-	}
 	
 	// Save file
 	void saveFile(String s) {
@@ -113,7 +115,7 @@
 	}
 	
 	// Open file
-	String open(String s) {
+	String open(@SuppressWarnings("unused") String s) {
 		int accept = fc.showOpenDialog(parent);
 		
 		if(accept == JFileChooser.APPROVE_OPTION) {
@@ -134,7 +136,9 @@
 			
 			return readFile(s);
 		} catch (IOException e) {
-			e.printStackTrace();
+			// e.printStackTrace();
+			System.err.println("failed to load file: " + e.getMessage());
+			System.exit(1);
 		}
 		
 		return null;
# diff -Naurw src.org/Scope.java src/Scope.java...
--- src.org/Scope.java	2015-12-05 20:47:00.000000000 +0100
+++ src/Scope.java	2016-03-16 12:18:19.152882419 +0100
@@ -1,4 +1,3 @@
-
 import java.awt.Graphics;
 import java.awt.Image;
 import java.awt.PopupMenu;
@@ -35,17 +34,39 @@
     int draw_ox, draw_oy;
     float dpixels[];
     CirSim sim;
+
     Scope(CirSim s) {
 	rect = new Rectangle();
 	reset();
 	sim = s;
     }
-    void showCurrent(boolean b) { showI = b; value = ivalue = 0; }
-    void showVoltage(boolean b) { showV = b; value = ivalue = 0; }
-    void showMax    (boolean b) { showMax = b; }
-    void showMin    (boolean b) { showMin = b; }
-    void showFreq   (boolean b) { showFreq = b; }
-    void setLockScale  (boolean b) { lockScale = b; }
+
+	void showCurrent(boolean b) {
+		showI = b;
+		value = ivalue = 0;
+	}
+
+	void showVoltage(boolean b) {
+		showV = b;
+		value = ivalue = 0;
+	}
+
+	void showMax(boolean b) {
+		showMax = b;
+	}
+
+	void showMin(boolean b) {
+		showMin = b;
+	}
+
+	void showFreq(boolean b) {
+		showFreq = b;
+	}
+
+	void setLockScale(boolean b) {
+		lockScale = b;
+	}
+
     void resetGraph() {
 	scopePointCount = 1;
 	while (scopePointCount <= rect.width)
@@ -57,7 +78,11 @@
 	ptr = ctr = 0;
 	allocImage();
     }
-    boolean active() { return elm != null; }
+
+	boolean active() {
+		return elm != null;
+	}
+
     void reset() {
 	resetGraph();
 	minMaxV = 5;
@@ -67,20 +92,25 @@
 	showFreq = lockScale = showMin = false;
 	plot2d = false;
 	// no showI for Output
-	if (elm != null && (elm instanceof OutputElm ||
-			    elm instanceof LogicOutputElm ||
-			    elm instanceof ProbeElm))
+		if (elm != null && (elm instanceof OutputElm || elm instanceof LogicOutputElm || elm instanceof ProbeElm))
 	    showI = false;
 	value = ivalue = 0;
 	if (elm instanceof TransistorElm)
 	    value = VAL_VCE;
     }
+
     void setRect(Rectangle r) {
 	rect = r;
 	resetGraph();
     }
-    int getWidth() { return rect.width; }
-    int rightEdge() { return rect.x+rect.width; }
+
+	int getWidth() {
+		return rect.width;
+	}
+
+	int rightEdge() {
+		return rect.x + rect.width;
+	}
 	
     void setElm(CircuitElm ce) {
 	elm = ce;
@@ -425,9 +455,7 @@
 	x += rect.x;
 	if (showMax) {
 	    if (value != 0)
-		g.drawString(CircuitElm.getUnitText(realMaxV,
-					 elm.getScopeUnits(value)),
-			     x, yt);
+				g.drawString(CircuitElm.getUnitText(realMaxV, elm.getScopeUnits(value)), x, yt);
 	    else if (showV)
 		g.drawString(CircuitElm.getVoltageText(realMaxV), x, yt);
 	    else if (showI)
@@ -437,9 +465,7 @@
 	if (showMin) {
 	    int ym = rect.y+rect.height-5;
 	    if (value != 0)
-		g.drawString(CircuitElm.getUnitText(realMinV,
-					 elm.getScopeUnits(value)),
-			     x, ym);
+				g.drawString(CircuitElm.getUnitText(realMinV, elm.getScopeUnits(value)), x, ym);
 	    else if (showV)
 		g.drawString(CircuitElm.getVoltageText(realMinV), x, ym);
 	    else if (showI)
@@ -465,6 +491,7 @@
 	    resetGraph();
 	}
     }
+
     void slowDown() {
 	speed *= 2;
 	resetGraph();
@@ -482,7 +509,7 @@
 	    sim.scopeVceMenuItem.setState(value == VAL_VCE && ivalue != VAL_IC);
 	    sim.scopeVceIcMenuItem.setState(value == VAL_VCE && ivalue == VAL_IC);
 	    return sim.transScopeMenu;
-	} else {
+		}
 	    sim.scopeVMenuItem    .setState(showV && value == 0);
 	    sim.scopeIMenuItem    .setState(showI && value == 0);
 	    sim.scopeMaxMenuItem  .setState(showMax);
@@ -496,28 +523,35 @@
 	    sim.scopeResistMenuItem.setEnabled(elm instanceof MemristorElm);
 	    return sim.scopeMenu;
 	}
+
+	void setValue(int x) {
+		reset();
+		value = x;
     }
-    void setValue(int x) { reset(); value = x; }
+
     String dump() {
 	if (elm == null)
 	    return null;
-	int flags = (showI ? 1 : 0) | (showV ? 2 : 0) |
-	    (showMax ? 0 : 4) |   // showMax used to be always on
-	    (showFreq ? 8 : 0) |
-	    (lockScale ? 16 : 0) | (plot2d ? 64 : 0) |
-	    (plotXY ? 128 : 0) | (showMin ? 256 : 0);
+		int flags = (showI ? 1 : 0) | (showV ? 2 : 0) | (showMax ? 0 : 4) | // showMax
+																			// used
+																			// to
+																			// be
+																			// always
+																			// on
+				(showFreq ? 8 : 0) | (lockScale ? 16 : 0) | (plot2d ? 64 : 0) | (plotXY ? 128 : 0)
+				| (showMin ? 256 : 0);
 	flags |= FLAG_YELM; // yelm present
 	int eno = sim.locateElm(elm);
 	if (eno < 0)
 	    return null;
 	int yno = yElm == null ? -1 : sim.locateElm(yElm);
-	String x = "o " + eno + " " +
-	    speed + " " + value + " " + flags + " " +
-	    minMaxV + " " + minMaxI + " " + position + " " + yno;
+		String x = "o " + eno + " " + speed + " " + value + " " + flags + " " + minMaxV + " " + minMaxI + " " + position
+				+ " " + yno;
 	if (text != null)
 	    x += " " + text;
 	return x;
     }
+
     void undump(StringTokenizer st) {
 	reset();
 	int e = new Integer(st.nextToken()).intValue();
@@ -560,6 +594,7 @@
 	plotXY = (flags & 128) != 0;
 	showMin = (flags & 256) != 0;
     }
+
     void allocImage() {
 	pixels = null;
 	int w = rect.width;
@@ -568,30 +603,26 @@
 	    return;
 	if (sim.useBufferedImage) {
 	    try {
-		/* simulate the following code using reflection:
-		   dbimage = new BufferedImage(d.width, d.height,
-		   BufferedImage.TYPE_INT_RGB);
-		   DataBuffer db = (DataBuffer)(((BufferedImage)dbimage).
-		   getRaster().getDataBuffer());
-		   DataBufferInt dbi = (DataBufferInt) db;
-		   pixels = dbi.getData();
+				/*
+				 * simulate the following code using reflection: dbimage = new
+				 * BufferedImage(d.width, d.height, BufferedImage.TYPE_INT_RGB);
+				 * DataBuffer db = (DataBuffer)(((BufferedImage)dbimage).
+				 * getRaster().getDataBuffer()); DataBufferInt dbi =
+				 * (DataBufferInt) db; pixels = dbi.getData();
 		*/
-		Class biclass = Class.forName("java.awt.image.BufferedImage");
-		Class dbiclass = Class.forName("java.awt.image.DataBufferInt");
-		Class rasclass = Class.forName("java.awt.image.Raster");
-		Constructor cstr = biclass.getConstructor(
-		    new Class[] { int.class, int.class, int.class });
-		image = (Image) cstr.newInstance(new Object[] {
-						     new Integer(w), new Integer(h),
-						     new Integer(BufferedImage.TYPE_INT_RGB)});
+				Class<?> biclass = Class.forName("java.awt.image.BufferedImage");
+				Class<?> dbiclass = Class.forName("java.awt.image.DataBufferInt");
+				Class<?> rasclass = Class.forName("java.awt.image.Raster");
+				Constructor<?> cstr = biclass.getConstructor(new Class[] { int.class, int.class, int.class });
+				image = (Image) cstr.newInstance(
+						new Object[] { new Integer(w), new Integer(h), new Integer(BufferedImage.TYPE_INT_RGB) });
 		Method m = biclass.getMethod("getRaster");
 		Object ras = m.invoke(image);
 		Object db = rasclass.getMethod("getDataBuffer").invoke(ras);
-		pixels = (int[])
-		    dbiclass.getMethod("getData").invoke(db);
+				pixels = (int[]) dbiclass.getMethod("getData").invoke(db);
 	    } catch (Exception ee) {
-		// ee.printStackTrace();
-		System.out.println("BufferedImage failed");
+				ee.printStackTrace();
+				// System.out.println("BufferedImage failed");
 	    }
 	}
 	if (pixels == null) {
@@ -608,7 +639,7 @@
 	draw_ox = draw_oy = -1;
     }
 
-    void handleMenu(ItemEvent e, Object mi) {
+	void handleMenu(@SuppressWarnings("unused") ItemEvent e, Object mi) {
 	if (mi == sim.scopeVMenuItem)
 	    showVoltage(sim.scopeVMenuItem.getState());
 	if (mi == sim.scopeIMenuItem)
@@ -670,8 +701,7 @@
 	while (true) {
 	    for (e++; e < sim.elmList.size(); e++) {
 		CircuitElm ce = sim.getElm(e);
-		if ((ce instanceof OutputElm || ce instanceof ProbeElm) &&
-		    ce != elm) {
+				if ((ce instanceof OutputElm || ce instanceof ProbeElm) && ce != elm) {
 		    yElm = ce;
 		    return;
 		}
# diff -Naurw src.org/SCRElm.java src/SCRElm.java...
--- src.org/SCRElm.java	2015-12-05 20:46:58.000000000 +0100
+++ src/SCRElm.java	2016-03-16 13:15:43.422818927 +0100
@@ -1,4 +1,3 @@
-
 import java.awt.Graphics;
 import java.awt.Point;
 import java.awt.Polygon;
@@ -17,13 +16,14 @@
     final int gnode = 2;
     final int inode = 3;
     Diode diode;
+
     public SCRElm(int xx, int yy) {
 	super(xx, yy);
 	setDefaults();
 	setup();
     }
-    public SCRElm(int xa, int ya, int xb, int yb, int f,
-		  StringTokenizer st) {
+
+	public SCRElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	super(xa, ya, xb, yb, f);
 	setDefaults();
 	try {
@@ -39,31 +39,41 @@
 	}
 	setup();
     }
+
     void setDefaults() {
 	cresistance = 50;
 	holdingI = .0082;
 	triggerI = .01;
     }
+
     void setup() {
 	diode = new Diode(sim);
 	diode.setup(.8, 0);
     }
+
     @Override
-	boolean nonLinear() { return true; }
+	boolean nonLinear() {
+		return true;
+	}
+
     @Override
 	void reset() {
 	volts[anode] = volts[cnode] = volts[gnode] = 0;
 	diode.reset();
 	lastvag = lastvac = curcount_a = curcount_c = curcount_g = 0;
     }
+
     @Override
-	int getDumpType() { return 177; }
+	int getDumpType() {
+		return 177;
+	}
+
     @Override
 	String dump() {
-	return super.dump() + " " + (volts[anode]-volts[cnode]) + " " +
-	    (volts[anode]-volts[gnode]) + " " + triggerI + " "+  holdingI + " " +
-	    cresistance;
+		return super.dump() + " " + (volts[anode] - volts[cnode]) + " " + (volts[anode] - volts[gnode]) + " " + triggerI
+				+ " " + holdingI + " " + cresistance;
     }
+
     double ia, ic, ig, curcount_a, curcount_c, curcount_g;
     double lastvac, lastvag;
     double cresistance, triggerI, holdingI;
@@ -97,7 +107,8 @@
 	int gatelen = sim.gridSize;
 	gatelen += leadlen % sim.gridSize;
 	if (leadlen < gatelen) {
-	    x2 = x; y2 = y;
+			x2 = x;
+			y2 = y;
 	    return;
 	}
 	interpPoint(lead2, point2, gate[0], gatelen/leadlen, gatelen*dir);
@@ -138,22 +149,28 @@
 	drawPosts(g);
     }
 	
-    
     @Override
 	Point getPost(int n) {
 	return (n == 0) ? point1 : (n == 1) ? point2 : gate[1];
     }
 	
     @Override
-	int getPostCount() { return 3; }
+	int getPostCount() {
+		return 3;
+	}
+
     @Override
-	int getInternalNodeCount() { return 1; }
+	int getInternalNodeCount() {
+		return 1;
+	}
+
     @Override
 	double getPower() {
 	return (volts[anode]-volts[gnode])*ia + (volts[cnode]-volts[gnode])*ic;
     }
 
     double aresistance;
+
     @Override
 	void stamp() {
 	sim.stampNonLinear(nodes[anode]);
@@ -168,8 +185,7 @@
 	void doStep() {
 	double vac = volts[anode]-volts[cnode]; // typically negative
 	double vag = volts[anode]-volts[gnode]; // typically positive
-	if (Math.abs(vac-lastvac) > .01 ||
-	    Math.abs(vag-lastvag) > .01)
+		if (Math.abs(vac - lastvac) > .01 || Math.abs(vag - lastvag) > .01)
 	    sim.converged = false;
 	lastvac = vac;
 	lastvag = vag;
@@ -178,9 +194,12 @@
 	double iamult = 1/holdingI - icmult;
 	//System.out.println(icmult + " " + iamult);
 	aresistance = (-icmult*ic + ia*iamult > 1) ? .0105 : 10e5;
-	//System.out.println(vac + " " + vag + " " + sim.converged + " " + ic + " " + ia + " " + aresistance + " " + volts[inode] + " " + volts[gnode] + " " + volts[anode]);
+		// System.out.println(vac + " " + vag + " " + sim.converged + " " + ic +
+		// " " + ia + " " + aresistance + " " + volts[inode] + " " +
+		// volts[gnode] + " " + volts[anode]);
 	sim.stampResistor(nodes[anode], nodes[inode], aresistance);
     }
+
     @Override
 	void getInfo(String arr[]) {
 	arr[0] = "SCR";
@@ -193,12 +212,14 @@
 	arr[4] = "Vag = " + getVoltageText(vag);
 	arr[5] = "Vgc = " + getVoltageText(vgc);
     }
+
     @Override
 	void calculateCurrent() {
 	ic = (volts[cnode]-volts[gnode])/cresistance;
 	ia = (volts[anode]-volts[inode])/aresistance;
 	ig = -ic-ia;
     }
+
     @Override
 	public EditInfo getEditInfo(int n) {
 	// ohmString doesn't work here on linux
@@ -210,6 +231,7 @@
 	    return new EditInfo("Gate-Cathode Resistance (ohms)", cresistance, 0, 0);
 	return null;
     }
+
     @Override
 	public void setEditValue(int n, EditInfo ei) {
 	if (n == 0 && ei.value > 0)
@@ -220,4 +242,3 @@
 	    cresistance = ei.value;
     }
 }
-
# diff -Naurw src.org/SevenSegElm.java src/SevenSegElm.java...
--- src.org/SevenSegElm.java	2015-12-05 20:47:02.000000000 +0100
+++ src/SevenSegElm.java	2016-03-16 13:15:49.414710802 +0100
@@ -1,17 +1,23 @@
-
 import java.awt.Color;
 import java.awt.Graphics;
 import java.util.StringTokenizer;
 
     class SevenSegElm extends ChipElm {
-	public SevenSegElm(int xx, int yy) { super(xx, yy); }
-	public SevenSegElm(int xa, int ya, int xb, int yb, int f,
-			   StringTokenizer st) {
+	public SevenSegElm(int xx, int yy) {
+		super(xx, yy);
+	}
+
+	public SevenSegElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	    super(xa, ya, xb, yb, f, st);
 	}
+
 	@Override
-	String getChipName() { return "7-segment driver/display"; }
+	String getChipName() {
+		return "7-segment driver/display";
+	}
+
 	Color darkred;
+
 	@Override
 	void setupPins() {
 	    darkred = new Color(30, 0, 0);
@@ -26,6 +32,7 @@
 	    pins[5] = new Pin(2, SIDE_S, "f");
 	    pins[6] = new Pin(3, SIDE_S, "g");
 	}
+
 	@Override
 	void draw(Graphics g) {
 	    drawChip(g);
@@ -47,14 +54,23 @@
 	    setColor(g, 6);
 	    drawThickLine(g, xl, yl+cspc, xl+cspc, yl+cspc);
 	}
+
 	void setColor(Graphics g, int p) {
-	    g.setColor(pins[p].value ? Color.red :
-		       sim.printableCheckItem.getState() ? Color.white : darkred);
+		g.setColor(pins[p].value ? Color.red : sim.printableCheckItem.getState() ? Color.white : darkred);
 	}
+
 	@Override
-	int getPostCount() { return 7; }
+	int getPostCount() {
+		return 7;
+	}
+
 	@Override
-	int getVoltageSourceCount() { return 0; }
+	int getVoltageSourceCount() {
+		return 0;
+	}
+
 	@Override
-	int getDumpType() { return 157; }
+	int getDumpType() {
+		return 157;
+	}
     }
# diff -Naurw src.org/SparkGapElm.java src/SparkGapElm.java...
--- src.org/SparkGapElm.java	2015-12-05 20:47:00.000000000 +0100
+++ src/SparkGapElm.java	2016-03-16 13:15:56.274587014 +0100
@@ -1,4 +1,3 @@
-
 import java.awt.Graphics;
 import java.awt.Point;
 import java.awt.Polygon;
@@ -7,6 +6,7 @@
 class SparkGapElm extends CircuitElm {
     double resistance, onresistance, offresistance, breakdown, holdcurrent;
     boolean state;
+
     public SparkGapElm(int xx, int yy) {
 	super(xx, yy);
 	offresistance = 1e9;
@@ -15,24 +15,32 @@
 	holdcurrent = 0.001;
 	state = false;
     }
-    public SparkGapElm(int xa, int ya, int xb, int yb, int f,
-		       StringTokenizer st) {
+
+	public SparkGapElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	super(xa, ya, xb, yb, f);
 	onresistance = new Double(st.nextToken()).doubleValue();
 	offresistance = new Double(st.nextToken()).doubleValue();
 	breakdown = new Double(st.nextToken()).doubleValue();
 	holdcurrent = new Double(st.nextToken()).doubleValue();
     }
+
     @Override
-	boolean nonLinear() {return true;}
+	boolean nonLinear() {
+		return true;
+	}
+
     @Override
-	int getDumpType() { return 187; }
+	int getDumpType() {
+		return 187;
+	}
+
     @Override
 	String dump() {
-	return super.dump() + " " + onresistance + " " + offresistance + " "
-	    + breakdown + " " + holdcurrent;
+		return super.dump() + " " + onresistance + " " + offresistance + " " + breakdown + " " + holdcurrent;
     }
+
     Polygon arrow1, arrow2;
+
     @Override
 	void setPoints() {
 	super.setPoints();
@@ -88,11 +96,13 @@
 	resistance = (state) ? onresistance : offresistance;
 	sim.stampResistor(nodes[0], nodes[1], resistance);
     }
+
     @Override
 	void stamp() {
 	sim.stampNonLinear(nodes[0]);
 	sim.stampNonLinear(nodes[1]);
     }
+
     @Override
 	void getInfo(String arr[]) {
 	arr[0] = "spark gap";
@@ -102,6 +112,7 @@
 	arr[5] = "Roff = " + getUnitText(offresistance, CirSim.ohmString);
 	arr[6] = "Vbreakdown = " + getUnitText(breakdown, "V");
     }
+
     @Override
 	public EditInfo getEditInfo(int n) {
 	// ohmString doesn't work here on linux
@@ -115,6 +126,7 @@
 	    return new EditInfo("Holding current (A)", holdcurrent, 0, 0);
 	return null;
     }
+
     @Override
 	public void setEditValue(int n, EditInfo ei) {
 	if (ei.value > 0 && n == 0)
@@ -126,7 +138,9 @@
 	if (ei.value > 0 && n == 3)
 	    holdcurrent = ei.value;
     }
+
     @Override
-	boolean needsShortcut() { return false; }
+	boolean needsShortcut() {
+		return false;
+	}
 }
-
# diff -Naurw src.org/SquareRailElm.java src/SquareRailElm.java...
--- src.org/SquareRailElm.java	2015-12-05 20:47:02.000000000 +0100
+++ src/SquareRailElm.java	2016-03-16 13:16:06.334405483 +0100
@@ -1,6 +1,10 @@
-
     class SquareRailElm extends RailElm {
-	public SquareRailElm(int xx, int yy) { super(xx, yy, WF_SQUARE); }
+	public SquareRailElm(int xx, int yy) {
+		super(xx, yy, WF_SQUARE);
+	}
+
 	@Override
-	Class getDumpClass() { return RailElm.class; }
+	Class<RailElm> getDumpClass() {
+		return RailElm.class;
+	}
     }
# diff -Naurw src.org/SweepElm.java src/SweepElm.java...
--- src.org/SweepElm.java	2015-12-05 20:46:58.000000000 +0100
+++ src/SweepElm.java	2016-03-16 13:16:10.786325147 +0100
@@ -1,4 +1,3 @@
-
 import java.awt.Checkbox;
 import java.awt.Color;
 import java.awt.Graphics;
@@ -11,12 +10,14 @@
 	
     public SweepElm(int xx, int yy) {
 	super(xx, yy);
-	minF = 20; maxF = 4000;
+		minF = 20;
+		maxF = 4000;
 	maxV = 5;
 	sweepTime = .1;
 	flags = FLAG_BIDIR;
 	reset();
     }
+
     public SweepElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	super(xa, ya, xb, yb, f);
 	minF = new Double(st.nextToken()).doubleValue();
@@ -25,22 +26,30 @@
 	sweepTime = new Double(st.nextToken()).doubleValue();
 	reset();
     }
+
     @Override
-	int getDumpType() { return 170; }
+	int getDumpType() {
+		return 170;
+	}
+
     @Override
-	int getPostCount() { return 1; }
+	int getPostCount() {
+		return 1;
+	}
+
     final int circleSize = 17;
 
     @Override
 	String dump() {
-	return super.dump() + " " + minF + " " + maxF + " " + maxV + " " +
-	    sweepTime;
+		return super.dump() + " " + minF + " " + maxF + " " + maxV + " " + sweepTime;
     }
+
     @Override
 	void setPoints() {
 	super.setPoints();
 	lead1 = interpPoint(point1, point2, 1-circleSize/dn);
     }
+
     @Override
 	void draw(Graphics g) {
 	setBbox(point1, point2, circleSize);
@@ -48,11 +57,11 @@
 	drawThickLine(g, point1, lead1);
 	g.setColor(needsHighlight() ? selectColor : Color.gray);
 	setPowerColor(g, false);
-	int xc = point2.x; int yc = point2.y;
+		int xc = point2.x;
+		int yc = point2.y;
 	drawThickCircle(g, xc, yc, circleSize);
 	int wl = 8;
-	adjustBbox(xc-circleSize, yc-circleSize,
-		   xc+circleSize, yc+circleSize);
+		adjustBbox(xc - circleSize, yc - circleSize, xc + circleSize, yc + circleSize);
 	int i;
 	int xl = 10;
 	int ox = -1, oy = -1;
@@ -68,7 +77,8 @@
 	    int yy = yc+(int) (.95*Math.sin(i*pi*w/xl)*wl);
 	    if (ox != -1)
 		drawThickLine(g, ox, oy, xc+i, yy);
-	    ox = xc+i; oy = yy;
+			ox = xc + i;
+			oy = yy;
 	}
 	if (sim.showValuesCheckItem.getState()) {
 	    String s = getShortUnitText(frequency, "Hz");
@@ -86,8 +96,10 @@
 	void stamp() {
 	sim.stampVoltageSource(0, nodes[0], voltSource);
     }
+
     double fadd, fmul, freqTime, savedTimeStep;
     int dir = 1;
+
     void setParams() {
 	if (frequency < minF || frequency > maxF) {
 	    frequency = minF;
@@ -103,6 +115,7 @@
 	}
 	savedTimeStep = sim.timeStep;
     }
+
     @Override
 	void reset() {
 	frequency = minF;
@@ -110,7 +123,9 @@
 	dir = 1;
 	setParams();
     }
+
     double v;
+
     @Override
 	void startIteration() {
 	// has timestep been changed?
@@ -133,27 +148,37 @@
 	    dir = 1;
 	}
     }
+
     @Override
 	void doStep() {
 	sim.updateVoltageSource(0, nodes[0], voltSource, v);
     }
 	
     @Override
-	double getVoltageDiff() { return volts[0]; }
+	double getVoltageDiff() {
+		return volts[0];
+	}
+
     @Override
-	int getVoltageSourceCount() { return 1; }
+	int getVoltageSourceCount() {
+		return 1;
+	}
+
     @Override
-	boolean hasGroundConnection(int n1) { return true; }
+	boolean hasGroundConnection(int n1) {
+		return true;
+	}
+
     @Override
 	void getInfo(String arr[]) {
 	arr[0] = "sweep " + (((flags & FLAG_LOG) == 0) ? "(linear)" : "(log)");
 	arr[1] = "I = " + getCurrentDText(getCurrent());
 	arr[2] = "V = " + getVoltageText(volts[0]);
 	arr[3] = "f = " + getUnitText(frequency, "Hz");
-	arr[4] = "range = " + getUnitText(minF, "Hz") + " .. " +
-	    getUnitText(maxF, "Hz");
+		arr[4] = "range = " + getUnitText(minF, "Hz") + " .. " + getUnitText(maxF, "Hz");
 	arr[5] = "time = " + getUnitText(sweepTime, "s");
     }
+
     @Override
 	public EditInfo getEditInfo(int n) {
 	if (n == 0)
@@ -176,6 +201,7 @@
 	}
 	return null;
     }
+
     @Override
 	public void setEditValue(int n, EditInfo ei) {
 	double maxfreq = 1/(8*sim.timeStep);
@@ -206,4 +232,3 @@
 	setParams();
     }
 }
-    
# diff -Naurw src.org/Switch2Elm.java src/Switch2Elm.java...
--- src.org/Switch2Elm.java	2015-12-05 20:47:00.000000000 +0100
+++ src/Switch2Elm.java	2016-03-16 13:16:16.666219044 +0100
@@ -1,4 +1,3 @@
-
 import java.awt.Checkbox;
 import java.awt.Graphics;
 import java.awt.Point;
@@ -12,18 +11,23 @@
 	    super(xx, yy, false);
 	    noDiagonal = true;
 	}
+
 	Switch2Elm(int xx, int yy, boolean mm) {
 	    super(xx, yy, mm);
 	    noDiagonal = true;
 	}
-	public Switch2Elm(int xa, int ya, int xb, int yb, int f,
-			  StringTokenizer st) {
+
+	public Switch2Elm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	    super(xa, ya, xb, yb, f, st);
 	    link = new Integer(st.nextToken()).intValue();
 	    noDiagonal = true;
 	}
+
 	@Override
-	int getDumpType() { return 'S'; }
+	int getDumpType() {
+		return 'S';
+	}
+
 	@Override
 	String dump() {
 	    return super.dump() + " " + link;
@@ -31,6 +35,7 @@
 
 	final int openhs = 16;
 	Point swposts[], swpoles[];
+
 	@Override
 	void setPoints() {
 	    super.setPoints();
@@ -70,27 +75,35 @@
 		drawDots(g, swpoles[position], swposts[position], curcount);
 	    drawPosts(g);
 	}
+
 	@Override
 	Point getPost(int n) {
 	    return (n == 0) ? point1 : swposts[n-1];
 	}
+
 	@Override
-	int getPostCount() { return 3; }
+	int getPostCount() {
+		return 3;
+	}
+
 	@Override
 	void calculateCurrent() {
 	    if (position == 2)
 		current = 0;
 	}
+
 	@Override
 	void stamp() {
 	    if (position == 2) // in center?
 		return;
 	    sim.stampVoltageSource(nodes[0], nodes[position+1], voltSource, 0);
 	}
+
 	@Override
 	int getVoltageSourceCount() {
 	    return (position == 2) ? 0 : 1;
 	}
+
 	@Override
 	void toggle() {
 	    super.toggle();
@@ -106,17 +119,20 @@
 		}
 	    }
 	}
+
 	@Override
 	boolean getConnection(int n1, int n2) {
 	    if (position == 2)
 		return false;
 	    return comparePair(n1, n2, 0, 1+position);
 	}
+
 	@Override
 	void getInfo(String arr[]) {
 	    arr[0] = (link == 0) ? "switch (SPDT)" : "switch (DPDT)";
 	    arr[1] = "I = " + getCurrentDText(getCurrent());
 	}
+
 	@Override
 	public EditInfo getEditInfo(int n) {
 	    if (n == 1) {
@@ -126,6 +142,7 @@
 	    }
 	    return super.getEditInfo(n);
 	}
+
 	@Override
 	public void setEditValue(int n, EditInfo ei) {
 	    if (n == 1) {
@@ -138,5 +155,8 @@
 	    } else
 		super.setEditValue(n, ei);
 	}
-	boolean hasCenterOff() { return (flags & FLAG_CENTER_OFF) != 0; }
+
+	boolean hasCenterOff() {
+		return (flags & FLAG_CENTER_OFF) != 0;
+	}
     }
# diff -Naurw src.org/SwitchElm.java src/SwitchElm.java...
--- src.org/SwitchElm.java	2015-12-05 20:47:00.000000000 +0100
+++ src/SwitchElm.java	2016-03-16 13:16:22.130120448 +0100
@@ -1,4 +1,3 @@
-
 import java.awt.Checkbox;
 import java.awt.Graphics;
 import java.awt.Point;
@@ -8,20 +7,22 @@
     boolean momentary;
     // position 0 == closed, position 1 == open
     int position, posCount;
+
     public SwitchElm(int xx, int yy) {
 	super(xx, yy);
 	momentary = false;
 	position = 0;
 	posCount = 2;
     }
+
     SwitchElm(int xx, int yy, boolean mm) {
 	super(xx, yy);
 	position = (mm) ? 1 : 0;
 	momentary = mm;
 	posCount = 2;
     }
-    public SwitchElm(int xa, int ya, int xb, int yb, int f,
-		     StringTokenizer st) {
+
+	public SwitchElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	super(xa, ya, xb, yb, f);
 	String str = st.nextToken();
 	if (str.compareTo("true") == 0)
@@ -33,14 +34,19 @@
 	momentary = new Boolean(st.nextToken()).booleanValue();
 	posCount = 2;
     }
+
     @Override
-	int getDumpType() { return 's'; }
+	int getDumpType() {
+		return 's';
+	}
+
     @Override
 	String dump() {
 	return super.dump() + " " + position + " " + momentary;
     }
 
     Point ps, ps2;
+
     @Override
 	void setPoints() {
 	super.setPoints();
@@ -69,29 +75,35 @@
 	drawThickLine(g, ps, ps2);
 	drawPosts(g);
     }
+
     @Override
 	void calculateCurrent() {
 	if (position == 1)
 	    current = 0;
     }
+
     @Override
 	void stamp() {
 	if (position == 0)
 	    sim.stampVoltageSource(nodes[0], nodes[1], voltSource, 0);
     }
+
     @Override
 	int getVoltageSourceCount() {
 	return (position == 1) ? 0 : 1;
     }
+
     void mouseUp() {
 	if (momentary)
 	    toggle();
     }
+
     void toggle() {
 	position++;
 	if (position >= posCount)
 	    position = 0;
     }
+
     @Override
 	void getInfo(String arr[]) {
 	arr[0] = (momentary) ? "push switch (SPST)" : "switch (SPST)";
@@ -104,10 +116,17 @@
 	    arr[3] = "I = " + getCurrentDText(getCurrent());
 	}
     }
+
     @Override
-	boolean getConnection(int n1, int n2) { return position == 0; }
+	boolean getConnection(int n1, int n2) {
+		return position == 0;
+	}
+
     @Override
-	boolean isWire() { return true; }
+	boolean isWire() {
+		return true;
+	}
+
     @Override
 	public EditInfo getEditInfo(int n) {
 	if (n == 0) {
@@ -117,6 +136,7 @@
 	}
 	return null;
     }
+
     @Override
 	public void setEditValue(int n, EditInfo ei) {
 	if (n == 0)
# diff -Naurw src.org/TappedTransformerElm.java src/TappedTransformerElm.java...
--- src.org/TappedTransformerElm.java	2015-12-05 20:47:00.000000000 +0100
+++ src/TappedTransformerElm.java	2016-03-16 13:16:30.697965842 +0100
@@ -1,4 +1,3 @@
-
 import java.awt.Graphics;
 import java.awt.Point;
 import java.util.StringTokenizer;
@@ -7,6 +6,7 @@
 	double inductance, ratio;
 	Point ptEnds[], ptCoil[], ptCore[];
 	double current[], curcount[];
+
 	public TappedTransformerElm(int xx, int yy) {
 	    super(xx, yy);
 	    inductance = 4;
@@ -15,8 +15,8 @@
 	    current  = new double[4];
 	    curcount = new double[4];
 	}
-	public TappedTransformerElm(int xa, int ya, int xb, int yb, int f,
-			      StringTokenizer st) {
+
+	public TappedTransformerElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	    super(xa, ya, xb, yb, f);
 	    inductance = new Double(st.nextToken()).doubleValue();
 	    ratio = new Double(st.nextToken()).doubleValue();
@@ -26,16 +26,21 @@
 	    current[1] = new Double(st.nextToken()).doubleValue();
 	    try {
 		current[2] = new Double(st.nextToken()).doubleValue();
-	    } catch (Exception e) { }
+		} catch (Exception e) {
+		}
 	    noDiagonal = true;
 	}
+
 	@Override
-	int getDumpType() { return 169; }
+	int getDumpType() {
+		return 169;
+	}
+
 	@Override
 	String dump() {
-	    return super.dump() + " " + inductance + " " + ratio + " " +
-		current[0] + " " + current[1] + " " + current[2];
+		return super.dump() + " " + inductance + " " + ratio + " " + current[0] + " " + current[1] + " " + current[2];
 	}
+
 	@Override
 	void draw(Graphics g) {
 	    int i;
@@ -47,8 +52,7 @@
 		if (i == 1)
 		    continue;
 		setPowerColor(g, current[i]*(volts[i]-volts[i+1]));
-		drawCoil(g, i > 1 ? -6 : 6,
-			 ptCoil[i], ptCoil[i+1], volts[i], volts[i+1]);
+			drawCoil(g, i > 1 ? -6 : 6, ptCoil[i], ptCoil[i + 1], volts[i], volts[i + 1]);
 	    }
 	    g.setColor(needsHighlight() ? selectColor : lightGrayColor);
 	    for (i = 0; i != 4; i += 2) {
@@ -101,18 +105,24 @@
 		interpPoint(ptEnds[0], ptEnds[2], ptCore[i+2], 1-cd, b);
 	    }
 	}
+
 	@Override
 	Point getPost(int n) {
 	    return ptEnds[n];
 	}
+
 	@Override
-	int getPostCount() { return 5; }
+	int getPostCount() {
+		return 5;
+	}
+
 	@Override
 	void reset() {
-	    current[0] = current[1] = volts[0] = volts[1] = volts[2] =
-		volts[3] = curcount[0] = curcount[1] = 0;
+		current[0] = current[1] = volts[0] = volts[1] = volts[2] = volts[3] = curcount[0] = curcount[1] = 0;
 	}
+
 	double a[];
+
 	@Override
 	void stamp() {
 	    // equations for transformer:
@@ -172,6 +182,7 @@
 	    voltdiff = new double[3];
 	    curSourceValue = new double[3];
 	}
+
 	@Override
 	void startIteration() {
 	    voltdiff[0] = volts[0]-volts[1];
@@ -184,13 +195,16 @@
 		    curSourceValue[i] += a[i*3+j]*voltdiff[j];
 	    }
 	}
+
 	double curSourceValue[], voltdiff[];
+
 	@Override
 	void doStep() {
 	    sim.stampCurrentSource(nodes[0], nodes[1], curSourceValue[0]);
 	    sim.stampCurrentSource(nodes[2], nodes[3], curSourceValue[1]);
 	    sim.stampCurrentSource(nodes[3], nodes[4], curSourceValue[2]);
  	}
+
 	@Override
 	void calculateCurrent() {
 	    voltdiff[0] = volts[0]-volts[1];
@@ -203,6 +217,7 @@
 		    current[i] += a[i*3+j]*voltdiff[j];
 	    }
 	}
+
 	@Override
 	void getInfo(String arr[]) {
 	    arr[0] = "transformer";
@@ -213,6 +228,7 @@
 	    //arr[5] = "I2 = " + getCurrentText(current2);
 	    arr[4] = "Vd2 = " + getVoltageText(volts[1]-volts[3]);
 	}
+
 	@Override
 	boolean getConnection(int n1, int n2) {
 	    if (comparePair(n1, n2, 0, 1))
@@ -225,6 +241,7 @@
 		return true;
 	    return false;
 	}
+
 	@Override
 	public EditInfo getEditInfo(int n) {
 	    if (n == 0)
@@ -233,6 +250,7 @@
 		return new EditInfo("Ratio", ratio, 1, 10).setDimensionless();
 	    return null;
 	}
+
 	@Override
 	public void setEditValue(int n, EditInfo ei) {
 	    if (n == 0)
# diff -Naurw src.org/TextElm.java src/TextElm.java...
--- src.org/TextElm.java	2015-12-05 20:47:00.000000000 +0100
+++ src/TextElm.java	2016-03-16 13:16:36.613859090 +0100
@@ -1,4 +1,3 @@
-
 import java.awt.Checkbox;
 import java.awt.Font;
 import java.awt.FontMetrics;
@@ -8,19 +7,20 @@
 
 class TextElm extends CircuitElm {
     String text;
-    Vector lines;
+	Vector<String> lines;
     int size;
     final int FLAG_CENTER = 1;
     final int FLAG_BAR = 2;
+
     public TextElm(int xx, int yy) {
 	super(xx, yy);
 	text = "hello";
-	lines = new Vector();
+		lines = new Vector<String>();
 	lines.add(text);
 	size = 24;
     }
-    public TextElm(int xa, int ya, int xb, int yb, int f,
-		   StringTokenizer st) {
+
+	public TextElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	super(xa, ya, xb, yb, f);
 	size = new Integer(st.nextToken()).intValue();
 	text = st.nextToken();
@@ -28,9 +28,10 @@
 	    text += ' ' + st.nextToken();
 	split();
     }
+
     void split() {
 	int i;
-	lines = new Vector();
+		lines = new Vector<String>();
 	StringBuffer sb = new StringBuffer(text);
 	for (i = 0; i < sb.length(); i++) {
 	    char c = sb.charAt(i);
@@ -47,12 +48,17 @@
 	}
 	lines.add(sb.toString());
     }
+
     @Override
 	String dump() {
 	return super.dump() + " " + size + " " + text;
     }
+
     @Override
-	int getDumpType() { return 'x'; }
+	int getDumpType() {
+		return 'x';
+	}
+
     @Override
 	void drag(int xx, int yy) {
 	x = xx;
@@ -60,6 +66,7 @@
 	x2 = xx+16;
 	y2 = yy;
     }
+
     @Override
 	void draw(Graphics g) {
 	g.setColor(needsHighlight() ? selectColor : lightGrayColor);
@@ -69,14 +76,14 @@
 	int i;
 	int maxw = -1;
 	for (i = 0; i != lines.size(); i++) {
-	    int w = fm.stringWidth((String) (lines.elementAt(i)));
+			int w = fm.stringWidth((lines.elementAt(i)));
 	    if (w > maxw)
 		maxw = w;
 	}
 	int cury = y;
 	setBbox(x, y, x, y);
 	for (i = 0; i != lines.size(); i++) {
-	    String s = (String) (lines.elementAt(i));
+			String s = (lines.elementAt(i));
 	    if ((flags & FLAG_CENTER) != 0)
 		x = (sim.winSize.width-fm.stringWidth(s))/2;
 	    g.drawString(s, x, cury);
@@ -84,13 +91,13 @@
 		int by = cury-fm.getAscent();
 		g.drawLine(x, by, x+fm.stringWidth(s)-1, by);
 	    }
-	    adjustBbox(x, cury-fm.getAscent(),
-		       x+fm.stringWidth(s), cury+fm.getDescent());
+			adjustBbox(x, cury - fm.getAscent(), x + fm.stringWidth(s), cury + fm.getDescent());
 	    cury += fm.getHeight();
 	}
 	x2 = boundingBox.x + boundingBox.width;
 	y2 = boundingBox.y + boundingBox.height;
     }
+
     @Override
 	public EditInfo getEditInfo(int n) {
 	if (n == 0) {
@@ -102,18 +109,17 @@
 	    return new EditInfo("Size", size, 5, 100);
 	if (n == 2) {
 	    EditInfo ei = new EditInfo("", 0, -1, -1);
-	    ei.checkbox =
-		new Checkbox("Center", (flags & FLAG_CENTER) != 0);
+			ei.checkbox = new Checkbox("Center", (flags & FLAG_CENTER) != 0);
 	    return ei;
 	}
 	if (n == 3) {
 	    EditInfo ei = new EditInfo("", 0, -1, -1);
-	    ei.checkbox =
-		new Checkbox("Draw Bar On Top", (flags & FLAG_BAR) != 0);
+			ei.checkbox = new Checkbox("Draw Bar On Top", (flags & FLAG_BAR) != 0);
 	    return ei;
 	}
 	return null;
     }
+
     @Override
 	public void setEditValue(int n, EditInfo ei) {
 	if (n == 0) {
@@ -135,13 +141,19 @@
 		flags &= ~FLAG_CENTER;
 	}
     }
+
     @Override
-	boolean isCenteredText() { return (flags & FLAG_CENTER) != 0; }
+	boolean isCenteredText() {
+		return (flags & FLAG_CENTER) != 0;
+	}
+
     @Override
 	void getInfo(String arr[]) {
 	arr[0] = text;
     }
+
     @Override
-	int getPostCount() { return 0; }
+	int getPostCount() {
+		return 0;
+	}
 }
-
# diff -Naurw src.org/ThermistorElm.java src/ThermistorElm.java...
--- src.org/ThermistorElm.java	2015-12-05 20:47:00.000000000 +0100
+++ src/ThermistorElm.java	2016-03-16 13:16:42.201758256 +0100
@@ -1,5 +1,3 @@
-
-
 import java.awt.Graphics;
 import java.awt.Label;
 import java.awt.Point;
@@ -11,34 +9,45 @@
     double resistance;
     Scrollbar slider;
     Label label;
+
     public ThermistorElm(int xx, int yy) {
 	super(xx, yy);
 	maxresistance = 1e9;
 	minresistance = 1e3;
 	createSlider();
     }
-    public ThermistorElm(int xa, int ya, int xb, int yb, int f,
-		       StringTokenizer st) {
+
+	public ThermistorElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	super(xa, ya, xb, yb, f);
 	minresistance = new Double(st.nextToken()).doubleValue();
 	maxresistance = new Double(st.nextToken()).doubleValue();
 	createSlider();
     }
+
     @Override
-	boolean nonLinear() {return true;}
+	boolean nonLinear() {
+		return true;
+	}
+
     @Override
-	int getDumpType() { return 188; }
+	int getDumpType() {
+		return 188;
+	}
+
     @Override
 	String dump() {
 	return super.dump() + " " + minresistance + " " + maxresistance;
     }
+
     Point ps3, ps4;
+
     void createSlider() {
 	CirSim.main.add(label = new Label("Temperature", Label.CENTER));
 	int value = 50;
 	CirSim.main.add(slider = new Scrollbar(Scrollbar.HORIZONTAL, value, 1, 0, 101));
 	CirSim.main.validate();
     }
+
     @Override
 	void setPoints() {
 	super.setPoints();
@@ -46,6 +55,7 @@
 	ps3 = new Point();
 	ps4 = new Point();
     }
+
     @Override
 	void delete() {
 	CirSim.main.remove(label);
@@ -70,6 +80,7 @@
 	double vd = volts[0] - volts[1];
 	current = vd/resistance;
     }
+
     @Override
 	void startIteration() {
 	double vd = volts[0] - volts[1];
@@ -77,15 +88,18 @@
 	resistance = minresistance;
 	//System.out.print(this + " res current set to " + current + "\n");
     }
+
     @Override
 	void doStep() {
 	sim.stampResistor(nodes[0], nodes[1], resistance);
     }
+
     @Override
 	void stamp() {
 	sim.stampNonLinear(nodes[0]);
 	sim.stampNonLinear(nodes[1]);
     }
+
     @Override
 	void getInfo(String arr[]) {
 	// FIXME
@@ -95,6 +109,7 @@
 	arr[4] = "Ron = " + getUnitText(minresistance, CirSim.ohmString);
 	arr[5] = "Roff = " + getUnitText(maxresistance, CirSim.ohmString);
     }
+
     @Override
 	public EditInfo getEditInfo(int n) {
 	// ohmString doesn't work here on linux
@@ -104,6 +119,7 @@
 	    return new EditInfo("Max resistance (ohms)", maxresistance, 0, 0);
 	return null;
     }
+
     @Override
 	public void setEditValue(int n, EditInfo ei) {
 	if (ei.value > 0 && n == 0)
@@ -112,4 +128,3 @@
 	    maxresistance = ei.value;
     }
 }
-
# diff -Naurw src.org/TimerElm.java src/TimerElm.java...
--- src.org/TimerElm.java	2015-12-05 20:47:00.000000000 +0100
+++ src/TimerElm.java	2016-03-16 13:16:48.021653236 +0100
@@ -1,4 +1,3 @@
-
 import java.util.StringTokenizer;
 
 class TimerElm extends ChipElm {
@@ -10,15 +9,25 @@
     final int N_CTL = 4;
     final int N_OUT = 5;
     final int N_RST = 6;
+
     @Override
-	int getDefaultFlags() { return FLAG_RESET; }
-    public TimerElm(int xx, int yy) { super(xx, yy); }
-    public TimerElm(int xa, int ya, int xb, int yb, int f,
-		    StringTokenizer st) {
+	int getDefaultFlags() {
+		return FLAG_RESET;
+	}
+
+	public TimerElm(int xx, int yy) {
+		super(xx, yy);
+	}
+
+	public TimerElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	super(xa, ya, xb, yb, f, st);
     }
+
     @Override
-	String getChipName() { return "555 Timer"; }
+	String getChipName() {
+		return "555 Timer";
+	}
+
     @Override
 	void setupPins() {
 	sizeX = 3;
@@ -34,9 +43,16 @@
 	pins[N_OUT].output = pins[N_OUT].state = true;
 	pins[N_RST] = new Pin(1, SIDE_E, "rst");
     }
+
     @Override
-	boolean nonLinear() { return true; }
-    boolean hasReset() { return (flags & FLAG_RESET) != 0; }
+	boolean nonLinear() {
+		return true;
+	}
+
+	boolean hasReset() {
+		return (flags & FLAG_RESET) != 0;
+	}
+
     @Override
 	void stamp() {
 	// stamp voltage divider to put ctl pin at 2/3 V
@@ -47,6 +63,7 @@
 	// discharge pin
 	sim.stampNonLinear(nodes[N_DIS]);
     }
+
     @Override
 	void calculateCurrent() {
 	// need current for V, discharge, control; output current is
@@ -55,7 +72,9 @@
 	pins[N_CTL].current = -volts[N_CTL]/10000 - pins[N_VIN].current;
 	pins[N_DIS].current = (!out && !setOut) ? -volts[N_DIS]/10 : 0;
     }
+
     boolean setOut, out;
+
     @Override
 	void startIteration() {
 	out = volts[N_OUT] > volts[N_VIN]/2;
@@ -66,6 +85,7 @@
 	if (volts[N_THRES] > volts[N_CTL] || (hasReset() && volts[N_RST] < .7))
 	    out = false;
     }
+
     @Override
 	void doStep() {
 	// if output is low, discharge pin 0.  we use a small
@@ -76,14 +96,21 @@
 	if (!out && !setOut)
 	    sim.stampResistor(nodes[N_DIS], 0, 10);
 	// output
-	sim.updateVoltageSource(0, nodes[N_OUT], pins[N_OUT].voltSource,
-			    out ? volts[N_VIN] : 0);
+		sim.updateVoltageSource(0, nodes[N_OUT], pins[N_OUT].voltSource, out ? volts[N_VIN] : 0);
     }
+
     @Override
-	int getPostCount() { return hasReset() ? 7 : 6; }
-    @Override
-	int getVoltageSourceCount() { return 1; }
+	int getPostCount() {
+		return hasReset() ? 7 : 6;
+	}
+
     @Override
-	int getDumpType() { return 165; }
+	int getVoltageSourceCount() {
+		return 1;
 }
     
+	@Override
+	int getDumpType() {
+		return 165;
+	}
+}
# diff -Naurw src.org/TransformerElm.java src/TransformerElm.java...
--- src.org/TransformerElm.java	2015-12-05 20:47:02.000000000 +0100
+++ src/TransformerElm.java	2016-03-16 13:16:53.273558470 +0100
@@ -1,4 +1,3 @@
-
 import java.awt.Checkbox;
 import java.awt.Graphics;
 import java.awt.Point;
@@ -10,6 +9,7 @@
 	double current[], curcount[];
 	int width;
 	public static final int FLAG_BACK_EULER = 2;
+
 	public TransformerElm(int xx, int yy) {
 	    super(xx, yy);
 	    inductance = 4;
@@ -20,8 +20,8 @@
 	    current  = new double[2];
 	    curcount = new double[2];
 	}
-	public TransformerElm(int xa, int ya, int xb, int yb, int f,
-			      StringTokenizer st) {
+
+	public TransformerElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	    super(xa, ya, xb, yb, f);
 	    width = max(32, abs(yb-ya));
 	    inductance = new Double(st.nextToken()).doubleValue();
@@ -33,9 +33,11 @@
 	    couplingCoef = .999;
 	    try {
 		couplingCoef = new Double(st.nextToken()).doubleValue();
-	    } catch (Exception e) { }
+		} catch (Exception e) {
+		}
 	    noDiagonal = true;
 	}
+
 	@Override
 	void drag(int xx, int yy) {
 	    xx = sim.snapGrid(xx);
@@ -43,17 +45,25 @@
 	    width = max(32, abs(yy-y));
 	    if (xx == x)
 	        yy = y;
-	    x2 = xx; y2 = yy;
+		x2 = xx;
+		y2 = yy;
 	    setPoints();
 	}
+
 	@Override
-	int getDumpType() { return 'T'; }
+	int getDumpType() {
+		return 'T';
+	}
+
 	@Override
 	String dump() {
-	    return super.dump() + " " + inductance + " " + ratio + " " +
-		current[0] + " " + current[1] + " " + couplingCoef;
+		return super.dump() + " " + inductance + " " + ratio + " " + current[0] + " " + current[1] + " " + couplingCoef;
+	}
+
+	boolean isTrapezoidal() {
+		return (flags & FLAG_BACK_EULER) == 0;
 	}
-	boolean isTrapezoidal() { return (flags & FLAG_BACK_EULER) == 0; }
+
 	@Override
 	void draw(Graphics g) {
 	    int i;
@@ -63,8 +73,7 @@
 	    }
 	    for (i = 0; i != 2; i++) {
 		setPowerColor(g, current[i]*(volts[i]-volts[i+2]));
-		drawCoil(g, dsign*(i == 1 ? -6 : 6),
-			 ptCoil[i], ptCoil[i+2], volts[i], volts[i+2]);
+			drawCoil(g, dsign * (i == 1 ? -6 : 6), ptCoil[i], ptCoil[i + 2], volts[i], volts[i + 2]);
 	    }
 	    g.setColor(needsHighlight() ? selectColor : lightGrayColor);
 	    for (i = 0; i != 2; i++) {
@@ -102,18 +111,24 @@
 		interpPoint(ptEnds[i], ptEnds[i+1], ptCore[i+1], 1-cd);
 	    }
 	}
+
 	@Override
 	Point getPost(int n) {
 	    return ptEnds[n];
 	}
+
 	@Override
-	int getPostCount() { return 4; }
+	int getPostCount() {
+		return 4;
+	}
+
 	@Override
 	void reset() {
-	    current[0] = current[1] = volts[0] = volts[1] = volts[2] =
-		volts[3] = curcount[0] = curcount[1] = 0;
+		current[0] = current[1] = volts[0] = volts[1] = volts[2] = volts[3] = curcount[0] = curcount[1] = 0;
 	}
+
 	double a1, a2, a3, a4;
+
 	@Override
 	void stamp() {
 	    // equations for transformer:
@@ -162,6 +177,7 @@
 	    sim.stampRightSide(nodes[2]);
 	    sim.stampRightSide(nodes[3]);
 	}
+
 	@Override
 	void startIteration() {
 	    double voltdiff1 = volts[0]-volts[2];
@@ -174,12 +190,15 @@
 		curSourceValue2 = current[1];
 	    } 
 	}
+
 	double curSourceValue1, curSourceValue2;
+
 	@Override
 	void doStep() {
 	    sim.stampCurrentSource(nodes[0], nodes[2], curSourceValue1);
 	    sim.stampCurrentSource(nodes[1], nodes[3], curSourceValue2);
  	}
+
 	@Override
 	void calculateCurrent() {
 	    double voltdiff1 = volts[0]-volts[2];
@@ -187,6 +206,7 @@
 	    current[0] = voltdiff1*a1 + voltdiff2*a2 + curSourceValue1;
 	    current[1] = voltdiff1*a3 + voltdiff2*a4 + curSourceValue2;
 	}
+
 	@Override
 	void getInfo(String arr[]) {
 	    arr[0] = "transformer";
@@ -197,6 +217,7 @@
 	    arr[5] = "I1 = " + getCurrentText(current[0]);
 	    arr[6] = "I2 = " + getCurrentText(current[1]);
 	}
+
 	@Override
 	boolean getConnection(int n1, int n2) {
 	    if (comparePair(n1, n2, 0, 2))
@@ -205,6 +226,7 @@
 		return true;
 	    return false;
 	}
+
 	@Override
 	public EditInfo getEditInfo(int n) {
 	    if (n == 0)
@@ -212,16 +234,15 @@
 	    if (n == 1)
 		return new EditInfo("Ratio", ratio, 1, 10).setDimensionless();
 	    if (n == 2)
-		return new EditInfo("Coupling Coefficient", couplingCoef, 0, 1).
-		    setDimensionless();
+			return new EditInfo("Coupling Coefficient", couplingCoef, 0, 1).setDimensionless();
 	    if (n == 3) {
 		EditInfo ei = new EditInfo("", 0, -1, -1);
-		ei.checkbox = new Checkbox("Trapezoidal Approximation",
-					   isTrapezoidal());
+			ei.checkbox = new Checkbox("Trapezoidal Approximation", isTrapezoidal());
 		return ei;
 	    }
 	    return null;
 	}
+
 	@Override
 	public void setEditValue(int n, EditInfo ei) {
 	    if (n == 0)
# diff -Naurw src.org/TransistorElm.java src/TransistorElm.java...
--- src.org/TransistorElm.java	2015-12-05 20:47:00.000000000 +0100
+++ src/TransistorElm.java	2016-03-16 13:16:58.037472503 +0100
@@ -1,4 +1,3 @@
-
 import java.awt.Checkbox;
 import java.awt.Color;
 import java.awt.Graphics;
@@ -12,14 +11,15 @@
 	double fgain;
 	double gmin;
 	final int FLAG_FLIP = 1;
+
 	TransistorElm(int xx, int yy, boolean pnpflag) {
 	    super(xx, yy);
 	    pnp = (pnpflag) ? -1 : 1;
 	    beta = 100;
 	    setup();
 	}
-	public TransistorElm(int xa, int ya, int xb, int yb, int f,
-		      StringTokenizer st) {
+
+	public TransistorElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	    super(xa, ya, xb, yb, f);
 	    pnp = new Integer(st.nextToken()).intValue();
 	    beta = 100;
@@ -34,25 +34,34 @@
 	    }
 	    setup();
 	}
+
 	void setup() {
 	    vcrit = vt * Math.log(vt/(Math.sqrt(2)*leakage));
 	    fgain = beta/(beta+1);
 	    noDiagonal = true;
 	}
+
 	@Override
-	boolean nonLinear() { return true; }
+	boolean nonLinear() {
+		return true;
+	}
+
 	@Override
 	void reset() {
 	    volts[0] = volts[1] = volts[2] = 0;
 	    lastvbc = lastvbe = curcount_c = curcount_e = curcount_b = 0;
 	}
+
 	@Override
-	int getDumpType() { return 't'; }
+	int getDumpType() {
+		return 't';
+	}
+
 	@Override
 	String dump() {
-	    return super.dump() + " " + pnp + " " + (volts[0]-volts[1]) + " " +
-		(volts[0]-volts[2]) + " " + beta;
+		return super.dump() + " " + pnp + " " + (volts[0] - volts[1]) + " " + (volts[0] - volts[2]) + " " + beta;
 	}
+
 	double ic, ie, ib, curcount_c, curcount_e, curcount_b;
 	Polygon rectPoly, arrowPoly;
 	
@@ -91,24 +100,32 @@
 		g.setFont(unitsFont);
 		int ds = sign(dx);
 		g.drawString("B", base.x-10*ds, base.y-5);
-		g.drawString("C", coll[0].x-3+9*ds, coll[0].y+4); // x+6 if ds=1, -12 if -1
+			g.drawString("C", coll[0].x - 3 + 9 * ds, coll[0].y + 4); // x+6 if
+																		// ds=1,
+																		// -12
+																		// if -1
 		g.drawString("E", emit[0].x-3+9*ds, emit[0].y+4);
 	    }
 	    drawPosts(g);
 	}
+
 	@Override
 	Point getPost(int n) {
 	    return (n == 0) ? point1 : (n == 1) ? coll[0] : emit[0];
 	}
 	
 	@Override
-	int getPostCount() { return 3; }
+	int getPostCount() {
+		return 3;
+	}
+
 	@Override
 	double getPower() {
 	    return (volts[0]-volts[2])*ib + (volts[1]-volts[2])*ic;
 	}
 
 	Point rect[], coll[], emit[], base;
+
 	@Override
 	void setPoints() {
 	    super.setPoints();
@@ -148,6 +165,7 @@
 	static final double rgain = .5;
 	double vcrit;
 	double lastvbc, lastvbe;
+
 	double limitStep(double vnew, double vold) {
 	    double arg;
 	    double oo = vnew;
@@ -168,12 +186,14 @@
 	    }
 	    return(vnew);
 	}
+
 	@Override
 	void stamp() {
 	    sim.stampNonLinear(nodes[0]);
 	    sim.stampNonLinear(nodes[1]);
 	    sim.stampNonLinear(nodes[2]);
 	}
+
 	@Override
 	void doStep() {
 	    double vbc = volts[0]-volts[1]; // typically negative
@@ -183,7 +203,8 @@
 		sim.converged = false;
 	    gmin = 0;
 	    if (sim.subIterations > 100) {
-		// if we have trouble converging, put a conductance in parallel with all P-N junctions.
+			// if we have trouble converging, put a conductance in parallel with
+			// all P-N junctions.
 		// Gradually increase the conductance value for each iteration.
 		gmin = Math.exp(-9*Math.log(10)*(1-sim.subIterations/3000.));
 		if (gmin > .1)
@@ -196,29 +217,33 @@
 	    lastvbe = vbe;
 	    double pcoef = vdcoef*pnp;
 	    double expbc = Math.exp(vbc*pcoef);
-	    /*if (expbc > 1e13 || Double.isInfinite(expbc))
-	      expbc = 1e13;*/
+		/*
+		 * if (expbc > 1e13 || Double.isInfinite(expbc)) expbc = 1e13;
+		 */
 	    double expbe = Math.exp(vbe*pcoef);
 	    if (expbe < 1)
 		expbe = 1;
-	    /*if (expbe > 1e13 || Double.isInfinite(expbe))
-	      expbe = 1e13;*/
+		/*
+		 * if (expbe > 1e13 || Double.isInfinite(expbe)) expbe = 1e13;
+		 */
 	    ie = pnp*leakage*(-(expbe-1)+rgain*(expbc-1));
 	    ic = pnp*leakage*(fgain*(expbe-1)-(expbc-1));
 	    ib = -(ie+ic);
 	    //System.out.println("gain " + ic/ib);
-	    //System.out.print("T " + vbc + " " + vbe + " " + ie + " " + ic + "\n");
+		// System.out.print("T " + vbc + " " + vbe + " " + ie + " " + ic +
+		// "\n");
 	    double gee = -leakage*vdcoef*expbe;
 	    double gec = rgain*leakage*vdcoef*expbc;
 	    double gce = -gee*fgain;
 	    double gcc = -gec*(1/rgain);
 
-	    /*System.out.print("gee = " + gee + "\n");
-	    System.out.print("gec = " + gec + "\n");
-	    System.out.print("gce = " + gce + "\n");
-	    System.out.print("gcc = " + gcc + "\n");
-	    System.out.print("gce+gcc = " + (gce+gcc) + "\n");
-	    System.out.print("gee+gec = " + (gee+gec) + "\n");*/
+		/*
+		 * System.out.print("gee = " + gee + "\n"); System.out.print("gec = " +
+		 * gec + "\n"); System.out.print("gce = " + gce + "\n");
+		 * System.out.print("gcc = " + gcc + "\n"); System.out.print(
+		 * "gce+gcc = " + (gce+gcc) + "\n"); System.out.print("gee+gec = " +
+		 * (gee+gec) + "\n");
+		 */
 	    
 	    // stamps from page 302 of Pillage.  Node 0 is the base,
 	    // node 1 the collector, node 2 the emitter.  Also stamp
@@ -239,10 +264,10 @@
 	    sim.stampRightSide(nodes[1], -ic + gce*vbe + gcc*vbc);
 	    sim.stampRightSide(nodes[2], -ie + gee*vbe + gec*vbc);
 	}
+
 	@Override
 	void getInfo(String arr[]) {
-	    arr[0] = "transistor (" + ((pnp == -1) ? "PNP)" : "NPN)") + " beta=" +
-		showFormat.format(beta);
+		arr[0] = "transistor (" + ((pnp == -1) ? "PNP)" : "NPN)") + " beta=" + showFormat.format(beta);
 	    double vbc = volts[0]-volts[1];
 	    double vbe = volts[0]-volts[2];
 	    double vce = volts[1]-volts[2];
@@ -256,31 +281,42 @@
 	    arr[5] = "Vbc = " + getVoltageText(vbc);
 	    arr[6] = "Vce = " + getVoltageText(vce);
 	}
+
 	@Override
 	double getScopeValue(int x) {
 	    switch (x) {
-	    case Scope.VAL_IB: return ib;
-	    case Scope.VAL_IC: return ic;
-	    case Scope.VAL_IE: return ie;
-	    case Scope.VAL_VBE: return volts[0]-volts[2];
-	    case Scope.VAL_VBC: return volts[0]-volts[1];
-	    case Scope.VAL_VCE: return volts[1]-volts[2];
+		case Scope.VAL_IB:
+			return ib;
+		case Scope.VAL_IC:
+			return ic;
+		case Scope.VAL_IE:
+			return ie;
+		case Scope.VAL_VBE:
+			return volts[0] - volts[2];
+		case Scope.VAL_VBC:
+			return volts[0] - volts[1];
+		case Scope.VAL_VCE:
+			return volts[1] - volts[2];
 	    }
 	    return 0;
 	}
+
 	@Override
 	String getScopeUnits(int x) {
 	    switch (x) {
-	    case Scope.VAL_IB: case Scope.VAL_IC:
-	    case Scope.VAL_IE: return "A";
-	    default: return "V";
+		case Scope.VAL_IB:
+		case Scope.VAL_IC:
+		case Scope.VAL_IE:
+			return "A";
+		default:
+			return "V";
 	    }
 	}
+
 	@Override
 	public EditInfo getEditInfo(int n) {
 	    if (n == 0)
-		return new EditInfo("Beta/hFE", beta, 10, 1000).
-		    setDimensionless();
+			return new EditInfo("Beta/hFE", beta, 10, 1000).setDimensionless();
 	    if (n == 1) {
 		EditInfo ei = new EditInfo("", 0, -1, -1);
 		ei.checkbox = new Checkbox("Swap E/C", (flags & FLAG_FLIP) != 0);
@@ -288,6 +324,7 @@
 	    }
 	    return null;
 	}
+
 	@Override
 	public void setEditValue(int n, EditInfo ei) {
 	    if (n == 0) {
@@ -302,6 +339,9 @@
 		setPoints();
 	    }
 	}
+
 	@Override
-	boolean canViewInScope() { return true; }
+	boolean canViewInScope() {
+		return true;
+	}
     }
# diff -Naurw src.org/TransLineElm.java src/TransLineElm.java...
--- src.org/TransLineElm.java	2015-12-05 20:47:02.000000000 +0100
+++ src/TransLineElm.java	2016-03-16 13:17:05.097345111 +0100
@@ -1,4 +1,3 @@
-
 import java.awt.Color;
 import java.awt.Graphics;
 import java.awt.Point;
@@ -8,6 +7,7 @@
     double delay, imped;
     double voltageL[], voltageR[];
     int lenSteps, ptr, width;
+
     public TransLineElm(int xx, int yy) {
 	super(xx, yy);
 	delay = 1000*sim.timeStep;
@@ -15,8 +15,8 @@
 	noDiagonal = true;
 	reset();
     }
-    public TransLineElm(int xa, int ya, int xb, int yb, int f,
-			StringTokenizer st) {
+
+	public TransLineElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	super(xa, ya, xb, yb, f);
 	delay = new Double(st.nextToken()).doubleValue();
 	imped = new Double(st.nextToken()).doubleValue();
@@ -26,16 +26,27 @@
 	noDiagonal = true;
 	reset();
     }
+
     @Override
-	int getDumpType() { return 171; }
+	int getDumpType() {
+		return 171;
+	}
+
     @Override
-	int getPostCount() { return 4; }
+	int getPostCount() {
+		return 4;
+	}
+
     @Override
-	int getInternalNodeCount() { return 2; }
+	int getInternalNodeCount() {
+		return 2;
+	}
+
     @Override
 	String dump() {
 	return super.dump() + " " + delay + " " + imped + " " + width + " " + 0.;
     }
+
     @Override
 	void drag(int xx, int yy) {
 	xx = sim.snapGrid(xx);
@@ -49,7 +60,8 @@
 	    yy = y;
 	    width = w1;
 	}
-	x2 = xx; y2 = yy;
+		x2 = xx;
+		y2 = yy;
 	setPoints();
     }
 	
@@ -60,7 +72,7 @@
 	if (sim.timeStep == 0)
 	    return;
 	lenSteps = (int) (delay/sim.timeStep);
-	System.out.println(lenSteps + " steps");
+		// System.out.println(lenSteps + " steps");
 	if (lenSteps > 100000)
 	    voltageL = voltageR = null;
 	else {
@@ -70,6 +82,7 @@
 	ptr = 0;
 	super.reset();
     }
+
     @Override
 	void setPoints() {
 	super.setPoints();
@@ -89,6 +102,7 @@
 	posts = new Point[] { p3, p4, point1, point2 };
 	inner = new Point[] { p7, p8, p5, p6 };
     }
+
     @Override
 	void draw(Graphics g) {
 	setBbox(posts[0], posts[3], 0);
@@ -97,8 +111,7 @@
 	double segf = 1./segments;
 	int i;
 	g.setColor(Color.darkGray);
-	g.fillRect(inner[2].x, inner[2].y,
-		   inner[1].x-inner[2].x+2, inner[1].y-inner[2].y+2);
+		g.fillRect(inner[2].x, inner[2].y, inner[1].x - inner[2].x + 2, inner[1].y - inner[2].y + 2);
 	for (i = 0; i != 4; i++) {
 	    setVoltageColor(g, volts[i]);
 	    drawThickLine(g, posts[i], inner[i]);
@@ -132,6 +145,7 @@
 
     int voltSource1, voltSource2;
     double current1, current2, curCount1, curCount2;
+
     @Override
 	void setVoltageSource(int n, int v) {
 	if (n == 0)
@@ -139,6 +153,7 @@
 	else
 	    voltSource2 = v;
     }
+
     @Override
 	void setCurrent(int v, double c) {
 	if (v == voltSource1)
@@ -164,12 +179,16 @@
 	}
 	voltageL[ptr] = volts[2]-volts[0] + volts[2]-volts[4];
 	voltageR[ptr] = volts[3]-volts[1] + volts[3]-volts[5];
-	//System.out.println(volts[2] + " " + volts[0] + " " + (volts[2]-volts[0]) + " " + (imped*current1) + " " + voltageL[ptr]);
-	/*System.out.println("sending fwd  " + currentL[ptr] + " " + current1);
-	  System.out.println("sending back " + currentR[ptr] + " " + current2);*/
+		// System.out.println(volts[2] + " " + volts[0] + " " +
+		// (volts[2]-volts[0]) + " " + (imped*current1) + " " + voltageL[ptr]);
+		/*
+		 * System.out.println("sending fwd  " + currentL[ptr] + " " + current1);
+		 * System.out.println("sending back " + currentR[ptr] + " " + current2);
+		 */
 	//System.out.println("sending back " + voltageR[ptr]);
 	ptr = (ptr+1) % lenSteps;
     }
+
     @Override
 	void doStep() {
 	if (voltageL == null) {
@@ -191,18 +210,24 @@
 	
     //double getVoltageDiff() { return volts[0]; }
     @Override
-	int getVoltageSourceCount() { return 2; }
+	int getVoltageSourceCount() {
+		return 2;
+	}
+
     @Override
-	boolean hasGroundConnection(int n1) { return false; }
+	boolean hasGroundConnection(int n1) {
+		return false;
+	}
+
     @Override
 	boolean getConnection(int n1, int n2) {
 	return false;
-	/*if (comparePair(n1, n2, 0, 1))
-	  return true;
-	  if (comparePair(n1, n2, 2, 3))
-	  return true;
-	  return false;*/
+		/*
+		 * if (comparePair(n1, n2, 0, 1)) return true; if (comparePair(n1, n2,
+		 * 2, 3)) return true; return false;
+		 */
     }
+
     @Override
 	void getInfo(String arr[]) {
 	arr[0] = "transmission line";
@@ -210,6 +235,7 @@
 	arr[2] = "length = " + getUnitText(2.9979e8*delay, "m");
 	arr[3] = "delay = " + getUnitText(delay, "s");
     }
+
     @Override
 	public EditInfo getEditInfo(int n) {
 	if (n == 0)
@@ -218,6 +244,7 @@
 	    return new EditInfo("Impedance (ohms)", imped, 0, 0);
 	return null;
     }
+
     @Override
 	public void setEditValue(int n, EditInfo ei) {
 	if (n == 0) {
@@ -230,4 +257,3 @@
 	}
     }
 }
-
# diff -Naurw src.org/TriacElm.java src/TriacElm.java...
--- src.org/TriacElm.java	2015-12-05 20:47:00.000000000 +0100
+++ src/TriacElm.java	2016-03-16 13:17:10.625245362 +0100
@@ -1,5 +1,3 @@
-
-
 import java.awt.Graphics;
 import java.awt.Point;
 import java.awt.Polygon;
@@ -18,13 +16,14 @@
     final int gnode = 2;
     final int inode = 3;
     Diode diode;
+
     public TriacElm(int xx, int yy) {
 	super(xx, yy);
 	setDefaults();
 	setup();
     }
-    public TriacElm(int xa, int ya, int xb, int yb, int f,
-		  StringTokenizer st) {
+
+	public TriacElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	super(xa, ya, xb, yb, f);
 	setDefaults();
 	try {
@@ -40,31 +39,41 @@
 	}
 	setup();
     }
+
     void setDefaults() {
 	cresistance = 50;
 	holdingI = .0082;
 	triggerI = .01;
     }
+
     void setup() {
 	diode = new Diode(sim);
 	diode.setup(.8, 0);
     }
+
     @Override
-	boolean nonLinear() { return true; }
+	boolean nonLinear() {
+		return true;
+	}
+
     @Override
 	void reset() {
 	volts[anode] = volts[cnode] = volts[gnode] = 0;
 	diode.reset();
 	lastvag = lastvac = curcount_a = curcount_c = curcount_g = 0;
     }
+
     @Override
-	int getDumpType() { return 183; }
+	int getDumpType() {
+		return 183;
+	}
+
     @Override
 	String dump() {
-	return super.dump() + " " + (volts[anode]-volts[cnode]) + " " +
-	    (volts[anode]-volts[gnode]) + " " + triggerI + " "+  holdingI + " " +
-	    cresistance;
+		return super.dump() + " " + (volts[anode] - volts[cnode]) + " " + (volts[anode] - volts[gnode]) + " " + triggerI
+				+ " " + holdingI + " " + cresistance;
     }
+
     double ia, ic, ig, curcount_a, curcount_c, curcount_g;
     double lastvac, lastvag;
     double cresistance, triggerI, holdingI;
@@ -98,7 +107,8 @@
 	int gatelen = sim.gridSize;
 	gatelen += leadlen % sim.gridSize;
 	if (leadlen < gatelen) {
-	    x2 = x; y2 = y;
+			x2 = x;
+			y2 = y;
 	    return;
 	}
 	interpPoint(lead2, point2, gate[0], gatelen/leadlen, gatelen*dir);
@@ -139,22 +149,28 @@
 	drawPosts(g);
     }
 	
-    
     @Override
 	Point getPost(int n) {
 	return (n == 0) ? point1 : (n == 1) ? point2 : gate[1];
     }
 	
     @Override
-	int getPostCount() { return 3; }
+	int getPostCount() {
+		return 3;
+	}
+
     @Override
-	int getInternalNodeCount() { return 1; }
+	int getInternalNodeCount() {
+		return 1;
+	}
+
     @Override
 	double getPower() {
 	return (volts[anode]-volts[gnode])*ia + (volts[cnode]-volts[gnode])*ic;
     }
 
     double aresistance;
+
     @Override
 	void stamp() {
 	sim.stampNonLinear(nodes[anode]);
@@ -169,8 +185,7 @@
 	void doStep() {
 	double vac = volts[anode]-volts[cnode]; // typically negative
 	double vag = volts[anode]-volts[gnode]; // typically positive
-	if (Math.abs(vac-lastvac) > .01 ||
-	    Math.abs(vag-lastvag) > .01)
+		if (Math.abs(vac - lastvac) > .01 || Math.abs(vag - lastvag) > .01)
 	    sim.converged = false;
 	lastvac = vac;
 	lastvag = vag;
@@ -179,9 +194,12 @@
 	double iamult = 1/holdingI - icmult;
 	//System.out.println(icmult + " " + iamult);
 	aresistance = (-icmult*ic + ia*iamult > 1) ? .0105 : 10e5;
-	//System.out.println(vac + " " + vag + " " + sim.converged + " " + ic + " " + ia + " " + aresistance + " " + volts[inode] + " " + volts[gnode] + " " + volts[anode]);
+		// System.out.println(vac + " " + vag + " " + sim.converged + " " + ic +
+		// " " + ia + " " + aresistance + " " + volts[inode] + " " +
+		// volts[gnode] + " " + volts[anode]);
 	sim.stampResistor(nodes[anode], nodes[inode], aresistance);
     }
+
     @Override
 	void getInfo(String arr[]) {
 	arr[0] = "SCR";
@@ -194,12 +212,14 @@
 	arr[4] = "Vag = " + getVoltageText(vag);
 	arr[5] = "Vgc = " + getVoltageText(vgc);
     }
+
     @Override
 	void calculateCurrent() {
 	ic = (volts[cnode]-volts[gnode])/cresistance;
 	ia = (volts[anode]-volts[inode])/aresistance;
 	ig = -ic-ia;
     }
+
     @Override
 	public EditInfo getEditInfo(int n) {
 	// ohmString doesn't work here on linux
@@ -211,6 +231,7 @@
 	    return new EditInfo("Gate-Cathode Resistance (ohms)", cresistance, 0, 0);
 	return null;
     }
+
     @Override
 	public void setEditValue(int n, EditInfo ei) {
 	if (n == 0 && ei.value > 0)
@@ -221,4 +242,3 @@
 	    cresistance = ei.value;
     }
 }
-
# diff -Naurw src.org/TriodeElm.java src/TriodeElm.java...
--- src.org/TriodeElm.java	2015-12-05 20:47:00.000000000 +0100
+++ src/TriodeElm.java	2016-03-16 13:17:19.525084770 +0100
@@ -1,4 +1,3 @@
-
 import java.awt.Color;
 import java.awt.Graphics;
 import java.awt.Point;
@@ -8,38 +7,49 @@
     double mu, kg1;
     double curcountp, curcountc, curcountg, currentp, currentg, currentc;
     final double gridCurrentR = 6000;
+
     public TriodeElm(int xx, int yy) {
 	super(xx, yy);
 	mu = 93;
 	kg1 = 680;
 	setup();
     }
-    public TriodeElm(int xa, int ya, int xb, int yb, int f,
-		     StringTokenizer st) {
+
+	public TriodeElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	super(xa, ya, xb, yb, f);
 	mu  = new Double(st.nextToken()).doubleValue();
 	kg1 = new Double(st.nextToken()).doubleValue();
 	setup();
     }
+
     void setup() {
 	noDiagonal = true;
     }
+
     @Override
-	boolean nonLinear() { return true; }
+	boolean nonLinear() {
+		return true;
+	}
+
     @Override
 	void reset() {
 	volts[0] = volts[1] = volts[2] = 0;
 	curcount = 0;
     }
+
     @Override
 	String dump() {
 	return super.dump() + " " + mu + " " + kg1;
     }
+
     @Override
-	int getDumpType() { return 173; }
+	int getDumpType() {
+		return 173;
+	}
 	
     Point plate[], grid[], cath[], midgrid, midcath;
     int circler;
+
     @Override
 	void setPoints() {
 	super.setPoints();
@@ -103,16 +113,24 @@
 	}
 	drawPosts(g);
     }
+
     @Override
 	Point getPost(int n) {
 	return (n == 0) ? plate[0] : (n == 1) ? grid[0] : cath[0];
     }
+
     @Override
-	int getPostCount() { return 3; }
+	int getPostCount() {
+		return 3;
+	}
+
     @Override
-	double getPower() { return (volts[0]-volts[2])*current; }
+	double getPower() {
+		return (volts[0] - volts[2]) * current;
+	}
 
     double lastv0, lastv1, lastv2;
+
     @Override
 	void doStep() {
 	double vs[] = new double[3];
@@ -132,9 +150,7 @@
 	int plate = 0;
 	double vgk = vs[grid] -vs[cath];
 	double vpk = vs[plate]-vs[cath];
-	if (Math.abs(lastv0-vs[0]) > .01 ||
-	    Math.abs(lastv1-vs[1]) > .01 ||
-	    Math.abs(lastv2-vs[2]) > .01)
+		if (Math.abs(lastv0 - vs[0]) > .01 || Math.abs(lastv1 - vs[1]) > .01 || Math.abs(lastv2 - vs[2]) > .01)
 	    sim.converged = false;
 	lastv0 = vs[0];
 	lastv1 = vs[1];
@@ -182,6 +198,7 @@
 	sim.stampNonLinear(nodes[1]);
 	sim.stampNonLinear(nodes[2]);
     }
+
     @Override
 	void getInfo(String arr[]) {
 	arr[0] = "triode";
@@ -192,8 +209,10 @@
 	arr[2] = "Vbc = " + getVoltageText(vbc);
 	arr[3] = "Vce = " + getVoltageText(vce);
     }
+
     // grid not connected to other terminals
     @Override
-	boolean getConnection(int n1, int n2) { return !(n1 == 1 || n2 == 1); }
+	boolean getConnection(int n1, int n2) {
+		return !(n1 == 1 || n2 == 1);
+	}
 }
-
# diff -Naurw src.org/TunnelDiodeElm.java src/TunnelDiodeElm.java...
--- src.org/TunnelDiodeElm.java	2015-12-05 20:47:00.000000000 +0100
+++ src/TunnelDiodeElm.java	2016-03-16 13:17:26.952950737 +0100
@@ -1,4 +1,3 @@
-
 import java.awt.Graphics;
 import java.awt.Point;
 import java.awt.Polygon;
@@ -9,17 +8,24 @@
 	super(xx, yy);
 	setup();
     }
-    public TunnelDiodeElm(int xa, int ya, int xb, int yb, int f,
-			  StringTokenizer st) {
+
+	public TunnelDiodeElm(int xa, int ya, int xb, int yb, int f, @SuppressWarnings("unused") StringTokenizer st) {
 	super(xa, ya, xb, yb, f);
 	setup();
     }
+
     @Override
-	boolean nonLinear() { return true; }
+	boolean nonLinear() {
+		return true;
+	}
+
     void setup() {
     }
+
     @Override
-	int getDumpType() { return 175; }
+	int getDumpType() {
+		return 175;
+	}
 	
     final int hs = 8;
     Polygon poly;
@@ -67,8 +73,10 @@
     }
 	
     double lastvoltdiff;
+
     double limitStep(double vnew, double vold) {
-	// Prevent voltage changes of more than 1V when iterating.  Wow, I thought it would be
+		// Prevent voltage changes of more than 1V when iterating. Wow, I
+		// thought it would be
 	// much harder than this to prevent convergence problems.
 	if (vnew > vold+1)
 	    return vold+1;
@@ -76,45 +84,48 @@
 	    return vold-1;
 	return vnew;
     }
+
     @Override
 	void stamp() {
 	sim.stampNonLinear(nodes[0]);
 	sim.stampNonLinear(nodes[1]);
     }
+
     static final double pvp = .1;
     static final double pip = 4.7e-3;
     static final double pvv = .37;
     static final double pvt = .026;
     static final double pvpp = .525;
     static final double piv = 370e-6;
+
     @Override
 	void doStep() {
 	double voltdiff = volts[0] - volts[1];
 	if (Math.abs(voltdiff-lastvoltdiff) > .01)
 	    sim.converged = false;
-	//System.out.println(voltdiff + " " + lastvoltdiff + " " + Math.abs(voltdiff-lastvoltdiff));
+		// System.out.println(voltdiff + " " + lastvoltdiff + " " +
+		// Math.abs(voltdiff-lastvoltdiff));
 	voltdiff = limitStep(voltdiff, lastvoltdiff);
 	lastvoltdiff = voltdiff;
 	
-	double i = pip*Math.exp(-pvpp/pvt)*(Math.exp(voltdiff/pvt)-1) +
-	    pip*(voltdiff/pvp)*Math.exp(1-voltdiff/pvp) +
-	    piv*Math.exp(voltdiff-pvv);
-	
-	double geq = pip*Math.exp(-pvpp/pvt)*Math.exp(voltdiff/pvt)/pvt +
-	    pip*Math.exp(1-voltdiff/pvp)/pvp
-	    - Math.exp(1-voltdiff/pvp)*pip*voltdiff/(pvp*pvp) +
-	    Math.exp(voltdiff-pvv)*piv;
+		double i = pip * Math.exp(-pvpp / pvt) * (Math.exp(voltdiff / pvt) - 1)
+				+ pip * (voltdiff / pvp) * Math.exp(1 - voltdiff / pvp) + piv * Math.exp(voltdiff - pvv);
+
+		double geq = pip * Math.exp(-pvpp / pvt) * Math.exp(voltdiff / pvt) / pvt
+				+ pip * Math.exp(1 - voltdiff / pvp) / pvp - Math.exp(1 - voltdiff / pvp) * pip * voltdiff / (pvp * pvp)
+				+ Math.exp(voltdiff - pvv) * piv;
 	double nc = i - geq*voltdiff;
 	sim.stampConductance(nodes[0], nodes[1], geq);
 	sim.stampCurrentSource(nodes[0], nodes[1], nc);
     }
+
     @Override
 	void calculateCurrent() {
 	double voltdiff = volts[0] - volts[1];
-	current = pip*Math.exp(-pvpp/pvt)*(Math.exp(voltdiff/pvt)-1) +
-	    pip*(voltdiff/pvp)*Math.exp(1-voltdiff/pvp) +
-	    piv*Math.exp(voltdiff-pvv);
+		current = pip * Math.exp(-pvpp / pvt) * (Math.exp(voltdiff / pvt) - 1)
+				+ pip * (voltdiff / pvp) * Math.exp(1 - voltdiff / pvp) + piv * Math.exp(voltdiff - pvv);
     }
+
     @Override
 	void getInfo(String arr[]) {
 	arr[0] = "tunnel diode";
# diff -Naurw src.org/VarRailElm.java src/VarRailElm.java...
--- src.org/VarRailElm.java	2015-12-05 20:47:02.000000000 +0100
+++ src/VarRailElm.java	2016-03-16 13:17:33.292836337 +0100
@@ -1,4 +1,3 @@
-
 import java.awt.Label;
 import java.awt.Scrollbar;
 import java.util.StringTokenizer;
@@ -7,26 +6,32 @@
 	Scrollbar slider;
 	Label label;
 	String sliderText;
+
 	public VarRailElm(int xx, int yy) {
 	    super(xx, yy, WF_VAR);
 	    sliderText = "Voltage";
 	    frequency = maxVoltage;
 	    createSlider();
 	}
-	public VarRailElm(int xa, int ya, int xb, int yb, int f,
-		       StringTokenizer st) {
+
+	public VarRailElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	    super(xa, ya, xb, yb, f, st);
 	    sliderText = st.nextToken();
 	    while (st.hasMoreTokens())
 		sliderText += ' ' + st.nextToken();
 	    createSlider();
 	}
+
 	@Override
 	String dump() {
 	    return super.dump() + " " + sliderText;
 	}
+
 	@Override
-	int getDumpType() { return 172; }
+	int getDumpType() {
+		return 172;
+	}
+
 	void createSlider() {
 	    waveform = WF_VAR;
 	    CirSim.main.add(label = new Label(sliderText, Label.CENTER));
@@ -34,16 +39,19 @@
 	    CirSim.main.add(slider = new Scrollbar(Scrollbar.HORIZONTAL, value, 1, 0, 101));
 	    CirSim.main.validate();
 	}
+
 	@Override
 	double getVoltage() {
 	    frequency = slider.getValue() * (maxVoltage-bias) / 100. + bias;
 	    return frequency;
 	}
+
 	@Override
 	void delete() {
 	    CirSim.main.remove(label);
 	    CirSim.main.remove(slider);
 	}
+
 	@Override
 	public EditInfo getEditInfo(int n) {
 	    if (n == 0)
@@ -57,6 +65,7 @@
 	    }
 	    return null;
 	}
+
 	@Override
 	public void setEditValue(int n, EditInfo ei) {
 	    if (n == 0)
# diff -Naurw src.org/VCOElm.java src/VCOElm.java...
--- src.org/VCOElm.java	2015-12-05 20:47:00.000000000 +0100
+++ src/VCOElm.java	2016-03-16 13:17:39.732720135 +0100
@@ -1,15 +1,20 @@
-
 import java.awt.Graphics;
 import java.util.StringTokenizer;
 
     class VCOElm extends ChipElm {
-	public VCOElm(int xx, int yy) { super(xx, yy); }
-	public VCOElm(int xa, int ya, int xb, int yb, int f,
-		      StringTokenizer st) {
+	public VCOElm(int xx, int yy) {
+		super(xx, yy);
+	}
+
+	public VCOElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	    super(xa, ya, xb, yb, f, st);
 	}
+
 	@Override
-	String getChipName() { return "VCO"; }
+	String getChipName() {
+		return "VCO";
+	}
+
 	@Override
 	void setupPins() {
 	    sizeX = 2;
@@ -25,8 +30,12 @@
 	    pins[5] = new Pin(3, SIDE_E, "R2");
 	    pins[5].output = true;
 	}
+
 	@Override
-	boolean nonLinear() { return true; }
+	boolean nonLinear() {
+		return true;
+	}
+
 	@Override
 	void stamp() {
 	    // output pin
@@ -41,9 +50,11 @@
 	    sim.stampNonLinear(nodes[2]);
 	    sim.stampNonLinear(nodes[3]);
 	}
+
 	final double cResistance = 1e6;
 	double cCurrent;
 	int cDir;
+
 	@Override
 	void doStep() {
 	    double vc = volts[3]-volts[2];
@@ -72,26 +83,37 @@
 	    sim.stampMatrix(nodes[3], cur2, -dir);
 	    cDir = dir;
 	}
+
+	@SuppressWarnings("unused")
 	// can't do this in calculateCurrent() because it's called before
         // we get pins[4].current and pins[5].current, which we need
 	void computeCurrent() {
 	    if (cResistance == 0)
 		return ;
-	    double c = cDir*(pins[4].current + pins[5].current) +
-		(volts[3]-volts[2])/cResistance;
+		double c = cDir * (pins[4].current + pins[5].current) + (volts[3] - volts[2]) / cResistance;
 	    pins[2].current = -c;
 	    pins[3].current = c;
 	    pins[0].current = -pins[4].current;
 	}
+
 	@Override
 	void draw(Graphics g) {
 	    computeCurrent();
 	    drawChip(g);
 	}
+
 	@Override
-	int getPostCount() { return 6; }
+	int getPostCount() {
+		return 6;
+	}
+
 	@Override
-	int getVoltageSourceCount() { return 3; }
+	int getVoltageSourceCount() {
+		return 3;
+	}
+
 	@Override
-	int getDumpType() { return 158; }
+	int getDumpType() {
+		return 158;
+	}
     }
# diff -Naurw src.org/VoltageElm.java src/VoltageElm.java...
--- src.org/VoltageElm.java	2015-12-05 20:47:00.000000000 +0100
+++ src/VoltageElm.java	2016-03-16 13:17:46.920590429 +0100
@@ -1,4 +1,3 @@
-
 import java.awt.Choice;
 import java.awt.Color;
 import java.awt.Graphics;
@@ -15,8 +14,8 @@
     static final int WF_SAWTOOTH = 4;
     static final int WF_PULSE = 5;
     static final int WF_VAR = 6;
-    double frequency, maxVoltage, freqTimeZero, bias,
-	phaseShift, dutyCycle;
+	double frequency, maxVoltage, freqTimeZero, bias, phaseShift, dutyCycle;
+
     VoltageElm(int xx, int yy, int wf) {
 	super(xx, yy);
 	waveform = wf;
@@ -25,8 +24,8 @@
 	dutyCycle = .5;
 	reset();
     }
-    public VoltageElm(int xa, int ya, int xb, int yb, int f,
-		      StringTokenizer st) {
+
+	public VoltageElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	super(xa, ya, xb, yb, f);
 	maxVoltage = 5;
 	frequency = 40;
@@ -47,66 +46,76 @@
 	}
 	reset();
     }
+
     @Override
-	int getDumpType() { return 'v'; }
+	int getDumpType() {
+		return 'v';
+	}
+
     @Override
 	String dump() {
-	return super.dump() + " " + waveform + " " + frequency + " " +
-	    maxVoltage + " " + bias + " " + phaseShift + " " +
-	    dutyCycle;
-    }
-    /*void setCurrent(double c) {
-      current = c;
-      System.out.print("v current set to " + c + "\n");
-      }*/
+		return super.dump() + " " + waveform + " " + frequency + " " + maxVoltage + " " + bias + " " + phaseShift + " "
+				+ dutyCycle;
+	}
+	/*
+	 * void setCurrent(double c) { current = c; System.out.print(
+	 * "v current set to " + c + "\n"); }
+	 */
 
     @Override
 	void reset() {
 	freqTimeZero = 0;
 	curcount = 0;
     }
+
     double triangleFunc(double x) {
 	if (x < pi)
 	    return x*(2/pi)-1;
 	return 1-(x-pi)*(2/pi);
     }
+
     @Override
 	void stamp() {
 	if (waveform == WF_DC)
-	    sim.stampVoltageSource(nodes[0], nodes[1], voltSource,
-			       getVoltage());
+			sim.stampVoltageSource(nodes[0], nodes[1], voltSource, getVoltage());
 	else
 	    sim.stampVoltageSource(nodes[0], nodes[1], voltSource);
     }
+
     @Override
 	void doStep() {
 	if (waveform != WF_DC)
-	    sim.updateVoltageSource(nodes[0], nodes[1], voltSource,
-				getVoltage());
+			sim.updateVoltageSource(nodes[0], nodes[1], voltSource, getVoltage());
     }
+
     double getVoltage() {
 	double w = 2*pi*(sim.t-freqTimeZero)*frequency + phaseShift;
 	switch (waveform) {
-	case WF_DC: return maxVoltage+bias;
-	case WF_AC: return Math.sin(w)*maxVoltage+bias;
+		case WF_DC:
+			return maxVoltage + bias;
+		case WF_AC:
+			return Math.sin(w) * maxVoltage + bias;
 	case WF_SQUARE:
-	    return bias+((w % (2*pi) > (2*pi*dutyCycle)) ?
-			 -maxVoltage : maxVoltage);
+			return bias + ((w % (2 * pi) > (2 * pi * dutyCycle)) ? -maxVoltage : maxVoltage);
 	case WF_TRIANGLE:
 	    return bias+triangleFunc(w % (2*pi))*maxVoltage;
 	case WF_SAWTOOTH:
 	    return bias+(w % (2*pi))*(maxVoltage/pi)-maxVoltage;
 	case WF_PULSE:
 	    return ((w % (2*pi)) < 1) ? maxVoltage+bias : bias;
-	default: return 0;
+		default:
+			return 0;
 	}
     }
+
     final int circleSize = 17;
+
     @Override
 	void setPoints() {
 	super.setPoints();
 	calcLeads((waveform == WF_DC || waveform == WF_VAR) ? 8 : circleSize*2);
     }
+
     @Override
 	void draw(Graphics g) {
 	setBbox(x, y, x2, y2);
@@ -141,15 +150,14 @@
     void drawWaveform(Graphics g, Point center) {
 	g.setColor(needsHighlight() ? selectColor : Color.gray);
 	setPowerColor(g, false);
-	int xc = center.x; int yc = center.y;
+		int xc = center.x;
+		int yc = center.y;
 	drawThickCircle(g, xc, yc, circleSize);
 	int wl = 8;
-	adjustBbox(xc-circleSize, yc-circleSize,
-		   xc+circleSize, yc+circleSize);
+		adjustBbox(xc - circleSize, yc - circleSize, xc + circleSize, yc + circleSize);
 	int xc2;
 	switch (waveform) {
-	case WF_DC:
-	{
+		case WF_DC: {
 	    break;
 	}
 	case WF_SQUARE:
@@ -173,8 +181,7 @@
 	    drawThickLine(g, xc   , yc-wl, xc   , yc+wl);
 	    drawThickLine(g, xc   , yc+wl, xc+wl, yc   );
 	    break;
-	case WF_TRIANGLE:
-	{
+		case WF_TRIANGLE: {
 	    int xl = 5;
 	    drawThickLine(g, xc-xl*2, yc   , xc-xl, yc-wl);
 	    drawThickLine(g, xc-xl, yc-wl, xc, yc);
@@ -182,8 +189,7 @@
 	    drawThickLine(g, xc+xl, yc+wl, xc+xl*2, yc);
 	    break;
 	}
-	case WF_AC:
-	{
+		case WF_AC: {
 	    int i;
 	    int xl = 10;
 	    int ox = -1, oy = -1;
@@ -191,7 +197,8 @@
 		int yy = yc+(int) (.95*Math.sin(i*pi/xl)*wl);
 		if (ox != -1)
 		    drawThickLine(g, ox, oy, xc+i, yy);
-		ox = xc+i; oy = yy;
+				ox = xc + i;
+				oy = yy;
 	    }
 	    break;
 	}
@@ -207,24 +214,42 @@
 	int getVoltageSourceCount() {
 	return 1;
     }
+
     @Override
-	double getPower() { return -getVoltageDiff()*current; }
+	double getPower() {
+		return -getVoltageDiff() * current;
+	}
+
     @Override
-	double getVoltageDiff() { return volts[1] - volts[0]; }
+	double getVoltageDiff() {
+		return volts[1] - volts[0];
+	}
+
     @Override
 	void getInfo(String arr[]) {
 	switch (waveform) {
-	case WF_DC: case WF_VAR:
-	    arr[0] = "voltage source"; break;
-	case WF_AC:       arr[0] = "A/C source"; break;
-	case WF_SQUARE:   arr[0] = "square wave gen"; break;
-	case WF_PULSE:    arr[0] = "pulse gen"; break;
-	case WF_SAWTOOTH: arr[0] = "sawtooth gen"; break;
-	case WF_TRIANGLE: arr[0] = "triangle gen"; break;
+		case WF_DC:
+		case WF_VAR:
+			arr[0] = "voltage source";
+			break;
+		case WF_AC:
+			arr[0] = "A/C source";
+			break;
+		case WF_SQUARE:
+			arr[0] = "square wave gen";
+			break;
+		case WF_PULSE:
+			arr[0] = "pulse gen";
+			break;
+		case WF_SAWTOOTH:
+			arr[0] = "sawtooth gen";
+			break;
+		case WF_TRIANGLE:
+			arr[0] = "triangle gen";
+			break;
 	}
 	arr[1] = "I = " + getCurrentText(getCurrent());
-	arr[2] = ((this instanceof RailElm) ? "V = " : "Vd = ") +
-	    getVoltageText(getVoltageDiff());
+		arr[2] = ((this instanceof RailElm) ? "V = " : "Vd = ") + getVoltageText(getVoltageDiff());
 	if (waveform != WF_DC && waveform != WF_VAR) {
 	    arr[3] = "f = " + getUnitText(frequency, "Hz");
 	    arr[4] = "Vmax = " + getVoltageText(maxVoltage);
@@ -232,16 +257,15 @@
 	    if (bias != 0)
 		arr[i++] = "Voff = " + getVoltageText(bias);
 	    else if (frequency > 500)
-		arr[i++] = "wavelength = " +
-		    getUnitText(2.9979e8/frequency, "m");
+				arr[i++] = "wavelength = " + getUnitText(2.9979e8 / frequency, "m");
 	    arr[i++] = "P = " + getUnitText(getPower(), "W");
 	}
     }
+
     @Override
 	public EditInfo getEditInfo(int n) {
 	if (n == 0)
-	    return new EditInfo(waveform == WF_DC ? "Voltage" :
-				"Max Voltage", maxVoltage, -20, 20);
+			return new EditInfo(waveform == WF_DC ? "Voltage" : "Max Voltage", maxVoltage, -20, 20);
 	if (n == 1) {
 	    EditInfo ei =  new EditInfo("Waveform", waveform, -1, -1);
 	    ei.choice = new Choice();
@@ -261,13 +285,12 @@
 	if (n == 3)
 	    return new EditInfo("DC Offset (V)", bias, -20, 20);
 	if (n == 4)
-	    return new EditInfo("Phase Offset (degrees)", phaseShift*180/pi,
-				-180, 180).setDimensionless();
+			return new EditInfo("Phase Offset (degrees)", phaseShift * 180 / pi, -180, 180).setDimensionless();
 	if (n == 5 && waveform == WF_SQUARE)
-	    return new EditInfo("Duty Cycle", dutyCycle*100, 0, 100).
-		setDimensionless();
+			return new EditInfo("Duty Cycle", dutyCycle * 100, 0, 100).setDimensionless();
 	return null;
     }
+
     @Override
 	public void setEditValue(int n, EditInfo ei) {
 	if (n == 0)
@@ -294,8 +317,7 @@
 	    } else if (waveform != WF_DC && ow == WF_DC) {
 		ei.newDialog = true;
 	    }
-	    if ((waveform == WF_SQUARE || ow == WF_SQUARE) &&
-		waveform != ow)
+			if ((waveform == WF_SQUARE || ow == WF_SQUARE) && waveform != ow)
 		ei.newDialog = true;
 	    setPoints();
 	}
# diff -Naurw src.org/WireElm.java src/WireElm.java...
--- src.org/WireElm.java	2015-12-05 20:46:58.000000000 +0100
+++ src/WireElm.java	2016-03-16 13:17:53.028480217 +0100
@@ -1,16 +1,19 @@
-
 import java.awt.Checkbox;
 import java.awt.Graphics;
 import java.util.StringTokenizer;
 
     class WireElm extends CircuitElm {
-	public WireElm(int xx, int yy) { super(xx, yy); }
-	public WireElm(int xa, int ya, int xb, int yb, int f,
-		       StringTokenizer st) {
+	public WireElm(int xx, int yy) {
+		super(xx, yy);
+	}
+
+	public WireElm(int xa, int ya, int xb, int yb, int f, @SuppressWarnings("unused") StringTokenizer st) {
 	    super(xa, ya, xb, yb, f);
 	}
+
 	static final int FLAG_SHOWCURRENT = 1;
 	static final int FLAG_SHOWVOLTAGE = 2;
+
 	@Override
 	void draw(Graphics g) {
 	    setVoltageColor(g, volts[0]);
@@ -26,32 +29,52 @@
 	    }
 	    drawPosts(g);
 	}
+
 	@Override
 	void stamp() {
 	    sim.stampVoltageSource(nodes[0], nodes[1], voltSource, 0);
 	}
+
 	boolean mustShowCurrent() {
 	    return (flags & FLAG_SHOWCURRENT) != 0;
 	}
+
 	boolean mustShowVoltage() {
 	    return (flags & FLAG_SHOWVOLTAGE) != 0;
 	}
+
 	@Override
-	int getVoltageSourceCount() { return 1; }
+	int getVoltageSourceCount() {
+		return 1;
+	}
+
 	@Override
 	void getInfo(String arr[]) {
 	    arr[0] = "wire";
 	    arr[1] = "I = " + getCurrentDText(getCurrent());
 	    arr[2] = "V = " + getVoltageText(volts[0]);
 	}
+
 	@Override
-	int getDumpType() { return 'w'; }
+	int getDumpType() {
+		return 'w';
+	}
+
 	@Override
-	double getPower() { return 0; }
+	double getPower() {
+		return 0;
+	}
+
 	@Override
-	double getVoltageDiff() { return volts[0]; }
+	double getVoltageDiff() {
+		return volts[0];
+	}
+
 	@Override
-	boolean isWire() { return true; }
+	boolean isWire() {
+		return true;
+	}
+
 	@Override
 	public EditInfo getEditInfo(int n) {
 	    if (n == 0) {
@@ -66,6 +89,7 @@
 	    }
 	    return null;
 	}
+
 	@Override
 	public void setEditValue(int n, EditInfo ei) {
 	    if (n == 0) {
@@ -81,6 +105,9 @@
 		    flags &= ~FLAG_SHOWVOLTAGE;
 	    }
 	}
+
 	@Override
-	boolean needsShortcut() { return true; }
+	boolean needsShortcut() {
+		return true;
+	}
     }
# diff -Naurw src.org/XorGateElm.java src/XorGateElm.java...
--- src.org/XorGateElm.java	2015-12-05 20:47:00.000000000 +0100
+++ src/XorGateElm.java	2016-03-16 13:18:00.808339840 +0100
@@ -1,14 +1,19 @@
-
 import java.util.StringTokenizer;
 
     class XorGateElm extends OrGateElm {
-	public XorGateElm(int xx, int yy) { super(xx, yy); }
-	public XorGateElm(int xa, int ya, int xb, int yb, int f,
-			  StringTokenizer st) {
+	public XorGateElm(int xx, int yy) {
+		super(xx, yy);
+	}
+
+	public XorGateElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	    super(xa, ya, xb, yb, f, st);
 	}
+
 	@Override
-	String getGateName() { return "XOR gate"; }
+	String getGateName() {
+		return "XOR gate";
+	}
+
 	@Override
 	boolean calcFunction() {
 	    int i;
@@ -17,6 +22,9 @@
 		f ^= getInput(i);
 	    return f;
 	}
+
 	@Override
-	int getDumpType() { return 154; }
+	int getDumpType() {
+		return 154;
+	}
     }
# diff -Naurw src.org/ZenerElm.java src/ZenerElm.java...
--- src.org/ZenerElm.java	2015-12-05 20:47:00.000000000 +0100
+++ src/ZenerElm.java	2016-03-16 13:18:08.000210069 +0100
@@ -1,4 +1,3 @@
-
 import java.awt.Graphics;
 import java.awt.Point;
 import java.awt.Polygon;
@@ -12,19 +11,24 @@
 	zvoltage = default_zvoltage;
 	setup();
     }
-    public ZenerElm(int xa, int ya, int xb, int yb, int f,
-		    StringTokenizer st) {
+
+	public ZenerElm(int xa, int ya, int xb, int yb, int f, StringTokenizer st) {
 	super(xa, ya, xb, yb, f, st);
 	zvoltage = new Double(st.nextToken()).doubleValue();
 	setup();
     }
+
     @Override
 	void setup() {
 	diode.leakage = 5e-6; // 1N4004 is 5.0 uAmp
 	super.setup();
     }
+
     @Override
-	int getDumpType() { return 'z'; }
+	int getDumpType() {
+		return 'z';
+	}
+
     @Override
 	String dump() {
 	return super.dump() + " " + zvoltage;
@@ -83,6 +87,7 @@
 	arr[0] = "Zener diode";
 	arr[5] = "Vz = " + getVoltageText(zvoltage);
     }
+
     @Override
 	public EditInfo getEditInfo(int n) {
 	if (n == 0)
@@ -91,6 +96,7 @@
 	    return new EditInfo("Zener Voltage @ 5mA", zvoltage, 1, 25);
 	return null;
     } 
+
     @Override
 	public void setEditValue(int n, EditInfo ei) {
 	if (n == 0)
